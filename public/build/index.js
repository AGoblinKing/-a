(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

  // node_modules/@mediapipe/holistic/holistic.js
  var require_holistic = __commonJS({
    "node_modules/@mediapipe/holistic/holistic.js"(exports) {
      (function() {
        "use strict";
        var x;
        function aa(a) {
          var b = 0;
          return function() {
            return b < a.length ? { done: false, value: a[b++] } : { done: true };
          };
        }
        var ba = typeof Object.defineProperties == "function" ? Object.defineProperty : function(a, b, c) {
          if (a == Array.prototype || a == Object.prototype)
            return a;
          a[b] = c.value;
          return a;
        };
        function ca(a) {
          a = [typeof globalThis == "object" && globalThis, a, typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global];
          for (var b = 0; b < a.length; ++b) {
            var c = a[b];
            if (c && c.Math == Math)
              return c;
          }
          throw Error("Cannot find global object");
        }
        var y = ca(this);
        function z(a, b) {
          if (b)
            a: {
              var c = y;
              a = a.split(".");
              for (var d = 0; d < a.length - 1; d++) {
                var e = a[d];
                if (!(e in c))
                  break a;
                c = c[e];
              }
              a = a[a.length - 1];
              d = c[a];
              b = b(d);
              b != d && b != null && ba(c, a, { configurable: true, writable: true, value: b });
            }
        }
        z("Symbol", function(a) {
          function b(g) {
            if (this instanceof b)
              throw new TypeError("Symbol is not a constructor");
            return new c(d + (g || "") + "_" + e++, g);
          }
          function c(g, f) {
            this.g = g;
            ba(this, "description", { configurable: true, writable: true, value: f });
          }
          if (a)
            return a;
          c.prototype.toString = function() {
            return this.g;
          };
          var d = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", e = 0;
          return b;
        });
        z("Symbol.iterator", function(a) {
          if (a)
            return a;
          a = Symbol("Symbol.iterator");
          for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), c = 0; c < b.length; c++) {
            var d = y[b[c]];
            typeof d === "function" && typeof d.prototype[a] != "function" && ba(d.prototype, a, { configurable: true, writable: true, value: function() {
              return da(aa(this));
            } });
          }
          return a;
        });
        function da(a) {
          a = { next: a };
          a[Symbol.iterator] = function() {
            return this;
          };
          return a;
        }
        function B(a) {
          var b = typeof Symbol != "undefined" && Symbol.iterator && a[Symbol.iterator];
          return b ? b.call(a) : { next: aa(a) };
        }
        function D(a) {
          if (!(a instanceof Array)) {
            a = B(a);
            for (var b, c = []; !(b = a.next()).done; )
              c.push(b.value);
            a = c;
          }
          return a;
        }
        var ea = typeof Object.create == "function" ? Object.create : function(a) {
          function b() {
          }
          b.prototype = a;
          return new b();
        }, fa;
        if (typeof Object.setPrototypeOf == "function")
          fa = Object.setPrototypeOf;
        else {
          var ha;
          a: {
            var ia = { a: true }, ja = {};
            try {
              ja.__proto__ = ia;
              ha = ja.a;
              break a;
            } catch (a) {
            }
            ha = false;
          }
          fa = ha ? function(a, b) {
            a.__proto__ = b;
            if (a.__proto__ !== b)
              throw new TypeError(a + " is not extensible");
            return a;
          } : null;
        }
        var ka = fa;
        function E(a, b) {
          a.prototype = ea(b.prototype);
          a.prototype.constructor = a;
          if (ka)
            ka(a, b);
          else
            for (var c in b)
              if (c != "prototype")
                if (Object.defineProperties) {
                  var d = Object.getOwnPropertyDescriptor(b, c);
                  d && Object.defineProperty(a, c, d);
                } else
                  a[c] = b[c];
          a.da = b.prototype;
        }
        function la() {
          this.l = false;
          this.i = null;
          this.h = void 0;
          this.g = 1;
          this.s = this.m = 0;
          this.j = null;
        }
        function ma(a) {
          if (a.l)
            throw new TypeError("Generator is already running");
          a.l = true;
        }
        la.prototype.o = function(a) {
          this.h = a;
        };
        function na(a, b) {
          a.j = { U: b, V: true };
          a.g = a.m || a.s;
        }
        la.prototype.return = function(a) {
          this.j = { return: a };
          this.g = this.s;
        };
        function F(a, b, c) {
          a.g = c;
          return { value: b };
        }
        function oa(a) {
          this.g = new la();
          this.h = a;
        }
        function pa(a, b) {
          ma(a.g);
          var c = a.g.i;
          if (c)
            return qa(a, "return" in c ? c["return"] : function(d) {
              return { value: d, done: true };
            }, b, a.g.return);
          a.g.return(b);
          return ra(a);
        }
        function qa(a, b, c, d) {
          try {
            var e = b.call(a.g.i, c);
            if (!(e instanceof Object))
              throw new TypeError("Iterator result " + e + " is not an object");
            if (!e.done)
              return a.g.l = false, e;
            var g = e.value;
          } catch (f) {
            return a.g.i = null, na(a.g, f), ra(a);
          }
          a.g.i = null;
          d.call(a.g, g);
          return ra(a);
        }
        function ra(a) {
          for (; a.g.g; )
            try {
              var b = a.h(a.g);
              if (b)
                return a.g.l = false, { value: b.value, done: false };
            } catch (c) {
              a.g.h = void 0, na(a.g, c);
            }
          a.g.l = false;
          if (a.g.j) {
            b = a.g.j;
            a.g.j = null;
            if (b.V)
              throw b.U;
            return { value: b.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function sa(a) {
          this.next = function(b) {
            ma(a.g);
            a.g.i ? b = qa(a, a.g.i.next, b, a.g.o) : (a.g.o(b), b = ra(a));
            return b;
          };
          this.throw = function(b) {
            ma(a.g);
            a.g.i ? b = qa(a, a.g.i["throw"], b, a.g.o) : (na(a.g, b), b = ra(a));
            return b;
          };
          this.return = function(b) {
            return pa(a, b);
          };
          this[Symbol.iterator] = function() {
            return this;
          };
        }
        function ta(a) {
          function b(d) {
            return a.next(d);
          }
          function c(d) {
            return a.throw(d);
          }
          return new Promise(function(d, e) {
            function g(f) {
              f.done ? d(f.value) : Promise.resolve(f.value).then(b, c).then(g, e);
            }
            g(a.next());
          });
        }
        function H(a) {
          return ta(new sa(new oa(a)));
        }
        z("Promise", function(a) {
          function b(f) {
            this.h = 0;
            this.i = void 0;
            this.g = [];
            this.o = false;
            var k = this.j();
            try {
              f(k.resolve, k.reject);
            } catch (h) {
              k.reject(h);
            }
          }
          function c() {
            this.g = null;
          }
          function d(f) {
            return f instanceof b ? f : new b(function(k) {
              k(f);
            });
          }
          if (a)
            return a;
          c.prototype.h = function(f) {
            if (this.g == null) {
              this.g = [];
              var k = this;
              this.i(function() {
                k.l();
              });
            }
            this.g.push(f);
          };
          var e = y.setTimeout;
          c.prototype.i = function(f) {
            e(f, 0);
          };
          c.prototype.l = function() {
            for (; this.g && this.g.length; ) {
              var f = this.g;
              this.g = [];
              for (var k = 0; k < f.length; ++k) {
                var h = f[k];
                f[k] = null;
                try {
                  h();
                } catch (l) {
                  this.j(l);
                }
              }
            }
            this.g = null;
          };
          c.prototype.j = function(f) {
            this.i(function() {
              throw f;
            });
          };
          b.prototype.j = function() {
            function f(l) {
              return function(n) {
                h || (h = true, l.call(k, n));
              };
            }
            var k = this, h = false;
            return { resolve: f(this.C), reject: f(this.l) };
          };
          b.prototype.C = function(f) {
            if (f === this)
              this.l(new TypeError("A Promise cannot resolve to itself"));
            else if (f instanceof b)
              this.F(f);
            else {
              a:
                switch (typeof f) {
                  case "object":
                    var k = f != null;
                    break a;
                  case "function":
                    k = true;
                    break a;
                  default:
                    k = false;
                }
              k ? this.v(f) : this.m(f);
            }
          };
          b.prototype.v = function(f) {
            var k = void 0;
            try {
              k = f.then;
            } catch (h) {
              this.l(h);
              return;
            }
            typeof k == "function" ? this.G(k, f) : this.m(f);
          };
          b.prototype.l = function(f) {
            this.s(2, f);
          };
          b.prototype.m = function(f) {
            this.s(1, f);
          };
          b.prototype.s = function(f, k) {
            if (this.h != 0)
              throw Error("Cannot settle(" + f + ", " + k + "): Promise already settled in state" + this.h);
            this.h = f;
            this.i = k;
            this.h === 2 && this.D();
            this.A();
          };
          b.prototype.D = function() {
            var f = this;
            e(function() {
              if (f.B()) {
                var k = y.console;
                typeof k !== "undefined" && k.error(f.i);
              }
            }, 1);
          };
          b.prototype.B = function() {
            if (this.o)
              return false;
            var f = y.CustomEvent, k = y.Event, h = y.dispatchEvent;
            if (typeof h === "undefined")
              return true;
            typeof f === "function" ? f = new f("unhandledrejection", { cancelable: true }) : typeof k === "function" ? f = new k("unhandledrejection", { cancelable: true }) : (f = y.document.createEvent("CustomEvent"), f.initCustomEvent("unhandledrejection", false, true, f));
            f.promise = this;
            f.reason = this.i;
            return h(f);
          };
          b.prototype.A = function() {
            if (this.g != null) {
              for (var f = 0; f < this.g.length; ++f)
                g.h(this.g[f]);
              this.g = null;
            }
          };
          var g = new c();
          b.prototype.F = function(f) {
            var k = this.j();
            f.J(k.resolve, k.reject);
          };
          b.prototype.G = function(f, k) {
            var h = this.j();
            try {
              f.call(k, h.resolve, h.reject);
            } catch (l) {
              h.reject(l);
            }
          };
          b.prototype.then = function(f, k) {
            function h(p2, m) {
              return typeof p2 == "function" ? function(q2) {
                try {
                  l(p2(q2));
                } catch (t) {
                  n(t);
                }
              } : m;
            }
            var l, n, r = new b(function(p2, m) {
              l = p2;
              n = m;
            });
            this.J(h(f, l), h(k, n));
            return r;
          };
          b.prototype.catch = function(f) {
            return this.then(void 0, f);
          };
          b.prototype.J = function(f, k) {
            function h() {
              switch (l.h) {
                case 1:
                  f(l.i);
                  break;
                case 2:
                  k(l.i);
                  break;
                default:
                  throw Error("Unexpected state: " + l.h);
              }
            }
            var l = this;
            this.g == null ? g.h(h) : this.g.push(h);
            this.o = true;
          };
          b.resolve = d;
          b.reject = function(f) {
            return new b(function(k, h) {
              h(f);
            });
          };
          b.race = function(f) {
            return new b(function(k, h) {
              for (var l = B(f), n = l.next(); !n.done; n = l.next())
                d(n.value).J(k, h);
            });
          };
          b.all = function(f) {
            var k = B(f), h = k.next();
            return h.done ? d([]) : new b(function(l, n) {
              function r(q2) {
                return function(t) {
                  p2[q2] = t;
                  m--;
                  m == 0 && l(p2);
                };
              }
              var p2 = [], m = 0;
              do
                p2.push(void 0), m++, d(h.value).J(r(p2.length - 1), n), h = k.next();
              while (!h.done);
            });
          };
          return b;
        });
        function ua(a, b) {
          a instanceof String && (a += "");
          var c = 0, d = false, e = { next: function() {
            if (!d && c < a.length) {
              var g = c++;
              return { value: b(g, a[g]), done: false };
            }
            d = true;
            return { done: true, value: void 0 };
          } };
          e[Symbol.iterator] = function() {
            return e;
          };
          return e;
        }
        var va = typeof Object.assign == "function" ? Object.assign : function(a, b) {
          for (var c = 1; c < arguments.length; c++) {
            var d = arguments[c];
            if (d)
              for (var e in d)
                Object.prototype.hasOwnProperty.call(d, e) && (a[e] = d[e]);
          }
          return a;
        };
        z("Object.assign", function(a) {
          return a || va;
        });
        z("Object.is", function(a) {
          return a ? a : function(b, c) {
            return b === c ? b !== 0 || 1 / b === 1 / c : b !== b && c !== c;
          };
        });
        z("Array.prototype.includes", function(a) {
          return a ? a : function(b, c) {
            var d = this;
            d instanceof String && (d = String(d));
            var e = d.length;
            c = c || 0;
            for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
              var g = d[c];
              if (g === b || Object.is(g, b))
                return true;
            }
            return false;
          };
        });
        z("String.prototype.includes", function(a) {
          return a ? a : function(b, c) {
            if (this == null)
              throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");
            if (b instanceof RegExp)
              throw new TypeError("First argument to String.prototype.includes must not be a regular expression");
            return this.indexOf(b, c || 0) !== -1;
          };
        });
        z("Array.prototype.keys", function(a) {
          return a ? a : function() {
            return ua(this, function(b) {
              return b;
            });
          };
        });
        var wa = this || self;
        function I(a, b) {
          a = a.split(".");
          var c = wa;
          a[0] in c || typeof c.execScript == "undefined" || c.execScript("var " + a[0]);
          for (var d; a.length && (d = a.shift()); )
            a.length || b === void 0 ? c[d] && c[d] !== Object.prototype[d] ? c = c[d] : c = c[d] = {} : c[d] = b;
        }
        ;
        function xa(a) {
          wa.setTimeout(function() {
            throw a;
          }, 0);
        }
        ;
        function ya(a) {
          xa(a);
          return;
          throw Error("invalid error level: 1");
        }
        function za(a, b) {
          ya(Error("Invalid wire type: " + a + " (at position " + b + ")"));
        }
        function Aa() {
          ya(Error("Failed to read varint, encoding is invalid."));
        }
        ;
        function Ba(a, b) {
          b = String.fromCharCode.apply(null, b);
          return a == null ? b : a + b;
        }
        var Ca, Da = typeof TextDecoder !== "undefined", Ea, Fa = typeof TextEncoder !== "undefined";
        function Ga(a) {
          if (Fa)
            a = (Ea || (Ea = new TextEncoder())).encode(a);
          else {
            var b = void 0;
            b = b === void 0 ? false : b;
            for (var c = 0, d = new Uint8Array(3 * a.length), e = 0; e < a.length; e++) {
              var g = a.charCodeAt(e);
              if (128 > g)
                d[c++] = g;
              else {
                if (2048 > g)
                  d[c++] = g >> 6 | 192;
                else {
                  if (55296 <= g && 57343 >= g) {
                    if (56319 >= g && e < a.length) {
                      var f = a.charCodeAt(++e);
                      if (56320 <= f && 57343 >= f) {
                        g = 1024 * (g - 55296) + f - 56320 + 65536;
                        d[c++] = g >> 18 | 240;
                        d[c++] = g >> 12 & 63 | 128;
                        d[c++] = g >> 6 & 63 | 128;
                        d[c++] = g & 63 | 128;
                        continue;
                      } else
                        e--;
                    }
                    if (b)
                      throw Error("Found an unpaired surrogate");
                    g = 65533;
                  }
                  d[c++] = g >> 12 | 224;
                  d[c++] = g >> 6 & 63 | 128;
                }
                d[c++] = g & 63 | 128;
              }
            }
            a = d.subarray(0, c);
          }
          return a;
        }
        ;
        var Ha = {}, Ia = null;
        function Ja(a) {
          var b;
          b === void 0 && (b = 0);
          Ka();
          b = Ha[b];
          for (var c = Array(Math.floor(a.length / 3)), d = b[64] || "", e = 0, g = 0; e < a.length - 2; e += 3) {
            var f = a[e], k = a[e + 1], h = a[e + 2], l = b[f >> 2];
            f = b[(f & 3) << 4 | k >> 4];
            k = b[(k & 15) << 2 | h >> 6];
            h = b[h & 63];
            c[g++] = l + f + k + h;
          }
          l = 0;
          h = d;
          switch (a.length - e) {
            case 2:
              l = a[e + 1], h = b[(l & 15) << 2] || d;
            case 1:
              a = a[e], c[g] = b[a >> 2] + b[(a & 3) << 4 | l >> 4] + h + d;
          }
          return c.join("");
        }
        function La(a) {
          var b = a.length, c = 3 * b / 4;
          c % 3 ? c = Math.floor(c) : "=.".indexOf(a[b - 1]) != -1 && (c = "=.".indexOf(a[b - 2]) != -1 ? c - 2 : c - 1);
          var d = new Uint8Array(c), e = 0;
          Ma(a, function(g) {
            d[e++] = g;
          });
          return d.subarray(0, e);
        }
        function Ma(a, b) {
          function c(h) {
            for (; d < a.length; ) {
              var l = a.charAt(d++), n = Ia[l];
              if (n != null)
                return n;
              if (!/^[\s\xa0]*$/.test(l))
                throw Error("Unknown base64 encoding at char: " + l);
            }
            return h;
          }
          Ka();
          for (var d = 0; ; ) {
            var e = c(-1), g = c(0), f = c(64), k = c(64);
            if (k === 64 && e === -1)
              break;
            b(e << 2 | g >> 4);
            f != 64 && (b(g << 4 & 240 | f >> 2), k != 64 && b(f << 6 & 192 | k));
          }
        }
        function Ka() {
          if (!Ia) {
            Ia = {};
            for (var a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), b = ["+/=", "+/", "-_=", "-_.", "-_"], c = 0; 5 > c; c++) {
              var d = a.concat(b[c].split(""));
              Ha[c] = d;
              for (var e = 0; e < d.length; e++) {
                var g = d[e];
                Ia[g] === void 0 && (Ia[g] = e);
              }
            }
          }
        }
        ;
        var Na = typeof Uint8Array === "function", Oa;
        function Pa(a) {
          this.g = a;
          if (a !== null && a.length === 0)
            throw Error("ByteString should be constructed with non-empty values");
        }
        Pa.prototype.toJSON = function() {
          if (this.g == null)
            var a = "";
          else
            a = this.g, a = this.g = a == null || typeof a === "string" ? a : Na && a instanceof Uint8Array ? Ja(a) : null;
          return a;
        };
        var Qa = typeof Uint8Array.prototype.slice === "function";
        function Ra(a, b, c) {
          return b === c ? Oa || (Oa = new Uint8Array(0)) : Qa ? a.slice(b, c) : new Uint8Array(a.subarray(b, c));
        }
        var K = 0, L = 0;
        function Sa(a) {
          if (a.constructor === Uint8Array)
            return a;
          if (a.constructor === ArrayBuffer)
            return new Uint8Array(a);
          if (a.constructor === Array)
            return new Uint8Array(a);
          if (a.constructor === String)
            return La(a);
          if (a.constructor === Pa) {
            if (a.g == null)
              var b = Oa || (Oa = new Uint8Array(0));
            else {
              b = Uint8Array;
              var c = a.g;
              c = c == null || Na && c != null && c instanceof Uint8Array ? c : typeof c === "string" ? La(c) : null;
              a = a.g = c;
              b = new b(a);
            }
            return b;
          }
          if (a instanceof Uint8Array)
            return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
          throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, or Array of numbers");
        }
        ;
        function Ta(a, b) {
          b = b === void 0 ? {} : b;
          b = b.u === void 0 ? false : b.u;
          this.h = null;
          this.g = this.i = this.m = 0;
          this.l = false;
          this.u = b;
          a && Ua(this, a);
        }
        function Ua(a, b) {
          a.h = Sa(b);
          a.m = 0;
          a.i = a.h.length;
          a.g = a.m;
        }
        Ta.prototype.reset = function() {
          this.g = this.m;
        };
        function Va(a) {
          for (var b = 128, c = 0, d = 0, e = 0; 4 > e && 128 <= b; e++)
            b = a.h[a.g++], c |= (b & 127) << 7 * e;
          128 <= b && (b = a.h[a.g++], c |= (b & 127) << 28, d |= (b & 127) >> 4);
          if (128 <= b)
            for (e = 0; 5 > e && 128 <= b; e++)
              b = a.h[a.g++], d |= (b & 127) << 7 * e + 3;
          if (128 > b) {
            a = c >>> 0;
            b = d >>> 0;
            if (d = b & 2147483648)
              a = ~a + 1 >>> 0, b = ~b >>> 0, a == 0 && (b = b + 1 >>> 0);
            a = 4294967296 * b + (a >>> 0);
            return d ? -a : a;
          }
          a.l = true;
          Aa();
        }
        function M(a) {
          a.g > a.i && (a.l = true, ya(Error("Tried to read past the end of the data " + a.g + " > " + a.i)));
        }
        Ta.prototype.j = function() {
          var a = this.h, b = a[this.g], c = b & 127;
          if (128 > b)
            return this.g += 1, M(this), c;
          b = a[this.g + 1];
          c |= (b & 127) << 7;
          if (128 > b)
            return this.g += 2, M(this), c;
          b = a[this.g + 2];
          c |= (b & 127) << 14;
          if (128 > b)
            return this.g += 3, M(this), c;
          b = a[this.g + 3];
          c |= (b & 127) << 21;
          if (128 > b)
            return this.g += 4, M(this), c;
          b = a[this.g + 4];
          c |= (b & 15) << 28;
          if (128 > b)
            return this.g += 5, M(this), c >>> 0;
          this.g += 5;
          if (128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++] && 128 <= a[this.g++])
            return this.l = true, Aa(), c;
          M(this);
          return c;
        };
        Ta.prototype.o = function() {
          var a = this.h[this.g], b = this.h[this.g + 1];
          var c = this.h[this.g + 2];
          var d = this.h[this.g + 3];
          this.g += 4;
          M(this);
          c = (a << 0 | b << 8 | c << 16 | d << 24) >>> 0;
          a = 2 * (c >> 31) + 1;
          b = c >>> 23 & 255;
          c &= 8388607;
          return b == 255 ? c ? NaN : Infinity * a : b == 0 ? a * Math.pow(2, -149) * c : a * Math.pow(2, b - 150) * (c + Math.pow(2, 23));
        };
        var Wa = [];
        function Xa() {
          this.g = new Uint8Array(64);
          this.h = 0;
        }
        function N(a, b) {
          if (!(a.h + 1 < a.g.length)) {
            var c = a.g;
            a.g = new Uint8Array(Math.ceil(1 + 2 * a.g.length));
            a.g.set(c);
          }
          a.g[a.h++] = b;
        }
        Xa.prototype.length = function() {
          return this.h;
        };
        Xa.prototype.end = function() {
          var a = this.g, b = this.h;
          this.h = 0;
          return Ra(a, 0, b);
        };
        function Ya(a, b) {
          for (; 127 < b; )
            N(a, b & 127 | 128), b >>>= 7;
          N(a, b);
        }
        ;
        function Za(a) {
          var b = {}, c = b.N === void 0 ? false : b.N;
          this.m = { u: b.u === void 0 ? false : b.u };
          this.N = c;
          b = this.m;
          Wa.length ? (c = Wa.pop(), b && (c.u = b.u), a && Ua(c, a), a = c) : a = new Ta(a, b);
          this.g = a;
          this.l = this.g.g;
          this.h = this.i = -1;
          this.j = false;
        }
        Za.prototype.reset = function() {
          this.g.reset();
          this.h = this.i = -1;
        };
        function $a(a) {
          var b = a.g;
          (b = b.g == b.i) || (b = a.j) || (b = a.g, b = b.l || 0 > b.g || b.g > b.i);
          if (b)
            return false;
          a.l = a.g.g;
          var c = a.g.j();
          b = c >>> 3;
          c &= 7;
          if (!(0 <= c && 5 >= c))
            return a.j = true, za(c, a.l), false;
          a.i = b;
          a.h = c;
          return true;
        }
        function ab(a) {
          switch (a.h) {
            case 0:
              if (a.h != 0)
                ab(a);
              else
                a: {
                  a = a.g;
                  for (var b = a.g, c = 0; 10 > c; c++) {
                    if ((a.h[b] & 128) === 0) {
                      a.g = b + 1;
                      M(a);
                      break a;
                    }
                    b++;
                  }
                  a.l = true;
                  Aa();
                }
              break;
            case 1:
              a = a.g;
              a.g += 8;
              M(a);
              break;
            case 2:
              a.h != 2 ? ab(a) : (b = a.g.j(), a = a.g, a.g += b, M(a));
              break;
            case 5:
              a = a.g;
              a.g += 4;
              M(a);
              break;
            case 3:
              b = a.i;
              do {
                if (!$a(a)) {
                  a.j = true;
                  ya(Error("Unmatched start-group tag: stream EOF"));
                  break;
                }
                if (a.h == 4) {
                  a.i != b && (a.j = true, ya(Error("Unmatched end-group tag")));
                  break;
                }
                ab(a);
              } while (1);
              break;
            default:
              a.j = true, za(a.h, a.l);
          }
        }
        function bb3(a, b, c) {
          a.N || (a = Ra(a.g.h, c, a.g.g), (c = b.o) ? c.push(a) : b.o = [a]);
        }
        function cb(a, b, c) {
          var d = a.g.i, e = a.g.j(), g = a.g.g + e;
          a.g.i = g;
          c(b, a);
          c = g - a.g.g;
          if (c !== 0)
            throw Error("Message parsing ended unexpectedly. Expected to read " + (e + " bytes, instead read " + (e - c) + " bytes, either the data ended unexpectedly or the message misreported its own length"));
          a.g.g = g;
          a.g.i = d;
          return b;
        }
        function db(a, b, c) {
          var d = a.g.j();
          for (d = a.g.g + d; a.g.g < d; )
            c.push(b.call(a.g));
        }
        var eb = [];
        function fb() {
          this.h = [];
          this.i = 0;
          this.g = new Xa();
        }
        function gb(a, b) {
          b.length !== 0 && (a.h.push(b), a.i += b.length);
        }
        function hb(a, b, c) {
          Ya(a.g, 8 * b + 2);
          Ya(a.g, c.length);
          gb(a, a.g.end());
          gb(a, c);
        }
        ;
        var ib = typeof Symbol === "function" && typeof Symbol() === "symbol" ? Symbol(void 0) : void 0;
        function jb(a, b) {
          Object.isFrozen(a) || (ib ? a[ib] |= b : a.g !== void 0 ? a.g |= b : Object.defineProperties(a, { g: { value: b, configurable: true, writable: true, enumerable: false } }));
        }
        function kb(a) {
          if (!a)
            return 0;
          var b;
          ib ? b = a[ib] : b = a.g;
          return b == null ? 0 : b;
        }
        function lb(a) {
          if (!Array.isArray(a))
            return a;
          jb(a, 1);
          return a;
        }
        function mb(a) {
          if (!Array.isArray(a))
            throw Error("cannot mark non-array as immutable");
          jb(a, 2);
        }
        ;
        function nb(a) {
          return a !== null && typeof a === "object" && a.constructor === Object;
        }
        function ob(a) {
          switch (typeof a) {
            case "number":
              return isFinite(a) ? a : String(a);
            case "object":
              return Na && a != null && a instanceof Uint8Array ? Ja(a) : a;
            default:
              return a;
          }
        }
        ;
        function pb(a, b) {
          if (a != null)
            return Array.isArray(a) || nb(a) ? qb(a, b) : b(a);
        }
        function qb(a, b) {
          if (Array.isArray(a)) {
            for (var c = Array(a.length), d = 0; d < a.length; d++)
              c[d] = pb(a[d], b);
            kb(a) & 1 && lb(c);
            return c;
          }
          c = {};
          for (d in a)
            c[d] = pb(a[d], b);
          return c;
        }
        ;
        var rb;
        function O(a, b, c) {
          var d = rb;
          rb = null;
          a || (a = d);
          d = this.constructor.ba;
          a || (a = d ? [d] : []);
          this.j = (d ? 0 : -1) - (this.constructor.$ || 0);
          this.m = this.g = null;
          this.h = a;
          a: {
            d = this.h.length;
            a = d - 1;
            if (d && (d = this.h[a], nb(d))) {
              this.l = a - this.j;
              this.i = d;
              break a;
            }
            b !== void 0 && -1 < b ? (this.l = Math.max(b, a + 1 - this.j), this.i = null) : this.l = Number.MAX_VALUE;
          }
          if (c)
            for (b = 0; b < c.length; b++)
              a = c[b], a < this.l ? (a += this.j, (d = this.h[a]) ? lb(d) : this.h[a] = sb) : (tb(this), (d = this.i[a]) ? lb(d) : this.i[a] = sb);
        }
        var sb = Object.freeze(lb([]));
        function tb(a) {
          var b = a.l + a.j;
          a.h[b] || (a.i = a.h[b] = {});
        }
        function P(a, b, c) {
          return b === -1 ? null : (c === void 0 ? 0 : c) || b >= a.l ? a.i ? a.i[b] : void 0 : a.h[b + a.j];
        }
        function ub(a, b, c) {
          c = c === void 0 ? true : c;
          var d = d === void 0 ? false : d;
          var e = P(a, b, d);
          e == null && (e = sb);
          e === sb ? (e = lb([]), Q(a, b, e, d)) : c && Array.isArray(e) && kb(e) & 2 && (e = e.slice(), Q(a, b, e, d));
          return e;
        }
        function vb(a) {
          var b = ub(a, 3, false);
          a.m || (a.m = {});
          if (!a.m[3]) {
            for (var c = 0; c < b.length; c++)
              b[c] = +b[c];
            a.m[3] = true;
          }
          return b;
        }
        function R(a, b, c) {
          a = P(a, b);
          return a == null ? c : a;
        }
        function S(a, b, c) {
          a = P(a, b);
          a = a == null ? a : +a;
          return a == null ? c === void 0 ? 0 : c : a;
        }
        function Q(a, b, c, d) {
          (d === void 0 ? 0 : d) || b >= a.l ? (tb(a), a.i[b] = c) : a.h[b + a.j] = c;
        }
        function wb(a, b, c) {
          if (c === -1)
            return null;
          a.g || (a.g = {});
          var d = a.g[c];
          if (d)
            return d;
          var e = P(a, c, false);
          if (e == null)
            return d;
          b = new b(e);
          return a.g[c] = b;
        }
        function xb(a, b, c) {
          a.g || (a.g = {});
          var d = a.g[c];
          if (!d) {
            var e = ub(a, c, false);
            d = [];
            for (var g = Array.isArray(e) ? !!(kb(e) & 2) : false, f = 0; f < e.length; f++)
              d[f] = new b(e[f]), g && mb(d[f].h);
            g && (mb(d), Object.freeze(d));
            a.g[c] = d;
          }
          return d;
        }
        function yb(a, b, c, d, e) {
          var g = xb(a, d, b);
          c = c ? c : new d();
          a = ub(a, b);
          e != void 0 ? (g.splice(e, 0, c), a.splice(e, 0, T(c))) : (g.push(c), a.push(T(c)));
        }
        O.prototype.toJSON = function() {
          var a = T(this);
          return qb(a, ob);
        };
        function T(a) {
          if (a.g)
            for (var b in a.g) {
              var c = a.g[b];
              if (Array.isArray(c))
                for (var d = 0; d < c.length; d++)
                  c[d] && T(c[d]);
              else
                c && T(c);
            }
          return a.h;
        }
        O.prototype.toString = function() {
          return T(this).toString();
        };
        function zb(a, b) {
          if (a = a.o) {
            gb(b, b.g.end());
            for (var c = 0; c < a.length; c++)
              gb(b, a[c]);
          }
        }
        function Ab(a) {
          var b = a[0];
          switch (a.length) {
            case 2:
              var c = a[1];
              return function(h, l, n) {
                return b(h, l, n, c);
              };
            case 3:
              var d = a[1], e = a[2];
              return function(h, l, n) {
                return b(h, l, n, d, e);
              };
            case 4:
              var g = a[1], f = a[2], k = a[3];
              return function(h, l, n) {
                return b(h, l, n, g, f, k);
              };
            default:
              throw Error("unsupported number of parameters, expected [2-4], got " + a.length);
          }
        }
        function U(a, b, c) {
          for (; $a(b) && b.h != 4; ) {
            var d = b.i, e = c[d];
            if (e) {
              if (Array.isArray(e) && (e = c[d] = Ab(e)), !e(b, a, d)) {
                d = b;
                e = a;
                var g = d.l;
                ab(d);
                bb3(d, e, g);
              }
            } else
              d = b, e = a, g = d.l, ab(d), bb3(d, e, g);
          }
          return a;
        }
        function Bb(a, b) {
          var c = new fb();
          b(a, c);
          a = c.i + c.g.length();
          if (a === 0)
            c = new Uint8Array(0);
          else {
            a = new Uint8Array(a);
            for (var d = c.h, e = d.length, g = b = 0; g < e; g++) {
              var f = d[g];
              f.length !== 0 && (a.set(f, b), b += f.length);
            }
            d = c.g;
            e = d.h;
            e !== 0 && (a.set(d.g.subarray(0, e), b), d.h = 0);
            c.h = [a];
            c = a;
          }
          return c;
        }
        function Cb(a, b, c) {
          if (eb.length) {
            var d = eb.pop();
            a && (Ua(d.g, a), d.i = -1, d.h = -1);
            a = d;
          } else
            a = new Za(a);
          try {
            return c(new b(), a);
          } finally {
            b = a.g, b.h = null, b.m = 0, b.i = 0, b.g = 0, b.l = false, b.u = false, a.i = -1, a.h = -1, a.j = false, 100 > eb.length && eb.push(a);
          }
        }
        function W(a, b, c) {
          b = P(b, c);
          if (b != null) {
            Ya(a.g, 8 * c + 5);
            a = a.g;
            var d = b;
            d = (c = 0 > d ? 1 : 0) ? -d : d;
            d === 0 ? 0 < 1 / d ? K = L = 0 : (L = 0, K = 2147483648) : isNaN(d) ? (L = 0, K = 2147483647) : 34028234663852886e22 < d ? (L = 0, K = (c << 31 | 2139095040) >>> 0) : 11754943508222875e-54 > d ? (d = Math.round(d / Math.pow(2, -149)), L = 0, K = (c << 31 | d) >>> 0) : (b = Math.floor(Math.log(d) / Math.LN2), d *= Math.pow(2, -b), d = Math.round(8388608 * d), 16777216 <= d && ++b, L = 0, K = (c << 31 | b + 127 << 23 | d & 8388607) >>> 0);
            c = K;
            N(a, c >>> 0 & 255);
            N(a, c >>> 8 & 255);
            N(a, c >>> 16 & 255);
            N(a, c >>> 24 & 255);
          }
        }
        function X(a, b, c) {
          if (a.h !== 5)
            return false;
          Q(b, c, a.g.o());
          return true;
        }
        function Db(a, b, c) {
          if (a.h !== 5 && a.h !== 2)
            return false;
          b = ub(b, c);
          a.h == 2 ? db(a, Ta.prototype.o, b) : b.push(a.g.o());
          return true;
        }
        function Eb(a, b, c) {
          if (a.h !== 0)
            return false;
          Q(b, c, Va(a.g));
          return true;
        }
        function Fb(a, b, c) {
          if (a.h !== 0)
            return false;
          Q(b, c, a.g.j());
          return true;
        }
        function Gb(a, b, c) {
          if (a.h !== 2)
            return false;
          var d = a.g.j();
          a = a.g;
          var e = a.g;
          a.g += d;
          M(a);
          a = a.h;
          var g;
          if (Da)
            (g = Ca) || (g = Ca = new TextDecoder("utf-8", { fatal: false })), g = g.decode(a.subarray(e, e + d));
          else {
            d = e + d;
            for (var f = [], k = null, h, l, n; e < d; )
              h = a[e++], 128 > h ? f.push(h) : 224 > h ? e >= d ? f.push(65533) : (l = a[e++], 194 > h || (l & 192) !== 128 ? (e--, f.push(65533)) : f.push((h & 31) << 6 | l & 63)) : 240 > h ? e >= d - 1 ? f.push(65533) : (l = a[e++], (l & 192) !== 128 || h === 224 && 160 > l || h === 237 && 160 <= l || ((g = a[e++]) & 192) !== 128 ? (e--, f.push(65533)) : f.push((h & 15) << 12 | (l & 63) << 6 | g & 63)) : 244 >= h ? e >= d - 2 ? f.push(65533) : (l = a[e++], (l & 192) !== 128 || (h << 28) + (l - 144) >> 30 !== 0 || ((g = a[e++]) & 192) !== 128 || ((n = a[e++]) & 192) !== 128 ? (e--, f.push(65533)) : (h = (h & 7) << 18 | (l & 63) << 12 | (g & 63) << 6 | n & 63, h -= 65536, f.push((h >> 10 & 1023) + 55296, (h & 1023) + 56320))) : f.push(65533), 8192 <= f.length && (k = Ba(k, f), f.length = 0);
            g = Ba(k, f);
          }
          Q(b, c, g);
          return true;
        }
        function Hb(a, b, c, d, e) {
          if (a.h !== 2)
            return false;
          a = cb(a, new d(), e);
          var g = g === void 0 ? false : g;
          b.g || (b.g = {});
          d = a ? T(a) : a;
          b.g[c] = a;
          Q(b, c, d, g);
          return true;
        }
        function Ib(a, b, c, d, e) {
          if (a.h !== 2)
            return false;
          a = cb(a, new d(), e);
          yb(b, c, a, d, void 0);
          return true;
        }
        function Jb(a, b, c) {
          if (a.h !== 0 && a.h !== 2)
            return false;
          b = ub(b, c);
          a.h == 2 ? db(a, Ta.prototype.j, b) : b.push(a.g.j());
          return true;
        }
        function Kb(a, b, c) {
          if (a.h !== 0)
            return false;
          Q(b, c, Va(a.g));
          return true;
        }
        ;
        function Y(a) {
          O.call(this, a, -1, Lb);
        }
        var Mb;
        E(Y, O);
        Y.prototype.getRows = function() {
          return P(this, 1);
        };
        Y.prototype.getCols = function() {
          return P(this, 2);
        };
        Y.prototype.getPackedDataList = function() {
          return vb(this);
        };
        Y.prototype.getLayout = function() {
          return R(this, 4, 0);
        };
        function Nb(a, b) {
          return U(a, b, Mb || (Mb = { 1: Fb, 2: Fb, 3: Db, 4: Kb }));
        }
        var Lb = [3];
        function Ob(a) {
          O.call(this, a);
        }
        var Pb;
        E(Ob, O);
        function Qb(a, b) {
          var c = P(a, 1);
          if (c != null && c != null) {
            Ya(b.g, 8);
            var d = b.g;
            if (0 <= c)
              Ya(d, c);
            else {
              for (var e = 0; 9 > e; e++)
                N(d, c & 127 | 128), c >>= 7;
              N(d, 1);
            }
          }
          W(b, a, 2);
          d = P(a, 3);
          d != null && hb(b, 3, Ga(d));
          d = P(a, 4);
          d != null && hb(b, 4, Ga(d));
          zb(a, b);
        }
        function Rb(a, b) {
          return U(a, b, Pb || (Pb = { 1: Fb, 2: X, 3: Gb, 4: Gb }));
        }
        ;
        function Sb(a) {
          O.call(this, a, -1, Tb);
        }
        var Ub;
        E(Sb, O);
        Sb.prototype.addClassification = function(a, b) {
          yb(this, 1, a, Ob, b);
          return this;
        };
        function Vb(a, b) {
          return U(a, b, Ub || (Ub = { 1: [Ib, Ob, Rb] }));
        }
        var Tb = [1];
        function Wb(a) {
          O.call(this, a);
        }
        var Xb;
        E(Wb, O);
        function Yb(a, b) {
          W(b, a, 1);
          W(b, a, 2);
          W(b, a, 3);
          W(b, a, 4);
          W(b, a, 5);
          zb(a, b);
        }
        function Zb(a, b) {
          return U(a, b, Xb || (Xb = { 1: X, 2: X, 3: X, 4: X, 5: X }));
        }
        ;
        function $b(a) {
          O.call(this, a, -1, ac);
        }
        var bc;
        E($b, O);
        function cc(a, b) {
          return U(a, b, bc || (bc = { 1: [Ib, Wb, Zb] }));
        }
        var ac = [1];
        function dc(a) {
          O.call(this, a);
        }
        var ec;
        E(dc, O);
        function fc(a, b) {
          W(b, a, 1);
          W(b, a, 2);
          W(b, a, 3);
          W(b, a, 4);
          W(b, a, 5);
          var c = P(a, 6);
          if (c != null && c != null) {
            Ya(b.g, 48);
            var d = b.g, e = c;
            c = 0 > e;
            e = Math.abs(e);
            var g = e >>> 0;
            e = Math.floor((e - g) / 4294967296);
            e >>>= 0;
            c && (e = ~e >>> 0, g = (~g >>> 0) + 1, 4294967295 < g && (g = 0, e++, 4294967295 < e && (e = 0)));
            K = g;
            L = e;
            c = K;
            for (g = L; 0 < g || 127 < c; )
              N(d, c & 127 | 128), c = (c >>> 7 | g << 25) >>> 0, g >>>= 7;
            N(d, c);
          }
          zb(a, b);
        }
        function gc(a, b) {
          return U(a, b, ec || (ec = { 1: X, 2: X, 3: X, 4: X, 5: X, 6: Eb }));
        }
        ;
        function Z(a) {
          O.call(this, a, -1, hc);
        }
        var ic;
        E(Z, O);
        Z.prototype.getVertexType = function() {
          return R(this, 1, 0);
        };
        Z.prototype.getPrimitiveType = function() {
          return R(this, 2, 0);
        };
        Z.prototype.getVertexBufferList = function() {
          return vb(this);
        };
        Z.prototype.getIndexBufferList = function() {
          return ub(this, 4);
        };
        function jc(a, b) {
          return U(a, b, ic || (ic = { 1: Kb, 2: Kb, 3: Db, 4: Jb }));
        }
        var hc = [3, 4];
        function kc(a) {
          O.call(this, a);
        }
        var lc;
        E(kc, O);
        kc.prototype.getMesh = function() {
          return wb(this, Z, 1);
        };
        kc.prototype.getPoseTransformMatrix = function() {
          return wb(this, Y, 2);
        };
        function mc(a, b) {
          return U(a, b, lc || (lc = { 1: [Hb, Z, jc], 2: [Hb, Y, Nb] }));
        }
        ;
        var nc = [[61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]], oc = [[263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [
          386,
          385
        ], [385, 384], [384, 398], [398, 362]], pc = [[276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]], qc = [[33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]], rc = [[46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]], sc = [
          [10, 338],
          [338, 297],
          [297, 332],
          [332, 284],
          [284, 251],
          [251, 389],
          [389, 356],
          [356, 454],
          [454, 323],
          [323, 361],
          [361, 288],
          [288, 397],
          [397, 365],
          [365, 379],
          [379, 378],
          [378, 400],
          [400, 377],
          [377, 152],
          [152, 148],
          [148, 176],
          [176, 149],
          [149, 150],
          [150, 136],
          [136, 172],
          [172, 58],
          [58, 132],
          [132, 93],
          [93, 234],
          [234, 127],
          [127, 162],
          [162, 21],
          [21, 54],
          [54, 103],
          [103, 67],
          [67, 109],
          [109, 10]
        ], tc = [].concat(D(nc), D(oc), D(pc), D(qc), D(rc), D(sc));
        function uc(a, b, c) {
          c = a.createShader(c === 0 ? a.VERTEX_SHADER : a.FRAGMENT_SHADER);
          a.shaderSource(c, b);
          a.compileShader(c);
          if (!a.getShaderParameter(c, a.COMPILE_STATUS))
            throw Error("Could not compile WebGL shader.\n\n" + a.getShaderInfoLog(c));
          return c;
        }
        ;
        function vc(a) {
          return xb(a, Ob, 1).map(function(b) {
            return { index: R(b, 1, 0), score: S(b, 2), label: P(b, 3) != null ? R(b, 3, "") : void 0, displayName: P(b, 4) != null ? R(b, 4, "") : void 0 };
          });
        }
        ;
        function wc(a) {
          return { x: S(a, 1), y: S(a, 2), z: S(a, 3), visibility: P(a, 4) != null ? S(a, 4) : void 0 };
        }
        function xc(a) {
          return xb(Cb(a, $b, cc), Wb, 1).map(wc);
        }
        ;
        function yc(a, b) {
          this.h = a;
          this.g = b;
          this.l = 0;
        }
        function zc(a, b, c) {
          Ac(a, b);
          if (typeof a.g.canvas.transferToImageBitmap === "function")
            return Promise.resolve(a.g.canvas.transferToImageBitmap());
          if (c)
            return Promise.resolve(a.g.canvas);
          if (typeof createImageBitmap === "function")
            return createImageBitmap(a.g.canvas);
          a.i === void 0 && (a.i = document.createElement("canvas"));
          return new Promise(function(d) {
            a.i.height = a.g.canvas.height;
            a.i.width = a.g.canvas.width;
            a.i.getContext("2d", {}).drawImage(a.g.canvas, 0, 0, a.g.canvas.width, a.g.canvas.height);
            d(a.i);
          });
        }
        function Ac(a, b) {
          var c = a.g;
          if (a.m === void 0) {
            var d = uc(c, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", 0), e = uc(c, "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }", 1), g = c.createProgram();
            c.attachShader(g, d);
            c.attachShader(g, e);
            c.linkProgram(g);
            if (!c.getProgramParameter(g, c.LINK_STATUS))
              throw Error("Could not compile WebGL program.\n\n" + c.getProgramInfoLog(g));
            d = a.m = g;
            c.useProgram(d);
            e = c.getUniformLocation(d, "sampler0");
            a.j = { I: c.getAttribLocation(d, "aVertex"), H: c.getAttribLocation(d, "aTex"), ca: e };
            a.s = c.createBuffer();
            c.bindBuffer(c.ARRAY_BUFFER, a.s);
            c.enableVertexAttribArray(a.j.I);
            c.vertexAttribPointer(a.j.I, 2, c.FLOAT, false, 0, 0);
            c.bufferData(c.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), c.STATIC_DRAW);
            c.bindBuffer(c.ARRAY_BUFFER, null);
            a.o = c.createBuffer();
            c.bindBuffer(c.ARRAY_BUFFER, a.o);
            c.enableVertexAttribArray(a.j.H);
            c.vertexAttribPointer(a.j.H, 2, c.FLOAT, false, 0, 0);
            c.bufferData(c.ARRAY_BUFFER, new Float32Array([0, 1, 0, 0, 1, 0, 1, 1]), c.STATIC_DRAW);
            c.bindBuffer(c.ARRAY_BUFFER, null);
            c.uniform1i(e, 0);
          }
          d = a.j;
          c.useProgram(a.m);
          c.canvas.width = b.width;
          c.canvas.height = b.height;
          c.viewport(0, 0, b.width, b.height);
          c.activeTexture(c.TEXTURE0);
          a.h.bindTexture2d(b.glName);
          c.enableVertexAttribArray(d.I);
          c.bindBuffer(c.ARRAY_BUFFER, a.s);
          c.vertexAttribPointer(d.I, 2, c.FLOAT, false, 0, 0);
          c.enableVertexAttribArray(d.H);
          c.bindBuffer(c.ARRAY_BUFFER, a.o);
          c.vertexAttribPointer(d.H, 2, c.FLOAT, false, 0, 0);
          c.bindFramebuffer(c.DRAW_FRAMEBUFFER ? c.DRAW_FRAMEBUFFER : c.FRAMEBUFFER, null);
          c.clearColor(0, 0, 0, 0);
          c.clear(c.COLOR_BUFFER_BIT);
          c.colorMask(true, true, true, true);
          c.drawArrays(c.TRIANGLE_FAN, 0, 4);
          c.disableVertexAttribArray(d.I);
          c.disableVertexAttribArray(d.H);
          c.bindBuffer(c.ARRAY_BUFFER, null);
          a.h.bindTexture2d(0);
        }
        function Bc(a) {
          this.g = a;
        }
        ;
        var Cc = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 9, 1, 7, 0, 65, 0, 253, 15, 26, 11]);
        function Dc(a, b) {
          return b + a;
        }
        function Ec(a, b) {
          window[a] = b;
        }
        function Fc(a) {
          var b = document.createElement("script");
          b.setAttribute("src", a);
          b.setAttribute("crossorigin", "anonymous");
          return new Promise(function(c) {
            b.addEventListener("load", function() {
              c();
            }, false);
            b.addEventListener("error", function() {
              c();
            }, false);
            document.body.appendChild(b);
          });
        }
        function Gc() {
          return H(function(a) {
            switch (a.g) {
              case 1:
                return a.m = 2, F(a, WebAssembly.instantiate(Cc), 4);
              case 4:
                a.g = 3;
                a.m = 0;
                break;
              case 2:
                return a.m = 0, a.j = null, a.return(false);
              case 3:
                return a.return(true);
            }
          });
        }
        function Hc(a) {
          this.g = a;
          this.listeners = {};
          this.j = {};
          this.F = {};
          this.m = {};
          this.s = {};
          this.G = this.o = this.R = true;
          this.C = Promise.resolve();
          this.P = "";
          this.B = {};
          this.locateFile = a && a.locateFile || Dc;
          if (typeof window === "object")
            var b = window.location.pathname.toString().substring(0, window.location.pathname.toString().lastIndexOf("/")) + "/";
          else if (typeof location !== "undefined")
            b = location.pathname.toString().substring(0, location.pathname.toString().lastIndexOf("/")) + "/";
          else
            throw Error("solutions can only be loaded on a web page or in a web worker");
          this.S = b;
          if (a.options) {
            b = B(Object.keys(a.options));
            for (var c = b.next(); !c.done; c = b.next()) {
              c = c.value;
              var d = a.options[c].default;
              d !== void 0 && (this.j[c] = typeof d === "function" ? d() : d);
            }
          }
        }
        x = Hc.prototype;
        x.close = function() {
          this.i && this.i.delete();
          return Promise.resolve();
        };
        function Ic(a) {
          var b, c, d, e, g, f, k, h, l, n, r;
          return H(function(p2) {
            switch (p2.g) {
              case 1:
                if (!a.R)
                  return p2.return();
                b = a.g.files === void 0 ? [] : typeof a.g.files === "function" ? a.g.files(a.j) : a.g.files;
                return F(p2, Gc(), 2);
              case 2:
                c = p2.h;
                if (typeof window === "object")
                  return Ec("createMediapipeSolutionsWasm", { locateFile: a.locateFile }), Ec("createMediapipeSolutionsPackedAssets", { locateFile: a.locateFile }), f = b.filter(function(m) {
                    return m.data !== void 0;
                  }), k = b.filter(function(m) {
                    return m.data === void 0;
                  }), h = Promise.all(f.map(function(m) {
                    var q2 = Jc(a, m.url);
                    if (m.path !== void 0) {
                      var t = m.path;
                      q2 = q2.then(function(w) {
                        a.overrideFile(t, w);
                        return Promise.resolve(w);
                      });
                    }
                    return q2;
                  })), l = Promise.all(k.map(function(m) {
                    return m.simd === void 0 || m.simd && c || !m.simd && !c ? Fc(a.locateFile(m.url, a.S)) : Promise.resolve();
                  })).then(function() {
                    var m, q2, t;
                    return H(function(w) {
                      if (w.g == 1)
                        return m = window.createMediapipeSolutionsWasm, q2 = window.createMediapipeSolutionsPackedAssets, t = a, F(w, m(q2), 2);
                      t.h = w.h;
                      w.g = 0;
                    });
                  }), n = function() {
                    return H(function(m) {
                      a.g.graph && a.g.graph.url ? m = F(m, Jc(a, a.g.graph.url), 0) : (m.g = 0, m = void 0);
                      return m;
                    });
                  }(), F(p2, Promise.all([l, h, n]), 7);
                if (typeof importScripts !== "function")
                  throw Error("solutions can only be loaded on a web page or in a web worker");
                d = b.filter(function(m) {
                  return m.simd === void 0 || m.simd && c || !m.simd && !c;
                }).map(function(m) {
                  return a.locateFile(m.url, a.S);
                });
                importScripts.apply(null, D(d));
                e = a;
                return F(p2, createMediapipeSolutionsWasm(Module), 6);
              case 6:
                e.h = p2.h;
                a.l = new OffscreenCanvas(1, 1);
                a.h.canvas = a.l;
                g = a.h.GL.createContext(a.l, {
                  antialias: false,
                  alpha: false,
                  aa: typeof WebGL2RenderingContext !== "undefined" ? 2 : 1
                });
                a.h.GL.makeContextCurrent(g);
                p2.g = 4;
                break;
              case 7:
                a.l = document.createElement("canvas");
                r = a.l.getContext("webgl2", {});
                if (!r && (r = a.l.getContext("webgl", {}), !r))
                  return alert("Failed to create WebGL canvas context when passing video frame."), p2.return();
                a.D = r;
                a.h.canvas = a.l;
                a.h.createContext(a.l, true, true, {});
              case 4:
                a.i = new a.h.SolutionWasm(), a.R = false, p2.g = 0;
            }
          });
        }
        function Kc(a) {
          var b, c, d, e, g, f, k, h;
          return H(function(l) {
            if (l.g == 1) {
              if (a.g.graph && a.g.graph.url && a.P === a.g.graph.url)
                return l.return();
              a.o = true;
              if (!a.g.graph || !a.g.graph.url) {
                l.g = 2;
                return;
              }
              a.P = a.g.graph.url;
              return F(l, Jc(a, a.g.graph.url), 3);
            }
            l.g != 2 && (b = l.h, a.i.loadGraph(b));
            c = B(Object.keys(a.B));
            for (d = c.next(); !d.done; d = c.next())
              e = d.value, a.i.overrideFile(e, a.B[e]);
            a.B = {};
            if (a.g.listeners)
              for (g = B(a.g.listeners), f = g.next(); !f.done; f = g.next())
                k = f.value, Lc(a, k);
            h = a.j;
            a.j = {};
            a.setOptions(h);
            l.g = 0;
          });
        }
        x.reset = function() {
          var a = this;
          return H(function(b) {
            a.i && (a.i.reset(), a.m = {}, a.s = {});
            b.g = 0;
          });
        };
        x.setOptions = function(a, b) {
          var c = this;
          if (b = b || this.g.options) {
            for (var d = [], e = [], g = {}, f = B(Object.keys(a)), k = f.next(); !k.done; g = { K: g.K, L: g.L }, k = f.next()) {
              var h = k.value;
              h in this.j && this.j[h] === a[h] || (this.j[h] = a[h], k = b[h], k !== void 0 && (k.onChange && (g.K = k.onChange, g.L = a[h], d.push(function(l) {
                return function() {
                  var n;
                  return H(function(r) {
                    if (r.g == 1)
                      return F(r, l.K(l.L), 2);
                    n = r.h;
                    n === true && (c.o = true);
                    r.g = 0;
                  });
                };
              }(g))), k.graphOptionXref && (h = { valueNumber: k.type === 1 ? a[h] : 0, valueBoolean: k.type === 0 ? a[h] : false, valueString: k.type === 2 ? a[h] : "" }, k = Object.assign(Object.assign(Object.assign({}, { calculatorName: "", calculatorIndex: 0 }), k.graphOptionXref), h), e.push(k))));
            }
            if (d.length !== 0 || e.length !== 0)
              this.o = true, this.A = (this.A === void 0 ? [] : this.A).concat(e), this.v = (this.v === void 0 ? [] : this.v).concat(d);
          }
        };
        function Mc(a) {
          var b, c, d, e, g, f, k;
          return H(function(h) {
            switch (h.g) {
              case 1:
                if (!a.o)
                  return h.return();
                if (!a.v) {
                  h.g = 2;
                  break;
                }
                b = B(a.v);
                c = b.next();
              case 3:
                if (c.done) {
                  h.g = 5;
                  break;
                }
                d = c.value;
                return F(h, d(), 4);
              case 4:
                c = b.next();
                h.g = 3;
                break;
              case 5:
                a.v = void 0;
              case 2:
                if (a.A) {
                  e = new a.h.GraphOptionChangeRequestList();
                  g = B(a.A);
                  for (f = g.next(); !f.done; f = g.next())
                    k = f.value, e.push_back(k);
                  a.i.changeOptions(e);
                  e.delete();
                  a.A = void 0;
                }
                a.o = false;
                h.g = 0;
            }
          });
        }
        x.initialize = function() {
          var a = this;
          return H(function(b) {
            return b.g == 1 ? F(b, Ic(a), 2) : b.g != 3 ? F(b, Kc(a), 3) : F(b, Mc(a), 0);
          });
        };
        function Jc(a, b) {
          var c, d;
          return H(function(e) {
            if (b in a.F)
              return e.return(a.F[b]);
            c = a.locateFile(b, "");
            d = fetch(c).then(function(g) {
              return g.arrayBuffer();
            });
            a.F[b] = d;
            return e.return(d);
          });
        }
        x.overrideFile = function(a, b) {
          this.i ? this.i.overrideFile(a, b) : this.B[a] = b;
        };
        x.clearOverriddenFiles = function() {
          this.B = {};
          this.i && this.i.clearOverriddenFiles();
        };
        x.send = function(a, b) {
          var c = this, d, e, g, f, k, h, l, n, r;
          return H(function(p2) {
            switch (p2.g) {
              case 1:
                if (!c.g.inputs)
                  return p2.return();
                d = 1e3 * (b === void 0 || b === null ? performance.now() : b);
                return F(p2, c.C, 2);
              case 2:
                return F(p2, c.initialize(), 3);
              case 3:
                e = new c.h.PacketDataList();
                g = B(Object.keys(a));
                for (f = g.next(); !f.done; f = g.next())
                  if (k = f.value, h = c.g.inputs[k]) {
                    a: {
                      var m = a[k];
                      switch (h.type) {
                        case "video":
                          var q2 = c.m[h.stream];
                          q2 || (q2 = new yc(c.h, c.D), c.m[h.stream] = q2);
                          q2.l === 0 && (q2.l = q2.h.createTexture());
                          if (typeof HTMLVideoElement !== "undefined" && m instanceof HTMLVideoElement) {
                            var t = m.videoWidth;
                            var w = m.videoHeight;
                          } else
                            typeof HTMLImageElement !== "undefined" && m instanceof HTMLImageElement ? (t = m.naturalWidth, w = m.naturalHeight) : (t = m.width, w = m.height);
                          w = { glName: q2.l, width: t, height: w };
                          t = q2.g;
                          t.canvas.width = w.width;
                          t.canvas.height = w.height;
                          t.activeTexture(t.TEXTURE0);
                          q2.h.bindTexture2d(q2.l);
                          t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, t.RGBA, t.UNSIGNED_BYTE, m);
                          q2.h.bindTexture2d(0);
                          q2 = w;
                          break a;
                        case "detections":
                          q2 = c.m[h.stream];
                          q2 || (q2 = new Bc(c.h), c.m[h.stream] = q2);
                          q2.data || (q2.data = new q2.g.DetectionListData());
                          q2.data.reset(m.length);
                          for (w = 0; w < m.length; ++w) {
                            t = m[w];
                            var v = q2.data, C = v.setBoundingBox, J = w;
                            var G = t.T;
                            var u = new dc();
                            Q(u, 1, G.X);
                            Q(u, 2, G.Y);
                            Q(u, 3, G.height);
                            Q(u, 4, G.width);
                            Q(u, 5, G.rotation);
                            Q(u, 6, G.W);
                            G = Bb(u, fc);
                            C.call(v, J, G);
                            if (t.O)
                              for (v = 0; v < t.O.length; ++v) {
                                u = t.O[v];
                                var A = u.visibility ? true : false;
                                C = q2.data;
                                J = C.addNormalizedLandmark;
                                G = w;
                                u = Object.assign(Object.assign({}, u), { visibility: A ? u.visibility : 0 });
                                A = new Wb();
                                Q(A, 1, u.x);
                                Q(A, 2, u.y);
                                Q(A, 3, u.z);
                                u.visibility && Q(A, 4, u.visibility);
                                u = Bb(A, Yb);
                                J.call(C, G, u);
                              }
                            if (t.M)
                              for (v = 0; v < t.M.length; ++v)
                                C = q2.data, J = C.addClassification, G = w, u = t.M[v], A = new Ob(), Q(A, 2, u.score), u.index && Q(A, 1, u.index), u.label && Q(A, 3, u.label), u.displayName && Q(A, 4, u.displayName), u = Bb(A, Qb), J.call(C, G, u);
                          }
                          q2 = q2.data;
                          break a;
                        default:
                          q2 = {};
                      }
                    }
                    l = q2;
                    n = h.stream;
                    switch (h.type) {
                      case "video":
                        e.pushTexture2d(Object.assign(Object.assign({}, l), { stream: n, timestamp: d }));
                        break;
                      case "detections":
                        r = l;
                        r.stream = n;
                        r.timestamp = d;
                        e.pushDetectionList(r);
                        break;
                      default:
                        throw Error("Unknown input config type: '" + h.type + "'");
                    }
                  }
                c.i.send(e);
                return F(p2, c.C, 4);
              case 4:
                e.delete(), p2.g = 0;
            }
          });
        };
        function Nc(a, b, c) {
          var d, e, g, f, k, h, l, n, r, p2, m, q2, t, w;
          return H(function(v) {
            switch (v.g) {
              case 1:
                if (!c)
                  return v.return(b);
                d = {};
                e = 0;
                g = B(Object.keys(c));
                for (f = g.next(); !f.done; f = g.next())
                  k = f.value, h = c[k], typeof h !== "string" && h.type === "texture" && b[h.stream] !== void 0 && ++e;
                1 < e && (a.G = false);
                l = B(Object.keys(c));
                f = l.next();
              case 2:
                if (f.done) {
                  v.g = 4;
                  break;
                }
                n = f.value;
                r = c[n];
                if (typeof r === "string")
                  return t = d, w = n, F(v, Oc(a, n, b[r]), 14);
                p2 = b[r.stream];
                if (r.type === "detection_list") {
                  if (p2) {
                    var C = p2.getRectList();
                    for (var J = p2.getLandmarksList(), G = p2.getClassificationsList(), u = [], A = 0; A < C.size(); ++A) {
                      var V = Cb(C.get(A), dc, gc);
                      V = { T: { X: S(V, 1), Y: S(V, 2), height: S(V, 3), width: S(V, 4), rotation: S(V, 5, 0), W: R(V, 6, 0) }, O: xc(J.get(A)), M: vc(Cb(G.get(A), Sb, Vb)) };
                      u.push(V);
                    }
                    C = u;
                  } else
                    C = [];
                  d[n] = C;
                  v.g = 7;
                  break;
                }
                if (r.type === "proto_list") {
                  if (p2) {
                    C = Array(p2.size());
                    for (J = 0; J < p2.size(); J++)
                      C[J] = p2.get(J);
                    p2.delete();
                  } else
                    C = [];
                  d[n] = C;
                  v.g = 7;
                  break;
                }
                if (p2 === void 0) {
                  v.g = 3;
                  break;
                }
                if (r.type === "float_list") {
                  d[n] = p2;
                  v.g = 7;
                  break;
                }
                if (r.type === "proto") {
                  d[n] = p2;
                  v.g = 7;
                  break;
                }
                if (r.type !== "texture")
                  throw Error("Unknown output config type: '" + r.type + "'");
                m = a.s[n];
                m || (m = new yc(a.h, a.D), a.s[n] = m);
                return F(v, zc(m, p2, a.G), 13);
              case 13:
                q2 = v.h, d[n] = q2;
              case 7:
                r.transform && d[n] && (d[n] = r.transform(d[n]));
                v.g = 3;
                break;
              case 14:
                t[w] = v.h;
              case 3:
                f = l.next();
                v.g = 2;
                break;
              case 4:
                return v.return(d);
            }
          });
        }
        function Oc(a, b, c) {
          var d;
          return H(function(e) {
            return typeof c === "number" || c instanceof Uint8Array || c instanceof a.h.Uint8BlobList ? e.return(c) : c instanceof a.h.Texture2dDataOut ? (d = a.s[b], d || (d = new yc(a.h, a.D), a.s[b] = d), e.return(zc(d, c, a.G))) : e.return(void 0);
          });
        }
        function Lc(a, b) {
          for (var c = b.name || "$", d = [].concat(D(b.wants)), e = new a.h.StringList(), g = B(b.wants), f = g.next(); !f.done; f = g.next())
            e.push_back(f.value);
          g = a.h.PacketListener.implement({ onResults: function(k) {
            for (var h = {}, l = 0; l < b.wants.length; ++l)
              h[d[l]] = k.get(l);
            var n = a.listeners[c];
            n && (a.C = Nc(a, h, b.outs).then(function(r) {
              r = n(r);
              for (var p2 = 0; p2 < b.wants.length; ++p2) {
                var m = h[d[p2]];
                typeof m === "object" && m.hasOwnProperty && m.hasOwnProperty("delete") && m.delete();
              }
              r && (a.C = r);
            }));
          } });
          a.i.attachMultiListener(e, g);
          e.delete();
        }
        x.onResults = function(a, b) {
          this.listeners[b || "$"] = a;
        };
        I("Solution", Hc);
        I("OptionType", { BOOL: 0, NUMBER: 1, Z: 2, 0: "BOOL", 1: "NUMBER", 2: "STRING" });
        function Pc(a) {
          return a.map(Qc);
        }
        function Qc(a) {
          a = Cb(a, kc, mc);
          var b = a.getMesh();
          if (!b)
            return a;
          var c = new Float32Array(b.getVertexBufferList());
          b.getVertexBufferList = function() {
            return c;
          };
          var d = new Uint32Array(b.getIndexBufferList());
          b.getIndexBufferList = function() {
            return d;
          };
          return a;
        }
        ;
        function Rc(a) {
          var b = this;
          a = a || {};
          this.g = new Hc({
            locateFile: a.locateFile,
            files: [{ url: "holistic_solution_packed_assets_loader.js" }, { simd: false, url: "holistic_solution_wasm_bin.js" }, { simd: true, url: "holistic_solution_simd_wasm_bin.js" }],
            graph: { url: "holistic.binarypb" },
            inputs: { image: { type: "video", stream: "input_frames_gpu" } },
            listeners: [{ wants: "left_hand_landmarks right_hand_landmarks face_landmarks pose_landmarks world_landmarks segmentation_mask image_transformed multi_face_geometry".split(" "), outs: { image: {
              type: "texture",
              stream: "image_transformed"
            }, leftHandLandmarks: { type: "proto", stream: "left_hand_landmarks", transform: xc }, rightHandLandmarks: { type: "proto", stream: "right_hand_landmarks", transform: xc }, faceLandmarks: { type: "proto", stream: "face_landmarks", transform: xc }, poseLandmarks: { type: "proto", stream: "pose_landmarks", transform: xc }, ea: { type: "proto", stream: "world_landmarks", transform: xc }, segmentationMask: { type: "texture", stream: "segmentation_mask" }, multiFaceGeometry: { type: "proto_list", stream: "multi_face_geometry", transform: Pc } } }],
            options: { useCpuInference: { type: 0, graphOptionXref: { calculatorType: "InferenceCalculator", fieldName: "use_cpu_inference" }, default: "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document }, enableFaceGeometry: { type: 0, graphOptionXref: { calculatorName: "EnableFaceGeometryConstant", calculatorType: "ConstantSidePacketCalculator", fieldName: "bool_value" } }, selfieMode: { type: 0, graphOptionXref: {
              calculatorType: "GlScalerCalculator",
              calculatorIndex: 1,
              fieldName: "flip_horizontal"
            } }, modelComplexity: { type: 1, default: 1, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorModelComplexity", fieldName: "int_value" }, onChange: function(c) {
              var d, e, g, f;
              return H(function(k) {
                if (k.g == 1) {
                  d = "";
                  switch (c) {
                    case 1:
                      d = "pose_landmark_full.tflite";
                      break;
                    case 2:
                      d = "pose_landmark_heavy.tflite";
                      break;
                    default:
                      d = "pose_landmark_lite.tflite";
                  }
                  e = "third_party/mediapipe/modules/pose_landmark/" + d;
                  g = b.g.locateFile(d, "");
                  return F(k, fetch(g), 3);
                }
                if (k.g != 2)
                  return F(k, k.h.arrayBuffer(), 2);
                f = k.h;
                b.g.overrideFile(e, f);
                return F(k, b.g.reset(), 0);
              });
            } }, smoothLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorSmoothLandmarks", fieldName: "bool_value" } }, enableSegmentation: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorEnableSegmentation", fieldName: "bool_value" } }, smoothSegmentation: {
              type: 0,
              graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorSmoothSegmentation", fieldName: "bool_value" }
            }, refineFaceLandmarks: { type: 0, graphOptionXref: { calculatorType: "ConstantSidePacketCalculator", calculatorName: "ConstantSidePacketCalculatorRefineFaceLandmarks", fieldName: "bool_value" } }, minDetectionConfidence: { type: 1, graphOptionXref: {
              calculatorType: "TensorsToDetectionsCalculator",
              calculatorName: "holisticlandmarkgpu__poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",
              fieldName: "min_score_thresh"
            } }, minTrackingConfidence: { type: 1, graphOptionXref: { calculatorType: "ThresholdingCalculator", calculatorName: "holisticlandmarkgpu__poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator", fieldName: "threshold" } }, cameraNear: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "near" } }, cameraFar: { type: 1, graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "far" } }, cameraVerticalFovDegrees: {
              type: 1,
              graphOptionXref: { calculatorType: "FaceGeometryEnvGeneratorCalculator", fieldName: "vertical_fov_degrees" }
            } }
          });
        }
        x = Rc.prototype;
        x.close = function() {
          this.g.close();
          return Promise.resolve();
        };
        x.onResults = function(a) {
          this.g.onResults(a);
        };
        x.initialize = function() {
          var a = this;
          return H(function(b) {
            return F(b, a.g.initialize(), 0);
          });
        };
        x.reset = function() {
          this.g.reset();
        };
        x.send = function(a) {
          var b = this;
          return H(function(c) {
            return F(c, b.g.send(a), 0);
          });
        };
        x.setOptions = function(a) {
          this.g.setOptions(a);
        };
        I("Holistic", Rc);
        I("FACE_GEOMETRY", { Layout: { COLUMN_MAJOR: 0, ROW_MAJOR: 1, 0: "COLUMN_MAJOR", 1: "ROW_MAJOR" }, PrimitiveType: { TRIANGLE: 0, 0: "TRIANGLE" }, VertexType: { VERTEX_PT: 0, 0: "VERTEX_PT" }, DEFAULT_CAMERA_PARAMS: { verticalFovDegrees: 63, near: 1, far: 1e4 } });
        I("FACEMESH_LIPS", nc);
        I("FACEMESH_LEFT_EYE", oc);
        I("FACEMESH_LEFT_EYEBROW", pc);
        I("FACEMESH_LEFT_IRIS", [[474, 475], [475, 476], [476, 477], [477, 474]]);
        I("FACEMESH_RIGHT_EYE", qc);
        I("FACEMESH_RIGHT_EYEBROW", rc);
        I("FACEMESH_RIGHT_IRIS", [[469, 470], [470, 471], [471, 472], [472, 469]]);
        I("FACEMESH_FACE_OVAL", sc);
        I("FACEMESH_CONTOURS", tc);
        I("FACEMESH_TESSELATION", [
          [127, 34],
          [34, 139],
          [139, 127],
          [11, 0],
          [0, 37],
          [37, 11],
          [232, 231],
          [231, 120],
          [120, 232],
          [72, 37],
          [37, 39],
          [39, 72],
          [128, 121],
          [121, 47],
          [47, 128],
          [232, 121],
          [121, 128],
          [128, 232],
          [104, 69],
          [69, 67],
          [67, 104],
          [175, 171],
          [171, 148],
          [148, 175],
          [118, 50],
          [50, 101],
          [101, 118],
          [73, 39],
          [39, 40],
          [40, 73],
          [9, 151],
          [151, 108],
          [108, 9],
          [48, 115],
          [115, 131],
          [131, 48],
          [194, 204],
          [204, 211],
          [211, 194],
          [74, 40],
          [40, 185],
          [185, 74],
          [80, 42],
          [42, 183],
          [183, 80],
          [40, 92],
          [92, 186],
          [186, 40],
          [230, 229],
          [229, 118],
          [118, 230],
          [202, 212],
          [
            212,
            214
          ],
          [214, 202],
          [83, 18],
          [18, 17],
          [17, 83],
          [76, 61],
          [61, 146],
          [146, 76],
          [160, 29],
          [29, 30],
          [30, 160],
          [56, 157],
          [157, 173],
          [173, 56],
          [106, 204],
          [204, 194],
          [194, 106],
          [135, 214],
          [214, 192],
          [192, 135],
          [203, 165],
          [165, 98],
          [98, 203],
          [21, 71],
          [71, 68],
          [68, 21],
          [51, 45],
          [45, 4],
          [4, 51],
          [144, 24],
          [24, 23],
          [23, 144],
          [77, 146],
          [146, 91],
          [91, 77],
          [205, 50],
          [50, 187],
          [187, 205],
          [201, 200],
          [200, 18],
          [18, 201],
          [91, 106],
          [106, 182],
          [182, 91],
          [90, 91],
          [91, 181],
          [181, 90],
          [85, 84],
          [84, 17],
          [17, 85],
          [206, 203],
          [203, 36],
          [36, 206],
          [148, 171],
          [171, 140],
          [140, 148],
          [
            92,
            40
          ],
          [40, 39],
          [39, 92],
          [193, 189],
          [189, 244],
          [244, 193],
          [159, 158],
          [158, 28],
          [28, 159],
          [247, 246],
          [246, 161],
          [161, 247],
          [236, 3],
          [3, 196],
          [196, 236],
          [54, 68],
          [68, 104],
          [104, 54],
          [193, 168],
          [168, 8],
          [8, 193],
          [117, 228],
          [228, 31],
          [31, 117],
          [189, 193],
          [193, 55],
          [55, 189],
          [98, 97],
          [97, 99],
          [99, 98],
          [126, 47],
          [47, 100],
          [100, 126],
          [166, 79],
          [79, 218],
          [218, 166],
          [155, 154],
          [154, 26],
          [26, 155],
          [209, 49],
          [49, 131],
          [131, 209],
          [135, 136],
          [136, 150],
          [150, 135],
          [47, 126],
          [126, 217],
          [217, 47],
          [223, 52],
          [52, 53],
          [53, 223],
          [45, 51],
          [51, 134],
          [134, 45],
          [211, 170],
          [
            170,
            140
          ],
          [140, 211],
          [67, 69],
          [69, 108],
          [108, 67],
          [43, 106],
          [106, 91],
          [91, 43],
          [230, 119],
          [119, 120],
          [120, 230],
          [226, 130],
          [130, 247],
          [247, 226],
          [63, 53],
          [53, 52],
          [52, 63],
          [238, 20],
          [20, 242],
          [242, 238],
          [46, 70],
          [70, 156],
          [156, 46],
          [78, 62],
          [62, 96],
          [96, 78],
          [46, 53],
          [53, 63],
          [63, 46],
          [143, 34],
          [34, 227],
          [227, 143],
          [123, 117],
          [117, 111],
          [111, 123],
          [44, 125],
          [125, 19],
          [19, 44],
          [236, 134],
          [134, 51],
          [51, 236],
          [216, 206],
          [206, 205],
          [205, 216],
          [154, 153],
          [153, 22],
          [22, 154],
          [39, 37],
          [37, 167],
          [167, 39],
          [200, 201],
          [201, 208],
          [208, 200],
          [36, 142],
          [142, 100],
          [
            100,
            36
          ],
          [57, 212],
          [212, 202],
          [202, 57],
          [20, 60],
          [60, 99],
          [99, 20],
          [28, 158],
          [158, 157],
          [157, 28],
          [35, 226],
          [226, 113],
          [113, 35],
          [160, 159],
          [159, 27],
          [27, 160],
          [204, 202],
          [202, 210],
          [210, 204],
          [113, 225],
          [225, 46],
          [46, 113],
          [43, 202],
          [202, 204],
          [204, 43],
          [62, 76],
          [76, 77],
          [77, 62],
          [137, 123],
          [123, 116],
          [116, 137],
          [41, 38],
          [38, 72],
          [72, 41],
          [203, 129],
          [129, 142],
          [142, 203],
          [64, 98],
          [98, 240],
          [240, 64],
          [49, 102],
          [102, 64],
          [64, 49],
          [41, 73],
          [73, 74],
          [74, 41],
          [212, 216],
          [216, 207],
          [207, 212],
          [42, 74],
          [74, 184],
          [184, 42],
          [169, 170],
          [170, 211],
          [211, 169],
          [
            170,
            149
          ],
          [149, 176],
          [176, 170],
          [105, 66],
          [66, 69],
          [69, 105],
          [122, 6],
          [6, 168],
          [168, 122],
          [123, 147],
          [147, 187],
          [187, 123],
          [96, 77],
          [77, 90],
          [90, 96],
          [65, 55],
          [55, 107],
          [107, 65],
          [89, 90],
          [90, 180],
          [180, 89],
          [101, 100],
          [100, 120],
          [120, 101],
          [63, 105],
          [105, 104],
          [104, 63],
          [93, 137],
          [137, 227],
          [227, 93],
          [15, 86],
          [86, 85],
          [85, 15],
          [129, 102],
          [102, 49],
          [49, 129],
          [14, 87],
          [87, 86],
          [86, 14],
          [55, 8],
          [8, 9],
          [9, 55],
          [100, 47],
          [47, 121],
          [121, 100],
          [145, 23],
          [23, 22],
          [22, 145],
          [88, 89],
          [89, 179],
          [179, 88],
          [6, 122],
          [122, 196],
          [196, 6],
          [88, 95],
          [95, 96],
          [96, 88],
          [138, 172],
          [172, 136],
          [136, 138],
          [215, 58],
          [58, 172],
          [172, 215],
          [115, 48],
          [48, 219],
          [219, 115],
          [42, 80],
          [80, 81],
          [81, 42],
          [195, 3],
          [3, 51],
          [51, 195],
          [43, 146],
          [146, 61],
          [61, 43],
          [171, 175],
          [175, 199],
          [199, 171],
          [81, 82],
          [82, 38],
          [38, 81],
          [53, 46],
          [46, 225],
          [225, 53],
          [144, 163],
          [163, 110],
          [110, 144],
          [52, 65],
          [65, 66],
          [66, 52],
          [229, 228],
          [228, 117],
          [117, 229],
          [34, 127],
          [127, 234],
          [234, 34],
          [107, 108],
          [108, 69],
          [69, 107],
          [109, 108],
          [108, 151],
          [151, 109],
          [48, 64],
          [64, 235],
          [235, 48],
          [62, 78],
          [78, 191],
          [191, 62],
          [129, 209],
          [209, 126],
          [126, 129],
          [111, 35],
          [35, 143],
          [
            143,
            111
          ],
          [117, 123],
          [123, 50],
          [50, 117],
          [222, 65],
          [65, 52],
          [52, 222],
          [19, 125],
          [125, 141],
          [141, 19],
          [221, 55],
          [55, 65],
          [65, 221],
          [3, 195],
          [195, 197],
          [197, 3],
          [25, 7],
          [7, 33],
          [33, 25],
          [220, 237],
          [237, 44],
          [44, 220],
          [70, 71],
          [71, 139],
          [139, 70],
          [122, 193],
          [193, 245],
          [245, 122],
          [247, 130],
          [130, 33],
          [33, 247],
          [71, 21],
          [21, 162],
          [162, 71],
          [170, 169],
          [169, 150],
          [150, 170],
          [188, 174],
          [174, 196],
          [196, 188],
          [216, 186],
          [186, 92],
          [92, 216],
          [2, 97],
          [97, 167],
          [167, 2],
          [141, 125],
          [125, 241],
          [241, 141],
          [164, 167],
          [167, 37],
          [37, 164],
          [72, 38],
          [38, 12],
          [12, 72],
          [38, 82],
          [82, 13],
          [13, 38],
          [63, 68],
          [68, 71],
          [71, 63],
          [226, 35],
          [35, 111],
          [111, 226],
          [101, 50],
          [50, 205],
          [205, 101],
          [206, 92],
          [92, 165],
          [165, 206],
          [209, 198],
          [198, 217],
          [217, 209],
          [165, 167],
          [167, 97],
          [97, 165],
          [220, 115],
          [115, 218],
          [218, 220],
          [133, 112],
          [112, 243],
          [243, 133],
          [239, 238],
          [238, 241],
          [241, 239],
          [214, 135],
          [135, 169],
          [169, 214],
          [190, 173],
          [173, 133],
          [133, 190],
          [171, 208],
          [208, 32],
          [32, 171],
          [125, 44],
          [44, 237],
          [237, 125],
          [86, 87],
          [87, 178],
          [178, 86],
          [85, 86],
          [86, 179],
          [179, 85],
          [84, 85],
          [85, 180],
          [180, 84],
          [83, 84],
          [84, 181],
          [181, 83],
          [201, 83],
          [83, 182],
          [182, 201],
          [137, 93],
          [93, 132],
          [132, 137],
          [76, 62],
          [62, 183],
          [183, 76],
          [61, 76],
          [76, 184],
          [184, 61],
          [57, 61],
          [61, 185],
          [185, 57],
          [212, 57],
          [57, 186],
          [186, 212],
          [214, 207],
          [207, 187],
          [187, 214],
          [34, 143],
          [143, 156],
          [156, 34],
          [79, 239],
          [239, 237],
          [237, 79],
          [123, 137],
          [137, 177],
          [177, 123],
          [44, 1],
          [1, 4],
          [4, 44],
          [201, 194],
          [194, 32],
          [32, 201],
          [64, 102],
          [102, 129],
          [129, 64],
          [213, 215],
          [215, 138],
          [138, 213],
          [59, 166],
          [166, 219],
          [219, 59],
          [242, 99],
          [99, 97],
          [97, 242],
          [2, 94],
          [94, 141],
          [141, 2],
          [75, 59],
          [59, 235],
          [235, 75],
          [24, 110],
          [110, 228],
          [
            228,
            24
          ],
          [25, 130],
          [130, 226],
          [226, 25],
          [23, 24],
          [24, 229],
          [229, 23],
          [22, 23],
          [23, 230],
          [230, 22],
          [26, 22],
          [22, 231],
          [231, 26],
          [112, 26],
          [26, 232],
          [232, 112],
          [189, 190],
          [190, 243],
          [243, 189],
          [221, 56],
          [56, 190],
          [190, 221],
          [28, 56],
          [56, 221],
          [221, 28],
          [27, 28],
          [28, 222],
          [222, 27],
          [29, 27],
          [27, 223],
          [223, 29],
          [30, 29],
          [29, 224],
          [224, 30],
          [247, 30],
          [30, 225],
          [225, 247],
          [238, 79],
          [79, 20],
          [20, 238],
          [166, 59],
          [59, 75],
          [75, 166],
          [60, 75],
          [75, 240],
          [240, 60],
          [147, 177],
          [177, 215],
          [215, 147],
          [20, 79],
          [79, 166],
          [166, 20],
          [187, 147],
          [147, 213],
          [213, 187],
          [112, 233],
          [233, 244],
          [244, 112],
          [233, 128],
          [128, 245],
          [245, 233],
          [128, 114],
          [114, 188],
          [188, 128],
          [114, 217],
          [217, 174],
          [174, 114],
          [131, 115],
          [115, 220],
          [220, 131],
          [217, 198],
          [198, 236],
          [236, 217],
          [198, 131],
          [131, 134],
          [134, 198],
          [177, 132],
          [132, 58],
          [58, 177],
          [143, 35],
          [35, 124],
          [124, 143],
          [110, 163],
          [163, 7],
          [7, 110],
          [228, 110],
          [110, 25],
          [25, 228],
          [356, 389],
          [389, 368],
          [368, 356],
          [11, 302],
          [302, 267],
          [267, 11],
          [452, 350],
          [350, 349],
          [349, 452],
          [302, 303],
          [303, 269],
          [269, 302],
          [357, 343],
          [343, 277],
          [277, 357],
          [452, 453],
          [453, 357],
          [357, 452],
          [333, 332],
          [
            332,
            297
          ],
          [297, 333],
          [175, 152],
          [152, 377],
          [377, 175],
          [347, 348],
          [348, 330],
          [330, 347],
          [303, 304],
          [304, 270],
          [270, 303],
          [9, 336],
          [336, 337],
          [337, 9],
          [278, 279],
          [279, 360],
          [360, 278],
          [418, 262],
          [262, 431],
          [431, 418],
          [304, 408],
          [408, 409],
          [409, 304],
          [310, 415],
          [415, 407],
          [407, 310],
          [270, 409],
          [409, 410],
          [410, 270],
          [450, 348],
          [348, 347],
          [347, 450],
          [422, 430],
          [430, 434],
          [434, 422],
          [313, 314],
          [314, 17],
          [17, 313],
          [306, 307],
          [307, 375],
          [375, 306],
          [387, 388],
          [388, 260],
          [260, 387],
          [286, 414],
          [414, 398],
          [398, 286],
          [335, 406],
          [406, 418],
          [418, 335],
          [364, 367],
          [
            367,
            416
          ],
          [416, 364],
          [423, 358],
          [358, 327],
          [327, 423],
          [251, 284],
          [284, 298],
          [298, 251],
          [281, 5],
          [5, 4],
          [4, 281],
          [373, 374],
          [374, 253],
          [253, 373],
          [307, 320],
          [320, 321],
          [321, 307],
          [425, 427],
          [427, 411],
          [411, 425],
          [421, 313],
          [313, 18],
          [18, 421],
          [321, 405],
          [405, 406],
          [406, 321],
          [320, 404],
          [404, 405],
          [405, 320],
          [315, 16],
          [16, 17],
          [17, 315],
          [426, 425],
          [425, 266],
          [266, 426],
          [377, 400],
          [400, 369],
          [369, 377],
          [322, 391],
          [391, 269],
          [269, 322],
          [417, 465],
          [465, 464],
          [464, 417],
          [386, 257],
          [257, 258],
          [258, 386],
          [466, 260],
          [260, 388],
          [388, 466],
          [456, 399],
          [399, 419],
          [419, 456],
          [284, 332],
          [332, 333],
          [333, 284],
          [417, 285],
          [285, 8],
          [8, 417],
          [346, 340],
          [340, 261],
          [261, 346],
          [413, 441],
          [441, 285],
          [285, 413],
          [327, 460],
          [460, 328],
          [328, 327],
          [355, 371],
          [371, 329],
          [329, 355],
          [392, 439],
          [439, 438],
          [438, 392],
          [382, 341],
          [341, 256],
          [256, 382],
          [429, 420],
          [420, 360],
          [360, 429],
          [364, 394],
          [394, 379],
          [379, 364],
          [277, 343],
          [343, 437],
          [437, 277],
          [443, 444],
          [444, 283],
          [283, 443],
          [275, 440],
          [440, 363],
          [363, 275],
          [431, 262],
          [262, 369],
          [369, 431],
          [297, 338],
          [338, 337],
          [337, 297],
          [273, 375],
          [375, 321],
          [321, 273],
          [450, 451],
          [
            451,
            349
          ],
          [349, 450],
          [446, 342],
          [342, 467],
          [467, 446],
          [293, 334],
          [334, 282],
          [282, 293],
          [458, 461],
          [461, 462],
          [462, 458],
          [276, 353],
          [353, 383],
          [383, 276],
          [308, 324],
          [324, 325],
          [325, 308],
          [276, 300],
          [300, 293],
          [293, 276],
          [372, 345],
          [345, 447],
          [447, 372],
          [352, 345],
          [345, 340],
          [340, 352],
          [274, 1],
          [1, 19],
          [19, 274],
          [456, 248],
          [248, 281],
          [281, 456],
          [436, 427],
          [427, 425],
          [425, 436],
          [381, 256],
          [256, 252],
          [252, 381],
          [269, 391],
          [391, 393],
          [393, 269],
          [200, 199],
          [199, 428],
          [428, 200],
          [266, 330],
          [330, 329],
          [329, 266],
          [287, 273],
          [273, 422],
          [422, 287],
          [250, 462],
          [
            462,
            328
          ],
          [328, 250],
          [258, 286],
          [286, 384],
          [384, 258],
          [265, 353],
          [353, 342],
          [342, 265],
          [387, 259],
          [259, 257],
          [257, 387],
          [424, 431],
          [431, 430],
          [430, 424],
          [342, 353],
          [353, 276],
          [276, 342],
          [273, 335],
          [335, 424],
          [424, 273],
          [292, 325],
          [325, 307],
          [307, 292],
          [366, 447],
          [447, 345],
          [345, 366],
          [271, 303],
          [303, 302],
          [302, 271],
          [423, 266],
          [266, 371],
          [371, 423],
          [294, 455],
          [455, 460],
          [460, 294],
          [279, 278],
          [278, 294],
          [294, 279],
          [271, 272],
          [272, 304],
          [304, 271],
          [432, 434],
          [434, 427],
          [427, 432],
          [272, 407],
          [407, 408],
          [408, 272],
          [394, 430],
          [430, 431],
          [431, 394],
          [395, 369],
          [369, 400],
          [400, 395],
          [334, 333],
          [333, 299],
          [299, 334],
          [351, 417],
          [417, 168],
          [168, 351],
          [352, 280],
          [280, 411],
          [411, 352],
          [325, 319],
          [319, 320],
          [320, 325],
          [295, 296],
          [296, 336],
          [336, 295],
          [319, 403],
          [403, 404],
          [404, 319],
          [330, 348],
          [348, 349],
          [349, 330],
          [293, 298],
          [298, 333],
          [333, 293],
          [323, 454],
          [454, 447],
          [447, 323],
          [15, 16],
          [16, 315],
          [315, 15],
          [358, 429],
          [429, 279],
          [279, 358],
          [14, 15],
          [15, 316],
          [316, 14],
          [285, 336],
          [336, 9],
          [9, 285],
          [329, 349],
          [349, 350],
          [350, 329],
          [374, 380],
          [380, 252],
          [252, 374],
          [318, 402],
          [402, 403],
          [403, 318],
          [6, 197],
          [
            197,
            419
          ],
          [419, 6],
          [318, 319],
          [319, 325],
          [325, 318],
          [367, 364],
          [364, 365],
          [365, 367],
          [435, 367],
          [367, 397],
          [397, 435],
          [344, 438],
          [438, 439],
          [439, 344],
          [272, 271],
          [271, 311],
          [311, 272],
          [195, 5],
          [5, 281],
          [281, 195],
          [273, 287],
          [287, 291],
          [291, 273],
          [396, 428],
          [428, 199],
          [199, 396],
          [311, 271],
          [271, 268],
          [268, 311],
          [283, 444],
          [444, 445],
          [445, 283],
          [373, 254],
          [254, 339],
          [339, 373],
          [282, 334],
          [334, 296],
          [296, 282],
          [449, 347],
          [347, 346],
          [346, 449],
          [264, 447],
          [447, 454],
          [454, 264],
          [336, 296],
          [296, 299],
          [299, 336],
          [338, 10],
          [10, 151],
          [151, 338],
          [278, 439],
          [
            439,
            455
          ],
          [455, 278],
          [292, 407],
          [407, 415],
          [415, 292],
          [358, 371],
          [371, 355],
          [355, 358],
          [340, 345],
          [345, 372],
          [372, 340],
          [346, 347],
          [347, 280],
          [280, 346],
          [442, 443],
          [443, 282],
          [282, 442],
          [19, 94],
          [94, 370],
          [370, 19],
          [441, 442],
          [442, 295],
          [295, 441],
          [248, 419],
          [419, 197],
          [197, 248],
          [263, 255],
          [255, 359],
          [359, 263],
          [440, 275],
          [275, 274],
          [274, 440],
          [300, 383],
          [383, 368],
          [368, 300],
          [351, 412],
          [412, 465],
          [465, 351],
          [263, 467],
          [467, 466],
          [466, 263],
          [301, 368],
          [368, 389],
          [389, 301],
          [395, 378],
          [378, 379],
          [379, 395],
          [412, 351],
          [351, 419],
          [419, 412],
          [436, 426],
          [426, 322],
          [322, 436],
          [2, 164],
          [164, 393],
          [393, 2],
          [370, 462],
          [462, 461],
          [461, 370],
          [164, 0],
          [0, 267],
          [267, 164],
          [302, 11],
          [11, 12],
          [12, 302],
          [268, 12],
          [12, 13],
          [13, 268],
          [293, 300],
          [300, 301],
          [301, 293],
          [446, 261],
          [261, 340],
          [340, 446],
          [330, 266],
          [266, 425],
          [425, 330],
          [426, 423],
          [423, 391],
          [391, 426],
          [429, 355],
          [355, 437],
          [437, 429],
          [391, 327],
          [327, 326],
          [326, 391],
          [440, 457],
          [457, 438],
          [438, 440],
          [341, 382],
          [382, 362],
          [362, 341],
          [459, 457],
          [457, 461],
          [461, 459],
          [434, 430],
          [430, 394],
          [394, 434],
          [414, 463],
          [463, 362],
          [362, 414],
          [396, 369],
          [369, 262],
          [262, 396],
          [354, 461],
          [461, 457],
          [457, 354],
          [316, 403],
          [403, 402],
          [402, 316],
          [315, 404],
          [404, 403],
          [403, 315],
          [314, 405],
          [405, 404],
          [404, 314],
          [313, 406],
          [406, 405],
          [405, 313],
          [421, 418],
          [418, 406],
          [406, 421],
          [366, 401],
          [401, 361],
          [361, 366],
          [306, 408],
          [408, 407],
          [407, 306],
          [291, 409],
          [409, 408],
          [408, 291],
          [287, 410],
          [410, 409],
          [409, 287],
          [432, 436],
          [436, 410],
          [410, 432],
          [434, 416],
          [416, 411],
          [411, 434],
          [264, 368],
          [368, 383],
          [383, 264],
          [309, 438],
          [438, 457],
          [457, 309],
          [352, 376],
          [376, 401],
          [401, 352],
          [274, 275],
          [275, 4],
          [4, 274],
          [421, 428],
          [
            428,
            262
          ],
          [262, 421],
          [294, 327],
          [327, 358],
          [358, 294],
          [433, 416],
          [416, 367],
          [367, 433],
          [289, 455],
          [455, 439],
          [439, 289],
          [462, 370],
          [370, 326],
          [326, 462],
          [2, 326],
          [326, 370],
          [370, 2],
          [305, 460],
          [460, 455],
          [455, 305],
          [254, 449],
          [449, 448],
          [448, 254],
          [255, 261],
          [261, 446],
          [446, 255],
          [253, 450],
          [450, 449],
          [449, 253],
          [252, 451],
          [451, 450],
          [450, 252],
          [256, 452],
          [452, 451],
          [451, 256],
          [341, 453],
          [453, 452],
          [452, 341],
          [413, 464],
          [464, 463],
          [463, 413],
          [441, 413],
          [413, 414],
          [414, 441],
          [258, 442],
          [442, 441],
          [441, 258],
          [257, 443],
          [443, 442],
          [442, 257],
          [259, 444],
          [444, 443],
          [443, 259],
          [260, 445],
          [445, 444],
          [444, 260],
          [467, 342],
          [342, 445],
          [445, 467],
          [459, 458],
          [458, 250],
          [250, 459],
          [289, 392],
          [392, 290],
          [290, 289],
          [290, 328],
          [328, 460],
          [460, 290],
          [376, 433],
          [433, 435],
          [435, 376],
          [250, 290],
          [290, 392],
          [392, 250],
          [411, 416],
          [416, 433],
          [433, 411],
          [341, 463],
          [463, 464],
          [464, 341],
          [453, 464],
          [464, 465],
          [465, 453],
          [357, 465],
          [465, 412],
          [412, 357],
          [343, 412],
          [412, 399],
          [399, 343],
          [360, 363],
          [363, 440],
          [440, 360],
          [437, 399],
          [399, 456],
          [456, 437],
          [420, 456],
          [456, 363],
          [363, 420],
          [401, 435],
          [435, 288],
          [288, 401],
          [
            372,
            383
          ],
          [383, 353],
          [353, 372],
          [339, 255],
          [255, 249],
          [249, 339],
          [448, 261],
          [261, 255],
          [255, 448],
          [133, 243],
          [243, 190],
          [190, 133],
          [133, 155],
          [155, 112],
          [112, 133],
          [33, 246],
          [246, 247],
          [247, 33],
          [33, 130],
          [130, 25],
          [25, 33],
          [398, 384],
          [384, 286],
          [286, 398],
          [362, 398],
          [398, 414],
          [414, 362],
          [362, 463],
          [463, 341],
          [341, 362],
          [263, 359],
          [359, 467],
          [467, 263],
          [263, 249],
          [249, 255],
          [255, 263],
          [466, 467],
          [467, 260],
          [260, 466],
          [75, 60],
          [60, 166],
          [166, 75],
          [238, 239],
          [239, 79],
          [79, 238],
          [162, 127],
          [127, 139],
          [139, 162],
          [72, 11],
          [11, 37],
          [37, 72],
          [121, 232],
          [
            232,
            120
          ],
          [120, 121],
          [73, 72],
          [72, 39],
          [39, 73],
          [114, 128],
          [128, 47],
          [47, 114],
          [233, 232],
          [232, 128],
          [128, 233],
          [103, 104],
          [104, 67],
          [67, 103],
          [152, 175],
          [175, 148],
          [148, 152],
          [119, 118],
          [118, 101],
          [101, 119],
          [74, 73],
          [73, 40],
          [40, 74],
          [107, 9],
          [9, 108],
          [108, 107],
          [49, 48],
          [48, 131],
          [131, 49],
          [32, 194],
          [194, 211],
          [211, 32],
          [184, 74],
          [74, 185],
          [185, 184],
          [191, 80],
          [80, 183],
          [183, 191],
          [185, 40],
          [40, 186],
          [186, 185],
          [119, 230],
          [230, 118],
          [118, 119],
          [210, 202],
          [202, 214],
          [214, 210],
          [84, 83],
          [83, 17],
          [17, 84],
          [77, 76],
          [76, 146],
          [146, 77],
          [161, 160],
          [160, 30],
          [30, 161],
          [190, 56],
          [56, 173],
          [173, 190],
          [182, 106],
          [106, 194],
          [194, 182],
          [138, 135],
          [135, 192],
          [192, 138],
          [129, 203],
          [203, 98],
          [98, 129],
          [54, 21],
          [21, 68],
          [68, 54],
          [5, 51],
          [51, 4],
          [4, 5],
          [145, 144],
          [144, 23],
          [23, 145],
          [90, 77],
          [77, 91],
          [91, 90],
          [207, 205],
          [205, 187],
          [187, 207],
          [83, 201],
          [201, 18],
          [18, 83],
          [181, 91],
          [91, 182],
          [182, 181],
          [180, 90],
          [90, 181],
          [181, 180],
          [16, 85],
          [85, 17],
          [17, 16],
          [205, 206],
          [206, 36],
          [36, 205],
          [176, 148],
          [148, 140],
          [140, 176],
          [165, 92],
          [92, 39],
          [39, 165],
          [245, 193],
          [193, 244],
          [244, 245],
          [27, 159],
          [159, 28],
          [28, 27],
          [
            30,
            247
          ],
          [247, 161],
          [161, 30],
          [174, 236],
          [236, 196],
          [196, 174],
          [103, 54],
          [54, 104],
          [104, 103],
          [55, 193],
          [193, 8],
          [8, 55],
          [111, 117],
          [117, 31],
          [31, 111],
          [221, 189],
          [189, 55],
          [55, 221],
          [240, 98],
          [98, 99],
          [99, 240],
          [142, 126],
          [126, 100],
          [100, 142],
          [219, 166],
          [166, 218],
          [218, 219],
          [112, 155],
          [155, 26],
          [26, 112],
          [198, 209],
          [209, 131],
          [131, 198],
          [169, 135],
          [135, 150],
          [150, 169],
          [114, 47],
          [47, 217],
          [217, 114],
          [224, 223],
          [223, 53],
          [53, 224],
          [220, 45],
          [45, 134],
          [134, 220],
          [32, 211],
          [211, 140],
          [140, 32],
          [109, 67],
          [67, 108],
          [108, 109],
          [146, 43],
          [43, 91],
          [91, 146],
          [231, 230],
          [230, 120],
          [120, 231],
          [113, 226],
          [226, 247],
          [247, 113],
          [105, 63],
          [63, 52],
          [52, 105],
          [241, 238],
          [238, 242],
          [242, 241],
          [124, 46],
          [46, 156],
          [156, 124],
          [95, 78],
          [78, 96],
          [96, 95],
          [70, 46],
          [46, 63],
          [63, 70],
          [116, 143],
          [143, 227],
          [227, 116],
          [116, 123],
          [123, 111],
          [111, 116],
          [1, 44],
          [44, 19],
          [19, 1],
          [3, 236],
          [236, 51],
          [51, 3],
          [207, 216],
          [216, 205],
          [205, 207],
          [26, 154],
          [154, 22],
          [22, 26],
          [165, 39],
          [39, 167],
          [167, 165],
          [199, 200],
          [200, 208],
          [208, 199],
          [101, 36],
          [36, 100],
          [100, 101],
          [43, 57],
          [57, 202],
          [202, 43],
          [242, 20],
          [20, 99],
          [99, 242],
          [56, 28],
          [
            28,
            157
          ],
          [157, 56],
          [124, 35],
          [35, 113],
          [113, 124],
          [29, 160],
          [160, 27],
          [27, 29],
          [211, 204],
          [204, 210],
          [210, 211],
          [124, 113],
          [113, 46],
          [46, 124],
          [106, 43],
          [43, 204],
          [204, 106],
          [96, 62],
          [62, 77],
          [77, 96],
          [227, 137],
          [137, 116],
          [116, 227],
          [73, 41],
          [41, 72],
          [72, 73],
          [36, 203],
          [203, 142],
          [142, 36],
          [235, 64],
          [64, 240],
          [240, 235],
          [48, 49],
          [49, 64],
          [64, 48],
          [42, 41],
          [41, 74],
          [74, 42],
          [214, 212],
          [212, 207],
          [207, 214],
          [183, 42],
          [42, 184],
          [184, 183],
          [210, 169],
          [169, 211],
          [211, 210],
          [140, 170],
          [170, 176],
          [176, 140],
          [104, 105],
          [105, 69],
          [69, 104],
          [193, 122],
          [122, 168],
          [168, 193],
          [50, 123],
          [123, 187],
          [187, 50],
          [89, 96],
          [96, 90],
          [90, 89],
          [66, 65],
          [65, 107],
          [107, 66],
          [179, 89],
          [89, 180],
          [180, 179],
          [119, 101],
          [101, 120],
          [120, 119],
          [68, 63],
          [63, 104],
          [104, 68],
          [234, 93],
          [93, 227],
          [227, 234],
          [16, 15],
          [15, 85],
          [85, 16],
          [209, 129],
          [129, 49],
          [49, 209],
          [15, 14],
          [14, 86],
          [86, 15],
          [107, 55],
          [55, 9],
          [9, 107],
          [120, 100],
          [100, 121],
          [121, 120],
          [153, 145],
          [145, 22],
          [22, 153],
          [178, 88],
          [88, 179],
          [179, 178],
          [197, 6],
          [6, 196],
          [196, 197],
          [89, 88],
          [88, 96],
          [96, 89],
          [135, 138],
          [138, 136],
          [136, 135],
          [138, 215],
          [215, 172],
          [172, 138],
          [
            218,
            115
          ],
          [115, 219],
          [219, 218],
          [41, 42],
          [42, 81],
          [81, 41],
          [5, 195],
          [195, 51],
          [51, 5],
          [57, 43],
          [43, 61],
          [61, 57],
          [208, 171],
          [171, 199],
          [199, 208],
          [41, 81],
          [81, 38],
          [38, 41],
          [224, 53],
          [53, 225],
          [225, 224],
          [24, 144],
          [144, 110],
          [110, 24],
          [105, 52],
          [52, 66],
          [66, 105],
          [118, 229],
          [229, 117],
          [117, 118],
          [227, 34],
          [34, 234],
          [234, 227],
          [66, 107],
          [107, 69],
          [69, 66],
          [10, 109],
          [109, 151],
          [151, 10],
          [219, 48],
          [48, 235],
          [235, 219],
          [183, 62],
          [62, 191],
          [191, 183],
          [142, 129],
          [129, 126],
          [126, 142],
          [116, 111],
          [111, 143],
          [143, 116],
          [118, 117],
          [117, 50],
          [50, 118],
          [223, 222],
          [
            222,
            52
          ],
          [52, 223],
          [94, 19],
          [19, 141],
          [141, 94],
          [222, 221],
          [221, 65],
          [65, 222],
          [196, 3],
          [3, 197],
          [197, 196],
          [45, 220],
          [220, 44],
          [44, 45],
          [156, 70],
          [70, 139],
          [139, 156],
          [188, 122],
          [122, 245],
          [245, 188],
          [139, 71],
          [71, 162],
          [162, 139],
          [149, 170],
          [170, 150],
          [150, 149],
          [122, 188],
          [188, 196],
          [196, 122],
          [206, 216],
          [216, 92],
          [92, 206],
          [164, 2],
          [2, 167],
          [167, 164],
          [242, 141],
          [141, 241],
          [241, 242],
          [0, 164],
          [164, 37],
          [37, 0],
          [11, 72],
          [72, 12],
          [12, 11],
          [12, 38],
          [38, 13],
          [13, 12],
          [70, 63],
          [63, 71],
          [71, 70],
          [31, 226],
          [226, 111],
          [111, 31],
          [36, 101],
          [101, 205],
          [205, 36],
          [203, 206],
          [206, 165],
          [165, 203],
          [126, 209],
          [209, 217],
          [217, 126],
          [98, 165],
          [165, 97],
          [97, 98],
          [237, 220],
          [220, 218],
          [218, 237],
          [237, 239],
          [239, 241],
          [241, 237],
          [210, 214],
          [214, 169],
          [169, 210],
          [140, 171],
          [171, 32],
          [32, 140],
          [241, 125],
          [125, 237],
          [237, 241],
          [179, 86],
          [86, 178],
          [178, 179],
          [180, 85],
          [85, 179],
          [179, 180],
          [181, 84],
          [84, 180],
          [180, 181],
          [182, 83],
          [83, 181],
          [181, 182],
          [194, 201],
          [201, 182],
          [182, 194],
          [177, 137],
          [137, 132],
          [132, 177],
          [184, 76],
          [76, 183],
          [183, 184],
          [185, 61],
          [61, 184],
          [184, 185],
          [186, 57],
          [57, 185],
          [185, 186],
          [216, 212],
          [
            212,
            186
          ],
          [186, 216],
          [192, 214],
          [214, 187],
          [187, 192],
          [139, 34],
          [34, 156],
          [156, 139],
          [218, 79],
          [79, 237],
          [237, 218],
          [147, 123],
          [123, 177],
          [177, 147],
          [45, 44],
          [44, 4],
          [4, 45],
          [208, 201],
          [201, 32],
          [32, 208],
          [98, 64],
          [64, 129],
          [129, 98],
          [192, 213],
          [213, 138],
          [138, 192],
          [235, 59],
          [59, 219],
          [219, 235],
          [141, 242],
          [242, 97],
          [97, 141],
          [97, 2],
          [2, 141],
          [141, 97],
          [240, 75],
          [75, 235],
          [235, 240],
          [229, 24],
          [24, 228],
          [228, 229],
          [31, 25],
          [25, 226],
          [226, 31],
          [230, 23],
          [23, 229],
          [229, 230],
          [231, 22],
          [22, 230],
          [230, 231],
          [232, 26],
          [26, 231],
          [231, 232],
          [233, 112],
          [112, 232],
          [232, 233],
          [244, 189],
          [189, 243],
          [243, 244],
          [189, 221],
          [221, 190],
          [190, 189],
          [222, 28],
          [28, 221],
          [221, 222],
          [223, 27],
          [27, 222],
          [222, 223],
          [224, 29],
          [29, 223],
          [223, 224],
          [225, 30],
          [30, 224],
          [224, 225],
          [113, 247],
          [247, 225],
          [225, 113],
          [99, 60],
          [60, 240],
          [240, 99],
          [213, 147],
          [147, 215],
          [215, 213],
          [60, 20],
          [20, 166],
          [166, 60],
          [192, 187],
          [187, 213],
          [213, 192],
          [243, 112],
          [112, 244],
          [244, 243],
          [244, 233],
          [233, 245],
          [245, 244],
          [245, 128],
          [128, 188],
          [188, 245],
          [188, 114],
          [114, 174],
          [174, 188],
          [134, 131],
          [131, 220],
          [220, 134],
          [174, 217],
          [217, 236],
          [236, 174],
          [236, 198],
          [198, 134],
          [134, 236],
          [215, 177],
          [177, 58],
          [58, 215],
          [156, 143],
          [143, 124],
          [124, 156],
          [25, 110],
          [110, 7],
          [7, 25],
          [31, 228],
          [228, 25],
          [25, 31],
          [264, 356],
          [356, 368],
          [368, 264],
          [0, 11],
          [11, 267],
          [267, 0],
          [451, 452],
          [452, 349],
          [349, 451],
          [267, 302],
          [302, 269],
          [269, 267],
          [350, 357],
          [357, 277],
          [277, 350],
          [350, 452],
          [452, 357],
          [357, 350],
          [299, 333],
          [333, 297],
          [297, 299],
          [396, 175],
          [175, 377],
          [377, 396],
          [280, 347],
          [347, 330],
          [330, 280],
          [269, 303],
          [303, 270],
          [270, 269],
          [151, 9],
          [9, 337],
          [337, 151],
          [344, 278],
          [278, 360],
          [360, 344],
          [424, 418],
          [
            418,
            431
          ],
          [431, 424],
          [270, 304],
          [304, 409],
          [409, 270],
          [272, 310],
          [310, 407],
          [407, 272],
          [322, 270],
          [270, 410],
          [410, 322],
          [449, 450],
          [450, 347],
          [347, 449],
          [432, 422],
          [422, 434],
          [434, 432],
          [18, 313],
          [313, 17],
          [17, 18],
          [291, 306],
          [306, 375],
          [375, 291],
          [259, 387],
          [387, 260],
          [260, 259],
          [424, 335],
          [335, 418],
          [418, 424],
          [434, 364],
          [364, 416],
          [416, 434],
          [391, 423],
          [423, 327],
          [327, 391],
          [301, 251],
          [251, 298],
          [298, 301],
          [275, 281],
          [281, 4],
          [4, 275],
          [254, 373],
          [373, 253],
          [253, 254],
          [375, 307],
          [307, 321],
          [321, 375],
          [280, 425],
          [425, 411],
          [411, 280],
          [200, 421],
          [
            421,
            18
          ],
          [18, 200],
          [335, 321],
          [321, 406],
          [406, 335],
          [321, 320],
          [320, 405],
          [405, 321],
          [314, 315],
          [315, 17],
          [17, 314],
          [423, 426],
          [426, 266],
          [266, 423],
          [396, 377],
          [377, 369],
          [369, 396],
          [270, 322],
          [322, 269],
          [269, 270],
          [413, 417],
          [417, 464],
          [464, 413],
          [385, 386],
          [386, 258],
          [258, 385],
          [248, 456],
          [456, 419],
          [419, 248],
          [298, 284],
          [284, 333],
          [333, 298],
          [168, 417],
          [417, 8],
          [8, 168],
          [448, 346],
          [346, 261],
          [261, 448],
          [417, 413],
          [413, 285],
          [285, 417],
          [326, 327],
          [327, 328],
          [328, 326],
          [277, 355],
          [355, 329],
          [329, 277],
          [309, 392],
          [392, 438],
          [438, 309],
          [381, 382],
          [
            382,
            256
          ],
          [256, 381],
          [279, 429],
          [429, 360],
          [360, 279],
          [365, 364],
          [364, 379],
          [379, 365],
          [355, 277],
          [277, 437],
          [437, 355],
          [282, 443],
          [443, 283],
          [283, 282],
          [281, 275],
          [275, 363],
          [363, 281],
          [395, 431],
          [431, 369],
          [369, 395],
          [299, 297],
          [297, 337],
          [337, 299],
          [335, 273],
          [273, 321],
          [321, 335],
          [348, 450],
          [450, 349],
          [349, 348],
          [359, 446],
          [446, 467],
          [467, 359],
          [283, 293],
          [293, 282],
          [282, 283],
          [250, 458],
          [458, 462],
          [462, 250],
          [300, 276],
          [276, 383],
          [383, 300],
          [292, 308],
          [308, 325],
          [325, 292],
          [283, 276],
          [276, 293],
          [293, 283],
          [264, 372],
          [372, 447],
          [447, 264],
          [346, 352],
          [352, 340],
          [340, 346],
          [354, 274],
          [274, 19],
          [19, 354],
          [363, 456],
          [456, 281],
          [281, 363],
          [426, 436],
          [436, 425],
          [425, 426],
          [380, 381],
          [381, 252],
          [252, 380],
          [267, 269],
          [269, 393],
          [393, 267],
          [421, 200],
          [200, 428],
          [428, 421],
          [371, 266],
          [266, 329],
          [329, 371],
          [432, 287],
          [287, 422],
          [422, 432],
          [290, 250],
          [250, 328],
          [328, 290],
          [385, 258],
          [258, 384],
          [384, 385],
          [446, 265],
          [265, 342],
          [342, 446],
          [386, 387],
          [387, 257],
          [257, 386],
          [422, 424],
          [424, 430],
          [430, 422],
          [445, 342],
          [342, 276],
          [276, 445],
          [422, 273],
          [273, 424],
          [424, 422],
          [306, 292],
          [292, 307],
          [307, 306],
          [
            352,
            366
          ],
          [366, 345],
          [345, 352],
          [268, 271],
          [271, 302],
          [302, 268],
          [358, 423],
          [423, 371],
          [371, 358],
          [327, 294],
          [294, 460],
          [460, 327],
          [331, 279],
          [279, 294],
          [294, 331],
          [303, 271],
          [271, 304],
          [304, 303],
          [436, 432],
          [432, 427],
          [427, 436],
          [304, 272],
          [272, 408],
          [408, 304],
          [395, 394],
          [394, 431],
          [431, 395],
          [378, 395],
          [395, 400],
          [400, 378],
          [296, 334],
          [334, 299],
          [299, 296],
          [6, 351],
          [351, 168],
          [168, 6],
          [376, 352],
          [352, 411],
          [411, 376],
          [307, 325],
          [325, 320],
          [320, 307],
          [285, 295],
          [295, 336],
          [336, 285],
          [320, 319],
          [319, 404],
          [404, 320],
          [329, 330],
          [330, 349],
          [349, 329],
          [334, 293],
          [293, 333],
          [333, 334],
          [366, 323],
          [323, 447],
          [447, 366],
          [316, 15],
          [15, 315],
          [315, 316],
          [331, 358],
          [358, 279],
          [279, 331],
          [317, 14],
          [14, 316],
          [316, 317],
          [8, 285],
          [285, 9],
          [9, 8],
          [277, 329],
          [329, 350],
          [350, 277],
          [253, 374],
          [374, 252],
          [252, 253],
          [319, 318],
          [318, 403],
          [403, 319],
          [351, 6],
          [6, 419],
          [419, 351],
          [324, 318],
          [318, 325],
          [325, 324],
          [397, 367],
          [367, 365],
          [365, 397],
          [288, 435],
          [435, 397],
          [397, 288],
          [278, 344],
          [344, 439],
          [439, 278],
          [310, 272],
          [272, 311],
          [311, 310],
          [248, 195],
          [195, 281],
          [281, 248],
          [375, 273],
          [273, 291],
          [291, 375],
          [175, 396],
          [396, 199],
          [199, 175],
          [312, 311],
          [311, 268],
          [268, 312],
          [276, 283],
          [283, 445],
          [445, 276],
          [390, 373],
          [373, 339],
          [339, 390],
          [295, 282],
          [282, 296],
          [296, 295],
          [448, 449],
          [449, 346],
          [346, 448],
          [356, 264],
          [264, 454],
          [454, 356],
          [337, 336],
          [336, 299],
          [299, 337],
          [337, 338],
          [338, 151],
          [151, 337],
          [294, 278],
          [278, 455],
          [455, 294],
          [308, 292],
          [292, 415],
          [415, 308],
          [429, 358],
          [358, 355],
          [355, 429],
          [265, 340],
          [340, 372],
          [372, 265],
          [352, 346],
          [346, 280],
          [280, 352],
          [295, 442],
          [442, 282],
          [282, 295],
          [354, 19],
          [19, 370],
          [370, 354],
          [285, 441],
          [441, 295],
          [295, 285],
          [
            195,
            248
          ],
          [248, 197],
          [197, 195],
          [457, 440],
          [440, 274],
          [274, 457],
          [301, 300],
          [300, 368],
          [368, 301],
          [417, 351],
          [351, 465],
          [465, 417],
          [251, 301],
          [301, 389],
          [389, 251],
          [394, 395],
          [395, 379],
          [379, 394],
          [399, 412],
          [412, 419],
          [419, 399],
          [410, 436],
          [436, 322],
          [322, 410],
          [326, 2],
          [2, 393],
          [393, 326],
          [354, 370],
          [370, 461],
          [461, 354],
          [393, 164],
          [164, 267],
          [267, 393],
          [268, 302],
          [302, 12],
          [12, 268],
          [312, 268],
          [268, 13],
          [13, 312],
          [298, 293],
          [293, 301],
          [301, 298],
          [265, 446],
          [446, 340],
          [340, 265],
          [280, 330],
          [330, 425],
          [425, 280],
          [322, 426],
          [426, 391],
          [391, 322],
          [
            420,
            429
          ],
          [429, 437],
          [437, 420],
          [393, 391],
          [391, 326],
          [326, 393],
          [344, 440],
          [440, 438],
          [438, 344],
          [458, 459],
          [459, 461],
          [461, 458],
          [364, 434],
          [434, 394],
          [394, 364],
          [428, 396],
          [396, 262],
          [262, 428],
          [274, 354],
          [354, 457],
          [457, 274],
          [317, 316],
          [316, 402],
          [402, 317],
          [316, 315],
          [315, 403],
          [403, 316],
          [315, 314],
          [314, 404],
          [404, 315],
          [314, 313],
          [313, 405],
          [405, 314],
          [313, 421],
          [421, 406],
          [406, 313],
          [323, 366],
          [366, 361],
          [361, 323],
          [292, 306],
          [306, 407],
          [407, 292],
          [306, 291],
          [291, 408],
          [408, 306],
          [291, 287],
          [287, 409],
          [409, 291],
          [287, 432],
          [432, 410],
          [410, 287],
          [427, 434],
          [434, 411],
          [411, 427],
          [372, 264],
          [264, 383],
          [383, 372],
          [459, 309],
          [309, 457],
          [457, 459],
          [366, 352],
          [352, 401],
          [401, 366],
          [1, 274],
          [274, 4],
          [4, 1],
          [418, 421],
          [421, 262],
          [262, 418],
          [331, 294],
          [294, 358],
          [358, 331],
          [435, 433],
          [433, 367],
          [367, 435],
          [392, 289],
          [289, 439],
          [439, 392],
          [328, 462],
          [462, 326],
          [326, 328],
          [94, 2],
          [2, 370],
          [370, 94],
          [289, 305],
          [305, 455],
          [455, 289],
          [339, 254],
          [254, 448],
          [448, 339],
          [359, 255],
          [255, 446],
          [446, 359],
          [254, 253],
          [253, 449],
          [449, 254],
          [253, 252],
          [252, 450],
          [450, 253],
          [252, 256],
          [256, 451],
          [451, 252],
          [
            256,
            341
          ],
          [341, 452],
          [452, 256],
          [414, 413],
          [413, 463],
          [463, 414],
          [286, 441],
          [441, 414],
          [414, 286],
          [286, 258],
          [258, 441],
          [441, 286],
          [258, 257],
          [257, 442],
          [442, 258],
          [257, 259],
          [259, 443],
          [443, 257],
          [259, 260],
          [260, 444],
          [444, 259],
          [260, 467],
          [467, 445],
          [445, 260],
          [309, 459],
          [459, 250],
          [250, 309],
          [305, 289],
          [289, 290],
          [290, 305],
          [305, 290],
          [290, 460],
          [460, 305],
          [401, 376],
          [376, 435],
          [435, 401],
          [309, 250],
          [250, 392],
          [392, 309],
          [376, 411],
          [411, 433],
          [433, 376],
          [453, 341],
          [341, 464],
          [464, 453],
          [357, 453],
          [453, 465],
          [465, 357],
          [343, 357],
          [357, 412],
          [412, 343],
          [437, 343],
          [343, 399],
          [399, 437],
          [344, 360],
          [360, 440],
          [440, 344],
          [420, 437],
          [437, 456],
          [456, 420],
          [360, 420],
          [420, 363],
          [363, 360],
          [361, 401],
          [401, 288],
          [288, 361],
          [265, 372],
          [372, 353],
          [353, 265],
          [390, 339],
          [339, 249],
          [249, 390],
          [339, 448],
          [448, 255],
          [255, 339]
        ]);
        I("HAND_CONNECTIONS", [[0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]]);
        I("POSE_CONNECTIONS", [[0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]]);
        I("POSE_LANDMARKS", { NOSE: 0, LEFT_EYE_INNER: 1, LEFT_EYE: 2, LEFT_EYE_OUTER: 3, RIGHT_EYE_INNER: 4, RIGHT_EYE: 5, RIGHT_EYE_OUTER: 6, LEFT_EAR: 7, RIGHT_EAR: 8, LEFT_RIGHT: 9, RIGHT_LEFT: 10, LEFT_SHOULDER: 11, RIGHT_SHOULDER: 12, LEFT_ELBOW: 13, RIGHT_ELBOW: 14, LEFT_WRIST: 15, RIGHT_WRIST: 16, LEFT_PINKY: 17, RIGHT_PINKY: 18, LEFT_INDEX: 19, RIGHT_INDEX: 20, LEFT_THUMB: 21, RIGHT_THUMB: 22, LEFT_HIP: 23, RIGHT_HIP: 24, LEFT_KNEE: 25, RIGHT_KNEE: 26, LEFT_ANKLE: 27, RIGHT_ANKLE: 28, LEFT_HEEL: 29, RIGHT_HEEL: 30, LEFT_FOOT_INDEX: 31, RIGHT_FOOT_INDEX: 32 });
        I("POSE_LANDMARKS_LEFT", { LEFT_EYE_INNER: 1, LEFT_EYE: 2, LEFT_EYE_OUTER: 3, LEFT_EAR: 7, LEFT_RIGHT: 9, LEFT_SHOULDER: 11, LEFT_ELBOW: 13, LEFT_WRIST: 15, LEFT_PINKY: 17, LEFT_INDEX: 19, LEFT_THUMB: 21, LEFT_HIP: 23, LEFT_KNEE: 25, LEFT_ANKLE: 27, LEFT_HEEL: 29, LEFT_FOOT_INDEX: 31 });
        I("POSE_LANDMARKS_RIGHT", { RIGHT_EYE_INNER: 4, RIGHT_EYE: 5, RIGHT_EYE_OUTER: 6, RIGHT_EAR: 8, RIGHT_LEFT: 10, RIGHT_SHOULDER: 12, RIGHT_ELBOW: 14, RIGHT_WRIST: 16, RIGHT_PINKY: 18, RIGHT_INDEX: 20, RIGHT_THUMB: 22, RIGHT_HIP: 24, RIGHT_KNEE: 26, RIGHT_ANKLE: 28, RIGHT_HEEL: 30, RIGHT_FOOT_INDEX: 32 });
        I("POSE_LANDMARKS_NEUTRAL", { NOSE: 0 });
        I("matrixDataToMatrix", function(a) {
          for (var b = a.getCols(), c = a.getRows(), d = a.getPackedDataList(), e = [], g = 0; g < c; g++)
            e.push(Array(b));
          for (g = 0; g < c; g++)
            for (var f = 0; f < b; f++) {
              var k = a.getLayout() === 1 ? g * b + f : f * c + g;
              e[g][f] = d[k];
            }
          return e;
        });
        I("VERSION", "0.5.1635989137");
      }).call(exports);
    }
  });

  // node_modules/@mediapipe/camera_utils/camera_utils.js
  var require_camera_utils = __commonJS({
    "node_modules/@mediapipe/camera_utils/camera_utils.js"(exports) {
      (function() {
        "use strict";
        function n(a) {
          var b = 0;
          return function() {
            return b < a.length ? { done: false, value: a[b++] } : { done: true };
          };
        }
        var q2 = typeof Object.defineProperties == "function" ? Object.defineProperty : function(a, b, e) {
          if (a == Array.prototype || a == Object.prototype)
            return a;
          a[b] = e.value;
          return a;
        };
        function t(a) {
          a = [typeof globalThis == "object" && globalThis, a, typeof window == "object" && window, typeof self == "object" && self, typeof global == "object" && global];
          for (var b = 0; b < a.length; ++b) {
            var e = a[b];
            if (e && e.Math == Math)
              return e;
          }
          throw Error("Cannot find global object");
        }
        var u = t(this);
        function v(a, b) {
          if (b)
            a: {
              var e = u;
              a = a.split(".");
              for (var f = 0; f < a.length - 1; f++) {
                var h = a[f];
                if (!(h in e))
                  break a;
                e = e[h];
              }
              a = a[a.length - 1];
              f = e[a];
              b = b(f);
              b != f && b != null && q2(e, a, { configurable: true, writable: true, value: b });
            }
        }
        v("Symbol", function(a) {
          function b(l) {
            if (this instanceof b)
              throw new TypeError("Symbol is not a constructor");
            return new e(f + (l || "") + "_" + h++, l);
          }
          function e(l, c) {
            this.g = l;
            q2(this, "description", { configurable: true, writable: true, value: c });
          }
          if (a)
            return a;
          e.prototype.toString = function() {
            return this.g;
          };
          var f = "jscomp_symbol_" + (1e9 * Math.random() >>> 0) + "_", h = 0;
          return b;
        });
        v("Symbol.iterator", function(a) {
          if (a)
            return a;
          a = Symbol("Symbol.iterator");
          for (var b = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), e = 0; e < b.length; e++) {
            var f = u[b[e]];
            typeof f === "function" && typeof f.prototype[a] != "function" && q2(f.prototype, a, { configurable: true, writable: true, value: function() {
              return w(n(this));
            } });
          }
          return a;
        });
        function w(a) {
          a = { next: a };
          a[Symbol.iterator] = function() {
            return this;
          };
          return a;
        }
        function x(a) {
          var b = typeof Symbol != "undefined" && Symbol.iterator && a[Symbol.iterator];
          return b ? b.call(a) : { next: n(a) };
        }
        function y() {
          this.i = false;
          this.g = null;
          this.o = void 0;
          this.j = 1;
          this.m = 0;
          this.h = null;
        }
        function z(a) {
          if (a.i)
            throw new TypeError("Generator is already running");
          a.i = true;
        }
        y.prototype.l = function(a) {
          this.o = a;
        };
        function A(a, b) {
          a.h = { F: b, G: true };
          a.j = a.m;
        }
        y.prototype.return = function(a) {
          this.h = { return: a };
          this.j = this.m;
        };
        function B(a) {
          this.g = new y();
          this.h = a;
        }
        function C(a, b) {
          z(a.g);
          var e = a.g.g;
          if (e)
            return D(a, "return" in e ? e["return"] : function(f) {
              return { value: f, done: true };
            }, b, a.g.return);
          a.g.return(b);
          return H(a);
        }
        function D(a, b, e, f) {
          try {
            var h = b.call(a.g.g, e);
            if (!(h instanceof Object))
              throw new TypeError("Iterator result " + h + " is not an object");
            if (!h.done)
              return a.g.i = false, h;
            var l = h.value;
          } catch (c) {
            return a.g.g = null, A(a.g, c), H(a);
          }
          a.g.g = null;
          f.call(a.g, l);
          return H(a);
        }
        function H(a) {
          for (; a.g.j; )
            try {
              var b = a.h(a.g);
              if (b)
                return a.g.i = false, { value: b.value, done: false };
            } catch (e) {
              a.g.o = void 0, A(a.g, e);
            }
          a.g.i = false;
          if (a.g.h) {
            b = a.g.h;
            a.g.h = null;
            if (b.G)
              throw b.F;
            return { value: b.return, done: true };
          }
          return { value: void 0, done: true };
        }
        function I(a) {
          this.next = function(b) {
            z(a.g);
            a.g.g ? b = D(a, a.g.g.next, b, a.g.l) : (a.g.l(b), b = H(a));
            return b;
          };
          this.throw = function(b) {
            z(a.g);
            a.g.g ? b = D(a, a.g.g["throw"], b, a.g.l) : (A(a.g, b), b = H(a));
            return b;
          };
          this.return = function(b) {
            return C(a, b);
          };
          this[Symbol.iterator] = function() {
            return this;
          };
        }
        function J(a) {
          function b(f) {
            return a.next(f);
          }
          function e(f) {
            return a.throw(f);
          }
          return new Promise(function(f, h) {
            function l(c) {
              c.done ? f(c.value) : Promise.resolve(c.value).then(b, e).then(l, h);
            }
            l(a.next());
          });
        }
        v("Promise", function(a) {
          function b(c) {
            this.h = 0;
            this.i = void 0;
            this.g = [];
            this.o = false;
            var d = this.j();
            try {
              c(d.resolve, d.reject);
            } catch (g) {
              d.reject(g);
            }
          }
          function e() {
            this.g = null;
          }
          function f(c) {
            return c instanceof b ? c : new b(function(d) {
              d(c);
            });
          }
          if (a)
            return a;
          e.prototype.h = function(c) {
            if (this.g == null) {
              this.g = [];
              var d = this;
              this.i(function() {
                d.l();
              });
            }
            this.g.push(c);
          };
          var h = u.setTimeout;
          e.prototype.i = function(c) {
            h(c, 0);
          };
          e.prototype.l = function() {
            for (; this.g && this.g.length; ) {
              var c = this.g;
              this.g = [];
              for (var d = 0; d < c.length; ++d) {
                var g = c[d];
                c[d] = null;
                try {
                  g();
                } catch (k) {
                  this.j(k);
                }
              }
            }
            this.g = null;
          };
          e.prototype.j = function(c) {
            this.i(function() {
              throw c;
            });
          };
          b.prototype.j = function() {
            function c(k) {
              return function(m) {
                g || (g = true, k.call(d, m));
              };
            }
            var d = this, g = false;
            return { resolve: c(this.A), reject: c(this.l) };
          };
          b.prototype.A = function(c) {
            if (c === this)
              this.l(new TypeError("A Promise cannot resolve to itself"));
            else if (c instanceof b)
              this.C(c);
            else {
              a:
                switch (typeof c) {
                  case "object":
                    var d = c != null;
                    break a;
                  case "function":
                    d = true;
                    break a;
                  default:
                    d = false;
                }
              d ? this.v(c) : this.m(c);
            }
          };
          b.prototype.v = function(c) {
            var d = void 0;
            try {
              d = c.then;
            } catch (g) {
              this.l(g);
              return;
            }
            typeof d == "function" ? this.D(d, c) : this.m(c);
          };
          b.prototype.l = function(c) {
            this.u(2, c);
          };
          b.prototype.m = function(c) {
            this.u(1, c);
          };
          b.prototype.u = function(c, d) {
            if (this.h != 0)
              throw Error("Cannot settle(" + c + ", " + d + "): Promise already settled in state" + this.h);
            this.h = c;
            this.i = d;
            this.h === 2 && this.B();
            this.H();
          };
          b.prototype.B = function() {
            var c = this;
            h(function() {
              if (c.I()) {
                var d = u.console;
                typeof d !== "undefined" && d.error(c.i);
              }
            }, 1);
          };
          b.prototype.I = function() {
            if (this.o)
              return false;
            var c = u.CustomEvent, d = u.Event, g = u.dispatchEvent;
            if (typeof g === "undefined")
              return true;
            typeof c === "function" ? c = new c("unhandledrejection", { cancelable: true }) : typeof d === "function" ? c = new d("unhandledrejection", { cancelable: true }) : (c = u.document.createEvent("CustomEvent"), c.initCustomEvent("unhandledrejection", false, true, c));
            c.promise = this;
            c.reason = this.i;
            return g(c);
          };
          b.prototype.H = function() {
            if (this.g != null) {
              for (var c = 0; c < this.g.length; ++c)
                l.h(this.g[c]);
              this.g = null;
            }
          };
          var l = new e();
          b.prototype.C = function(c) {
            var d = this.j();
            c.s(d.resolve, d.reject);
          };
          b.prototype.D = function(c, d) {
            var g = this.j();
            try {
              c.call(d, g.resolve, g.reject);
            } catch (k) {
              g.reject(k);
            }
          };
          b.prototype.then = function(c, d) {
            function g(p2, r) {
              return typeof p2 == "function" ? function(E) {
                try {
                  k(p2(E));
                } catch (F) {
                  m(F);
                }
              } : r;
            }
            var k, m, G = new b(function(p2, r) {
              k = p2;
              m = r;
            });
            this.s(g(c, k), g(d, m));
            return G;
          };
          b.prototype.catch = function(c) {
            return this.then(void 0, c);
          };
          b.prototype.s = function(c, d) {
            function g() {
              switch (k.h) {
                case 1:
                  c(k.i);
                  break;
                case 2:
                  d(k.i);
                  break;
                default:
                  throw Error("Unexpected state: " + k.h);
              }
            }
            var k = this;
            this.g == null ? l.h(g) : this.g.push(g);
            this.o = true;
          };
          b.resolve = f;
          b.reject = function(c) {
            return new b(function(d, g) {
              g(c);
            });
          };
          b.race = function(c) {
            return new b(function(d, g) {
              for (var k = x(c), m = k.next(); !m.done; m = k.next())
                f(m.value).s(d, g);
            });
          };
          b.all = function(c) {
            var d = x(c), g = d.next();
            return g.done ? f([]) : new b(function(k, m) {
              function G(E) {
                return function(F) {
                  p2[E] = F;
                  r--;
                  r == 0 && k(p2);
                };
              }
              var p2 = [], r = 0;
              do
                p2.push(void 0), r++, f(g.value).s(G(p2.length - 1), m), g = d.next();
              while (!g.done);
            });
          };
          return b;
        });
        var K = typeof Object.assign == "function" ? Object.assign : function(a, b) {
          for (var e = 1; e < arguments.length; e++) {
            var f = arguments[e];
            if (f)
              for (var h in f)
                Object.prototype.hasOwnProperty.call(f, h) && (a[h] = f[h]);
          }
          return a;
        };
        v("Object.assign", function(a) {
          return a || K;
        });
        var L = this || self;
        var M = { facingMode: "user", width: 640, height: 480 };
        function N(a, b) {
          this.video = a;
          this.i = 0;
          this.h = Object.assign(Object.assign({}, M), b);
        }
        N.prototype.stop = function() {
          var a = this, b, e, f, h;
          return J(new I(new B(function(l) {
            if (a.g) {
              b = a.g.getTracks();
              e = x(b);
              for (f = e.next(); !f.done; f = e.next())
                h = f.value, h.stop();
              a.g = void 0;
            }
            l.j = 0;
          })));
        };
        N.prototype.start = function() {
          var a = this, b;
          return J(new I(new B(function(e) {
            navigator.mediaDevices && navigator.mediaDevices.getUserMedia || alert("No navigator.mediaDevices.getUserMedia exists.");
            b = a.h;
            return e.return(navigator.mediaDevices.getUserMedia({ video: { facingMode: b.facingMode, width: b.width, height: b.height } }).then(function(f) {
              O(a, f);
            }).catch(function(f) {
              var h = "Failed to acquire camera feed: " + f;
              console.error(h);
              alert(h);
              throw f;
            }));
          })));
        };
        function P(a) {
          window.requestAnimationFrame(function() {
            Q(a);
          });
        }
        function O(a, b) {
          a.g = b;
          a.video.srcObject = b;
          a.video.onloadedmetadata = function() {
            a.video.play();
            P(a);
          };
        }
        function Q(a) {
          var b = null;
          a.video.paused || a.video.currentTime === a.i || (a.i = a.video.currentTime, b = a.h.onFrame());
          b ? b.then(function() {
            P(a);
          }) : P(a);
        }
        var R = ["Camera"], S = L;
        R[0] in S || typeof S.execScript == "undefined" || S.execScript("var " + R[0]);
        for (var T; R.length && (T = R.shift()); )
          R.length || N === void 0 ? S[T] && S[T] !== Object.prototype[T] ? S = S[T] : S = S[T] = {} : S[T] = N;
      }).call(exports);
    }
  });

  // node_modules/is-mobile/index.js
  var require_is_mobile = __commonJS({
    "node_modules/is-mobile/index.js"(exports, module) {
      "use strict";
      module.exports = isMobile;
      module.exports.isMobile = isMobile;
      module.exports.default = isMobile;
      var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
      var notMobileRE = /CrOS/;
      var tabletRE = /android|ipad|playbook|silk/i;
      function isMobile(opts) {
        if (!opts)
          opts = {};
        let ua = opts.ua;
        if (!ua && typeof navigator !== "undefined")
          ua = navigator.userAgent;
        if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
          ua = ua.headers["user-agent"];
        }
        if (typeof ua !== "string")
          return false;
        let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
        if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
          result = true;
        }
        return result;
      }
    }
  });

  // node_modules/svelte/internal/index.mjs
  function noop() {
  }
  function assign(tar, src) {
    for (const k in src)
      tar[k] = src[k];
    return tar;
  }
  function run(fn) {
    return fn();
  }
  function blank_object() {
    return /* @__PURE__ */ Object.create(null);
  }
  function run_all(fns) {
    fns.forEach(run);
  }
  function is_function(thing) {
    return typeof thing === "function";
  }
  function safe_not_equal(a, b) {
    return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
  }
  var src_url_equal_anchor;
  function src_url_equal(element_src, url) {
    if (!src_url_equal_anchor) {
      src_url_equal_anchor = document.createElement("a");
    }
    src_url_equal_anchor.href = url;
    return element_src === src_url_equal_anchor.href;
  }
  function is_empty(obj) {
    return Object.keys(obj).length === 0;
  }
  function subscribe(store, ...callbacks) {
    if (store == null) {
      return noop;
    }
    const unsub = store.subscribe(...callbacks);
    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
  }
  function component_subscribe(component, store, callback) {
    component.$$.on_destroy.push(subscribe(store, callback));
  }
  var is_hydrating = false;
  function start_hydrating() {
    is_hydrating = true;
  }
  function end_hydrating() {
    is_hydrating = false;
  }
  function append(target, node) {
    target.appendChild(node);
  }
  function insert(target, node, anchor) {
    target.insertBefore(node, anchor || null);
  }
  function detach(node) {
    node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
    for (let i = 0; i < iterations.length; i += 1) {
      if (iterations[i])
        iterations[i].d(detaching);
    }
  }
  function element(name) {
    return document.createElement(name);
  }
  function text(data) {
    return document.createTextNode(data);
  }
  function space() {
    return text(" ");
  }
  function empty() {
    return text("");
  }
  function listen(node, event, handler, options) {
    node.addEventListener(event, handler, options);
    return () => node.removeEventListener(event, handler, options);
  }
  function attr(node, attribute, value) {
    if (value == null)
      node.removeAttribute(attribute);
    else if (node.getAttribute(attribute) !== value)
      node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes) {
    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
    for (const key in attributes) {
      if (attributes[key] == null) {
        node.removeAttribute(key);
      } else if (key === "style") {
        node.style.cssText = attributes[key];
      } else if (key === "__value") {
        node.value = node[key] = attributes[key];
      } else if (descriptors[key] && descriptors[key].set) {
        node[key] = attributes[key];
      } else {
        attr(node, key, attributes[key]);
      }
    }
  }
  function set_custom_element_data(node, prop, value) {
    if (prop in node) {
      node[prop] = typeof node[prop] === "boolean" && value === "" ? true : value;
    } else {
      attr(node, prop, value);
    }
  }
  function children(element2) {
    return Array.from(element2.childNodes);
  }
  function set_data(text2, data) {
    data = "" + data;
    if (text2.wholeText !== data)
      text2.data = data;
  }
  function set_input_value(input, value) {
    input.value = value == null ? "" : value;
  }
  function set_style(node, key, value, important) {
    if (value === null) {
      node.style.removeProperty(key);
    } else {
      node.style.setProperty(key, value, important ? "important" : "");
    }
  }
  var current_component;
  function set_current_component(component) {
    current_component = component;
  }
  var dirty_components = [];
  var binding_callbacks = [];
  var render_callbacks = [];
  var flush_callbacks = [];
  var resolved_promise = Promise.resolve();
  var update_scheduled = false;
  function schedule_update() {
    if (!update_scheduled) {
      update_scheduled = true;
      resolved_promise.then(flush);
    }
  }
  function add_render_callback(fn) {
    render_callbacks.push(fn);
  }
  var seen_callbacks = /* @__PURE__ */ new Set();
  var flushidx = 0;
  function flush() {
    const saved_component = current_component;
    do {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
      set_current_component(null);
      dirty_components.length = 0;
      flushidx = 0;
      while (binding_callbacks.length)
        binding_callbacks.pop()();
      for (let i = 0; i < render_callbacks.length; i += 1) {
        const callback = render_callbacks[i];
        if (!seen_callbacks.has(callback)) {
          seen_callbacks.add(callback);
          callback();
        }
      }
      render_callbacks.length = 0;
    } while (dirty_components.length);
    while (flush_callbacks.length) {
      flush_callbacks.pop()();
    }
    update_scheduled = false;
    seen_callbacks.clear();
    set_current_component(saved_component);
  }
  function update($$) {
    if ($$.fragment !== null) {
      $$.update();
      run_all($$.before_update);
      const dirty = $$.dirty;
      $$.dirty = [-1];
      $$.fragment && $$.fragment.p($$.ctx, dirty);
      $$.after_update.forEach(add_render_callback);
    }
  }
  var outroing = /* @__PURE__ */ new Set();
  var outros;
  function group_outros() {
    outros = {
      r: 0,
      c: [],
      p: outros
    };
  }
  function check_outros() {
    if (!outros.r) {
      run_all(outros.c);
    }
    outros = outros.p;
  }
  function transition_in(block, local) {
    if (block && block.i) {
      outroing.delete(block);
      block.i(local);
    }
  }
  function transition_out(block, local, detach2, callback) {
    if (block && block.o) {
      if (outroing.has(block))
        return;
      outroing.add(block);
      outros.c.push(() => {
        outroing.delete(block);
        if (callback) {
          if (detach2)
            block.d(1);
          callback();
        }
      });
      block.o(local);
    }
  }
  var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
  function get_spread_update(levels, updates) {
    const update3 = {};
    const to_null_out = {};
    const accounted_for = { $$scope: 1 };
    let i = levels.length;
    while (i--) {
      const o = levels[i];
      const n = updates[i];
      if (n) {
        for (const key in o) {
          if (!(key in n))
            to_null_out[key] = 1;
        }
        for (const key in n) {
          if (!accounted_for[key]) {
            update3[key] = n[key];
            accounted_for[key] = 1;
          }
        }
        levels[i] = n;
      } else {
        for (const key in o) {
          accounted_for[key] = 1;
        }
      }
    }
    for (const key in to_null_out) {
      if (!(key in update3))
        update3[key] = void 0;
    }
    return update3;
  }
  function create_component(block) {
    block && block.c();
  }
  function mount_component(component, target, anchor, customElement) {
    const { fragment, on_mount, on_destroy, after_update } = component.$$;
    fragment && fragment.m(target, anchor);
    if (!customElement) {
      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);
        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          run_all(new_on_destroy);
        }
        component.$$.on_mount = [];
      });
    }
    after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
    const $$ = component.$$;
    if ($$.fragment !== null) {
      run_all($$.on_destroy);
      $$.fragment && $$.fragment.d(detaching);
      $$.on_destroy = $$.fragment = null;
      $$.ctx = [];
    }
  }
  function make_dirty(component, i) {
    if (component.$$.dirty[0] === -1) {
      dirty_components.push(component);
      schedule_update();
      component.$$.dirty.fill(0);
    }
    component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
  }
  function init(component, options, instance18, create_fragment20, not_equal, props, append_styles, dirty = [-1]) {
    const parent_component = current_component;
    set_current_component(component);
    const $$ = component.$$ = {
      fragment: null,
      ctx: null,
      props,
      update: noop,
      not_equal,
      bound: blank_object(),
      on_mount: [],
      on_destroy: [],
      on_disconnect: [],
      before_update: [],
      after_update: [],
      context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
      callbacks: blank_object(),
      dirty,
      skip_bound: false,
      root: options.target || parent_component.$$.root
    };
    append_styles && append_styles($$.root);
    let ready = false;
    $$.ctx = instance18 ? instance18(component, options.props || {}, (i, ret, ...rest) => {
      const value = rest.length ? rest[0] : ret;
      if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
        if (!$$.skip_bound && $$.bound[i])
          $$.bound[i](value);
        if (ready)
          make_dirty(component, i);
      }
      return ret;
    }) : [];
    $$.update();
    ready = true;
    run_all($$.before_update);
    $$.fragment = create_fragment20 ? create_fragment20($$.ctx) : false;
    if (options.target) {
      if (options.hydrate) {
        start_hydrating();
        const nodes = children(options.target);
        $$.fragment && $$.fragment.l(nodes);
        nodes.forEach(detach);
      } else {
        $$.fragment && $$.fragment.c();
      }
      if (options.intro)
        transition_in(component.$$.fragment);
      mount_component(component, options.target, options.anchor, options.customElement);
      end_hydrating();
      flush();
    }
    set_current_component(parent_component);
  }
  var SvelteElement;
  if (typeof HTMLElement === "function") {
    SvelteElement = class extends HTMLElement {
      constructor() {
        super();
        this.attachShadow({ mode: "open" });
      }
      connectedCallback() {
        const { on_mount } = this.$$;
        this.$$.on_disconnect = on_mount.map(run).filter(is_function);
        for (const key in this.$$.slotted) {
          this.appendChild(this.$$.slotted[key]);
        }
      }
      attributeChangedCallback(attr2, _oldValue, newValue) {
        this[attr2] = newValue;
      }
      disconnectedCallback() {
        run_all(this.$$.on_disconnect);
      }
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }
      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1)
            callbacks.splice(index, 1);
        };
      }
      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }
    };
  }
  var SvelteComponent = class {
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };

  // src/component/scatter.ts
  var bb = new AFRAME.THREE.Box3();
  AFRAME.registerComponent("scatter", {
    schema: {
      type: "string",
      default: "-0.5 -0.5 -0.5 0.5 0.5 0.5"
    },
    update() {
      bb.setFromArray(this.data.split(" ").map(parseFloat));
      this.el.object3D.position.x += bb.min.x + Math.random() * (bb.max.x - bb.min.x);
      this.el.object3D.position.y += bb.min.y + Math.random() * (bb.max.y - bb.min.y);
      this.el.object3D.position.z += bb.min.z + Math.random() * (bb.max.z - bb.min.z);
    }
  });

  // src/component/activate.ts
  AFRAME.registerComponent("activate", {
    multiple: true,
    update() {
      const pool = this.el.components[`pool__${this.id}`];
      if (!pool)
        return;
      let ent;
      for (let i = 0; i < pool.data.size; i++) {
        ent = pool.requestEntity();
        ent.play();
      }
    }
  });

  // src/component/ring.ts
  AFRAME.registerComponent("ring", {
    schema: {
      count: { type: "number", default: 10 },
      radius: { type: "number", default: 5 }
    },
    update() {
      const d = this.el.object3D.parent.userData;
      const i = (d.ringDex === void 0 ? d.ringDex = 1 : d.ringDex++) % this.data.count / this.data.count * Math.PI * 2;
      this.el.object3D.position.set(Math.sin(i), 0, Math.cos(i)).multiplyScalar(this.data.radius);
    }
  });

  // src/component/webcam-vrm.ts
  var import_holistic = __toESM(require_holistic());
  var import_camera_utils = __toESM(require_camera_utils());

  // src/state.ts
  var state_default = {
    "binds": {
      "n": "control selfie",
      "m": "control not selfie",
      "h": "hi! | hey ! | hey you! | hello...",
      "i": "it's doer 1 | it's me, doer 1 | doer 1 that's me",
      "f1": "control help",
      "f2": "control not help",
      "1": "welcome to a.goblin.life",
      "2": "these are keybinds",
      "3": "press ~ or enter then type ~ bind 3 to change this bind",
      "4": "press f1 to explore other commands",
      "5": "good luck, have fun"
    },
    "vars": {},
    "selfie": false,
    avatar: {
      doer: "./vrm/doer.2.vrm",
      current: "./vrm/doer.2.vrm"
    },
    binds_icon: {
      1: "\u{1F525}",
      2: "\u{1F3F4}\u200D\u2620\uFE0F",
      3: "\u{1F495}",
      4: "\u{1F3DC}\uFE0F",
      5: "\u{1F32A}\uFE0F"
    },
    visible: true
  };

  // src/value.ts
  var Value = class {
    constructor(value = void 0) {
      this.$ = value;
    }
    set(value) {
      this.$ = value;
      this.poke();
      return this;
    }
    on(subscribe2) {
      if (this.reactions === void 0) {
        this.reactions = /* @__PURE__ */ new Set();
      }
      this.reactions.add(subscribe2);
      subscribe2(this.$);
      return () => this.reactions.delete(subscribe2);
    }
    subscribe(subscribe2) {
      return this.on(subscribe2);
    }
    log(msg) {
      this.on(() => console.log(msg, this.$));
      return this;
    }
    poke() {
      if (this.reactions === void 0)
        return;
      for (let callback of this.reactions) {
        callback(this.$);
      }
      return this;
    }
    do(fn) {
      fn();
      return this;
    }
    re(fn) {
      this.on(fn);
      return this;
    }
    me() {
      return new Value(this.$);
    }
    fa(v, transform, filter) {
      v.on((state2) => {
        if (filter) {
          if (!filter(state2))
            return;
        }
        if (transform) {
          this.set(transform(state2));
        } else {
          this.set(state2);
        }
      });
      return this;
    }
    la(timing, fn) {
      let i = 0;
      setInterval(() => {
        fn(i++);
      }, timing);
      return this;
    }
    save(where) {
      try {
        const v = JSON.parse(localStorage.getItem(where));
        if (v !== void 0 && v !== null) {
          this.set(v);
        }
      } catch (ex) {
      }
      this.on((v) => {
        localStorage.setItem(where, JSON.stringify(v));
      });
      return this;
    }
  };

  // src/timing.ts
  var import_is_mobile = __toESM(require_is_mobile());
  var tick = new Value(0);
  var avatar_current = new Value(state_default.avatar.current).save("avatar_current_2");
  var avatar_doer = new Value(state_default.avatar.doer).save("avatar_doer_1");
  var voice_current = new Value("UK English").save("voice_current");
  var voice_doer = new Value("Aus | UK English").save("voice_doer");
  var scouter = new Value("green").save("scouter");
  var videos = new Value(["pxCwIWL4_wA", "ntV3RbQmLAU", "BzIeSMDe85U"]);
  var video = new Value("doer1.8").save("video_2");
  var open_ui = new Value(true).save("ui");
  var open_home = new Value(true);
  var open_game = new Value(false);
  var open_text = new Value(void 0);
  var open_loading = new Value(false);
  var open_help = new Value(false);
  var open_stats = new Value(false).save("stats");
  var open_debug = new Value(false).save("debugger");
  var open_targeting = new Value(false).save("targeting_3");
  var open_live = new Value(false);
  var open_hostid = new Value(true);
  var loc = location.search.slice(1).split("&").map((i) => i.split("="));
  var args = new Value(new Map(loc));
  var camera = new Value();
  var camera_el = new Value();
  var toggle_selfie = new Value(state_default.selfie).save("selfie");
  var toggle_visible = new Value(state_default.visible).save("visible");
  var do_echo = new Value(true).save("do_echo");
  var do_vary = new Value(true);
  var ismobile = new Value((0, import_is_mobile.default)());
  var time = new Value(new AFRAME.THREE.Uniform(0));
  var size = new Value(new AFRAME.THREE.Vector3(1, 1, 1));
  open_game.on(($g) => {
    if (open_game.$) {
      open_loading.set(true);
    }
  });
  var motd = new Value(`\u{1F38A}v0.3.3\u{1F38A}

\u2705 Sky \u2705 Mobile \u2705 HUD
\u2705 Cabin \u2705 Animals
\u274C Online MP 
\u274C Recording Mode
\u274C Targeting
\u274C AI  \u274C Gameplay 

Camera data is processed by mediapipe via tensorflow locally.

Microphone data is handled by the browser provider, ie: Chrome / Edge / etc.

Cookies are not used to track your personal data by us. localStorage is used for persistance. 
There are iframes to 3rd parties that may attempt to track you, like youtube. 
Users can load assets remotely using HTTP to other websites. We're not responsible for their content, contact the host directly.
If that's a problem then reject this terms of use by closing your browser or navigating away from this website.

Accountless. 

Age 18+ only.

`);
  var ticker = () => {
    requestAnimationFrame(ticker);
    tick.set(tick.$ + 1);
  };
  var loading = new Value(`Loading...

 WASD Move > Q+E Rotate
 Enter > Chat
     ~ > Command
 Space > Jump
 
 Default Binds:

 N: Selfie
 M: NotSelfie
 H: Hi | Hi! | Hello | Heya | Yo
 F1: Help
 F2: NotHelp
`);
  ticker();
  var helptext = new Value(`\u{1F916}Commands\u{1F916}

~ echo 
echo on, persisted

~ not echo 
echo off, persisted

~ avatar ...url 
set avatar to URL, persisted

~ clear avatar 
set avatar to default

~ bind key ...commands 
bind key to commands, persisted

~ not bind key
unbinds key, persisted

~ var name ...commands 
binds variable name to commands

~ not var name 
unbinds variable name

~ stats 
show fps stats

~ not stats
hide fps stats


~ help
show this help

~ not help
hide this help

~ voice ...nameToSearch
set voice to nameToSearch ie: aus would find an Australian voice or UK for British, persisted
per browser

~ swap
swap places with your doer

~ visible
show your avatar

~ not visible
hide your avatar

~ selfie
selfie camera mode

~ not selfie
not selfie camera mode

~ target
show targeting UI, persists

~ not target
hide targeting UI, persists

~ scouter ...color
set your targeting UI to be that color, persists

~ not scouter
reset scout color to green, persists

~ ui
show onscreen UI

~ not ui
hide onscreen UI

~ icon bindkey ...icon
show icon on onscreen ui for that bindkey (1-5)

~ not icon bindkey
remove icon from onscreen ui for that bindkey (1-5)

~ size number
set size of your avatar

~ not size
reset back to 1 for size

~ join ...room
~ host

`);

  // src/component/vrm.ts
  var { VRMUtils, VRM } = THREE_VRM;
  var currentVRM = new Value();
  var mirrorVRM = new Value();
  currentVRM.on(($vrm) => {
    if (!$vrm || !open_loading.$)
      return;
    currentVRM.$.scene.visible = toggle_visible.$;
    open_loading.set(false);
  });
  toggle_visible.on(() => {
    if (!currentVRM.$)
      return;
    currentVRM.$.scene.visible = toggle_visible.$;
  });
  function Load(url) {
    return new Promise((resolve, reject) => {
      const loader = new AFRAME.THREE.GLTFLoader();
      loader.crossOrigin = "anonymous";
      loader.load(url, (gltf) => {
        VRM.from(gltf).then((vrm) => {
          resolve(vrm);
        });
      }, (progress) => {
      }, reject);
    });
  }
  AFRAME.registerComponent("vrm", {
    schema: {
      src: { type: "string", default: "" },
      fps: { type: "bool", default: false },
      current: { type: "bool", default: false },
      mirror: { type: "bool", default: false }
    },
    load() {
      Load(this.data.src).then((vrm) => {
        VRMUtils.removeUnnecessaryVertices(vrm.scene);
        VRMUtils.removeUnnecessaryJoints(vrm.scene);
        this.el.setObject3D("mesh", vrm.scene);
        this.data.vrm = vrm;
        if (this.data.current) {
          vrm.firstPerson.setup();
          camera.$.layers.enable(vrm.firstPerson.firstPersonOnlyLayer);
          camera.$.layers.disable(vrm.firstPerson.thirdPersonOnlyLayer);
          currentVRM.set(vrm);
        }
        if (this.data.mirror) {
          mirrorVRM.set(vrm);
        }
      });
    },
    init() {
      this.cancel();
      this.load();
      if (this.data.src !== "") {
        if (this.data.current) {
          this.cancels.push(avatar_current.on(($av) => {
            if ($av !== this.data.src) {
              this.el.removeObject3D("mesh");
              currentVRM.$?.dispose();
              this.data.src = $av;
              open_loading.set(true);
              this.load();
            }
          }));
        }
        if (this.data.doer) {
          this.cancels.push(avatar_doer.on(($av) => {
            if ($av !== this.data.src) {
              this.el.removeObject3D("mesh");
              mirrorVRM.$?.dispose();
              this.data.src = $av;
              open_loading.set(true);
              this.load();
            }
          }));
        }
      }
    },
    cancel() {
      if (!this.cancels) {
        this.cancels = [];
        return;
      }
      this.cancels.forEach((c) => c());
      this.cancels = [];
    },
    remove() {
      this.cancel();
      this.el.removeObject3D("mesh");
    }
  });

  // src/component/net.ts
  var host = new Value(args.$.has("host"));
  var guest = new Value(args.$.has("join"));
  var room = new Value(args.$.get("join"));
  var passcode = new Value("").save("passcode");
  var scene;
  var paths = {};
  var state = {};
  var update2 = {};
  var interop = 0;
  AFRAME.registerSystem("net", {
    init() {
      scene = this.el.object3D;
      this.tick = AFRAME.utils.throttleTick(this.tick, 200, this);
      guest.on(() => {
        if (!guest.$)
          return;
        this.connect();
        console.log(scene.components);
      });
      host.on(() => {
        if (!host.$)
          return;
        this.connect();
      });
    },
    process() {
      for (let entry of Object.entries(update2)) {
        const [path, value] = entry;
        if (state[path]) {
          Object.assign(state[path], value);
        } else {
          state[path] = value;
        }
      }
    },
    tick() {
      if (!host.$)
        return;
      this.process();
      if (!this.ready) {
        update2 = {};
        return;
      }
      this.ws.send("UPD" /* UPDATE */ + this.password + JSON.stringify(update2));
      update2 = {};
    },
    fullUpdate() {
      this.ws.send("UPD" /* UPDATE */ + this.password + JSON.stringify(state));
    },
    connect() {
      if (this.ws)
        return;
      console.log("connecting");
      const lhost = window.location.host === "a.goblin.life" ? "ws.goblin.life" : window.location.host;
      const ws = new WebSocket(`${window.location.protocol === "https" ? "wss" : "ws"}://${lhost}/`);
      this.ws = ws;
      ws.addEventListener("close", () => {
        console.log("closed");
        this.ws = void 0;
        setTimeout(() => {
          this.connect();
        }, 1e4);
      });
      ws.addEventListener("open", () => {
        console.log("connected");
        if (host.$) {
          console.log("send host");
          this.ws.send("HST" /* HOST */ + room.$);
        }
        if (guest.$) {
          this.ws.send("JON" /* JOIN */ + room.$);
          this.ready = true;
        }
      });
      ws.addEventListener("message", (e) => {
        switch ("" + e.data.slice(0, 3)) {
          default:
            console.log(e.data.slice(0, 3));
            break;
          case "ERR" /* ERROR */:
            console.log("ERROR", e.data.slice(3));
            break;
          case "UPD" /* UPDATE */:
            if (host.$)
              return;
            interop = 0;
            const update3 = JSON.parse(e.data.slice(3));
            for (let entry of Object.entries(update3)) {
              const [path, value] = entry;
              if (!paths[path])
                continue;
              if (!state[path]) {
                state[path] = value;
              } else {
                Object.assign(state[path], value);
              }
              paths[path].components.host.netUpdate(value);
            }
            break;
          case "HST" /* HOST */:
            console.log("got host");
            this.password = "" + e.data.slice(3, 39);
            passcode.set(this.password);
            room.set("" + e.data.slice(39));
            this.ready = true;
            this.fullUpdate();
            break;
        }
      });
    }
  });
  function Mixins(el) {
    return el.mixinEls.map((el2) => el2.id).join(".");
  }
  function MakePath(el) {
    if (el.tagName === "A-SCENE") {
      return "";
    } else {
      const target = el.parentNode;
      const p2 = MakePath(target);
      const host2 = el.components.host?.data !== void 0 && typeof el.components.host.data === "string" ? el.components.host.data : false;
      return (p2 !== "" ? p2 + "/" : "") + (host2 || el.id || Mixins(el)) || "";
    }
  }
  var p = new AFRAME.THREE.Vector3();
  var s = new AFRAME.THREE.Vector3();
  var q = new AFRAME.THREE.Quaternion();
  AFRAME.registerComponent("host", {
    schema: {
      type: "string"
    },
    init() {
      this.slowtick = AFRAME.utils.throttleTick(this.slowtick, 200, this);
      this.netpath = MakePath(this.el);
      let i = 2;
      const og = this.netpath;
      while (paths[this.netpath]) {
        this.netpath = og + i;
        i++;
      }
      paths[this.netpath] = this.el;
      this.cancel = host.on(($h) => {
        if (!$h)
          return;
        this.markUpdate();
        state[this.netpath] = update2[this.netpath];
      });
    },
    markUpdate() {
      const u = update2[this.netpath] = update2[this.netpath] || {};
      const o3d = this.el.object3D;
      u.p = o3d.position.toArray(u.p);
      u.q = o3d.quaternion.toArray(u.q);
      u.s = o3d.scale.toArray(u.s);
      u.v = o3d.visible ? 1 : 0;
    },
    slowtick() {
      let type = this.el.components["ammo-body"]?.data.type;
      if (guest.$ && (type === "kinematic" || type === "dynamic")) {
        type = this.el.components["ammo-body"].data.type = "static";
      }
      if (!host.$ || type === "static")
        return;
      this.markUpdate();
    },
    tick(_, dt) {
      this.slowtick();
      interop += dt / 1e3;
      if (guest.$ && state[this.netpath] && this.lastUpdate > interop) {
        const i = Math.min(1, interop / 350);
        const o3d = this.el.object3D;
        q.fromArray(state[this.netpath].q);
        if (Math.abs(o3d.quaternion.angleTo(q)) > 1e-3)
          o3d.quaternion.slerp(q, i);
        p.fromArray(state[this.netpath].p);
        if (o3d.position.distanceTo(p) > 1e-3)
          o3d.position.lerp(p, i);
        s.fromArray(state[this.netpath].s);
        if (o3d.scale.distanceTo(s) > 1e-3)
          o3d.scale.lerp(s, i);
      }
    },
    netUpdate(update3) {
      this.lastUpdate = interop + 250;
      const o3d = this.el.object3D;
      if (update3.v !== void 0) {
        o3d.visible = update3.v;
      }
    },
    remove() {
      delete paths[this.netpath];
      this.cancel();
    }
  });
  AFRAME.registerComponent("net-avatar", {
    init() {
    }
  });

  // src/control.ts
  var binds = new Value(clone(state_default.binds)).save("binds");
  var vars = new Value(clone(state_default.vars)).save("vars");
  var binds_icon = new Value(clone(state_default.binds_icon)).save("binds_icon");
  function clone(target) {
    return Object.fromEntries(Object.entries(target));
  }
  function saveState() {
    console.log(JSON.stringify({
      binds: binds.$,
      vars: vars.$,
      selfie: toggle_selfie.$
    }, null, "	"));
  }
  function loadState(state2) {
    binds.set(state2.binds);
    vars.set(state2.vars);
    toggle_selfie.set(state2.selfie);
  }
  window.loadState = loadState;
  var controls = {
    ["bind" /* Bind */]: (items) => {
      binds.$[items[2]] = items.slice(3).join(" ");
      binds.poke();
    },
    ["notbind" /* NotBind */]: (items) => {
      delete binds.$[items[3]];
      binds.poke();
    },
    ["clearbind" /* ClearBind */]: (items) => {
      binds.set(clone(state_default.binds));
    },
    ["var" /* Var */]: (items) => {
      vars.$[items[2]] = items.slice(3).join(" ");
      vars.poke();
    },
    ["notvar" /* NotVar */]: (items) => {
      delete vars.$[items[3]];
      vars.poke();
    },
    ["clearvar" /* ClearVar */]: (items) => {
      vars.set(clone(state_default.vars));
    },
    ["selfie" /* Selfie */]: (items) => {
      toggle_selfie.set(true);
    },
    ["notselfie" /* NotSelfie */]: (items) => {
      toggle_selfie.set(false);
    },
    ["save" /* Save */]: () => {
      saveState();
    },
    ["swap" /* Swap */]: (items) => {
      const cur = avatar_current.$;
      avatar_current.set(avatar_doer.$);
      avatar_doer.set(cur);
    },
    ["visible" /* Visible */]: (items) => {
      toggle_visible.set(true);
    },
    ["notvisible" /* NotVisible */]: (items) => {
      toggle_visible.set(false);
    },
    ["avatar" /* Avatar */]: (items) => {
      avatar_current.set(items[2]);
    },
    ["clearavatar" /* ClearAvatar */]: (items) => {
      avatar_current.set(state_default.avatar.current);
    },
    ["echo" /* Echo */]: (items) => {
      do_echo.set(true);
    },
    ["notecho" /* NotEcho */]: (items) => {
      do_echo.set(false);
    },
    ["help" /* Help */]: (items) => {
      open_help.set(true);
    },
    ["nothelp" /* NotHelp */]: (items) => {
      open_help.set(false);
    },
    ["stats" /* Stats */]: (items) => {
      open_stats.set(true);
    },
    ["notstats" /* NotStats */]: (items) => {
      open_stats.set(false);
    },
    ["voice" /* Voice */]: (items) => {
      voice_current.set(items.slice(2).join(" "));
    },
    ["host" /* Host */]: (items) => {
      host.set(true);
    },
    ["nothost" /* NotHost */]: (items) => {
      host.set(false);
    },
    ["target" /* Target */]: (items) => {
      open_targeting.set(true);
    },
    ["nottarget" /* NotTarget */]: (items) => {
      open_targeting.set(false);
    },
    ["debug" /* Debug */]: (items) => {
      open_debug.set(true);
    },
    ["notdebug" /* NotDebug */]: (items) => {
      open_debug.set(false);
    },
    ["vary" /* Vary */]: (items) => {
      do_vary.poke();
    },
    ["scouter" /* Scouter */]: (items) => {
      scouter.set(items.join(" "));
    },
    ["notscouter" /* NotScouter */]: (items) => {
      scouter.set("green");
    },
    ["size" /* Size */]: (items) => {
      const n = parseFloat(items[2]);
      size.$.set(n, n, n);
      size.poke();
    },
    ["notsize" /* NotSize */]: (items) => {
      size.$.set(1, 1, 1);
      size.poke();
    },
    ["pos" /* Pos */]: (items) => {
    },
    ["notpos" /* NotPos */]: (items) => {
    },
    ["room" /* Room */]: (items) => {
      open_hostid.set(true);
    },
    ["notroom" /* NotRoom */]: (items) => {
      open_hostid.set(false);
    },
    ["join" /* Join */]: (items) => {
      if (host.$)
        host.set(false);
      guest.set(true);
      room.set(items.slice(2).join(" "));
    },
    ["notjoin" /* NotJoin */]: (items) => {
      guest.set(false);
      room.set("");
    },
    ["ui" /* UI */]: (items) => {
      open_ui.set(true);
    },
    ["notui" /* NotUI */]: (items) => {
      open_ui.set(false);
    },
    ["icon" /* Icon */]: (items) => {
      binds_icon.$[items[2]] = items.slice(3).join(" ");
    },
    ["noticon" /* NotIcon */]: (items) => {
      delete binds_icon.$[items[2]];
    }
  };

  // src/input.ts
  var key_down = new Value("");
  var key_up = new Value("");
  var key_map = new Value({});
  function bounce(e) {
    return e.target.tagName === "INPUT";
  }
  window.addEventListener("keydown", (e) => {
    if (bounce(e))
      return;
    e.preventDefault();
    const k = e.key.toLowerCase();
    key_down.set(k);
  });
  key_down.on(($k) => {
    key_map.$[$k] = true;
    key_map.poke();
  });
  window.addEventListener("keyup", (e) => {
    if (bounce(e))
      return;
    const k = e.key.toLowerCase();
    key_up.set(k);
  });
  key_up.on(($k) => {
    key_map.$[$k] = false;
    key_map.poke();
  });
  var analog_left_y = new Value(0);
  var analog_left_x = new Value(0);
  var analog_right_y = new Value(0);
  var analog_right_x = new Value(0);

  // src/chat.ts
  var recog = new Value();
  var recognition;
  var synth = window.speechSynthesis;
  function init2() {
    recognition = new webkitSpeechRecognition();
    recognition.continuous = false;
    recognition.lang = "en-US";
    recognition.interimResults = false;
    recognition.maxAlternatives = 1;
    recognition.onresult = (event) => {
      recog.set(event);
    };
    recognition.onend = () => {
      if (open_live.$)
        recognition.start();
    };
  }
  function findVoice(voiceName) {
    const voices = synth.getVoices();
    return voices.find((voice) => voice.name.toLowerCase().indexOf(voiceName.toLowerCase()) !== -1);
  }
  var talk = new Value("");
  var assist = new Value("");
  var findTilde = /~/g;
  function say(said) {
    if (!said)
      return;
    said = said.replace(findTilde, "control");
    if (doControl(said) && !do_echo.$)
      return;
    const spli = said.split("|");
    said = spli[Math.floor(Math.random() * spli.length)];
    const voices = synth.getVoices();
    var utterThis = new SpeechSynthesisUtterance(said);
    utterThis.voice = findVoice(voice_current.$) || findVoice("Aus") || findVoice("UK English Female") || voices[0];
    utterThis.pitch = 1;
    utterThis.rate = 0.8;
    utterThis.volume = 1;
    synth.speak(utterThis);
  }
  function doControl(said) {
    const items = said.toLowerCase().trim().split(" ");
    if (items[0] !== "control")
      return false;
    switch (items[1]) {
      case "not":
      case "clear":
        items[1] += items[2];
    }
    if (controls[items[1]]) {
      controls[items[1]](items);
    } else if (vars.$[items[1]]) {
      talk.set(vars.$[items[1]]);
    } else {
      return false;
    }
    return true;
  }
  talk.on(say);
  recog.on((event) => {
    if (!event)
      return;
    var said = event.results[event.results.length - 1][0].transcript.trim();
    talk.set(said);
  });
  var start = () => {
    if (!recognition)
      init2();
    recognition.start();
  };
  function end() {
    recognition?.stop();
  }
  var cancels = [];
  open_live.on(($l) => {
    if ($l) {
      start();
    } else {
      end();
    }
  });
  binds.on(($binds) => {
    cancels.forEach((cancel) => cancel());
    cancels = [];
    Object.entries($binds).forEach(([key, value]) => {
      const cancel = key_down.on(($k) => {
        if ($k !== key)
          return;
        talk.set(value);
      });
      cancels.push(cancel);
    });
  });

  // src/component/webcam-vrm.ts
  var { VRMSchema } = THREE_VRM;
  var clamp = Kalidokit.Utils.clamp;
  var lerp = Kalidokit.Vector.lerp;
  var euler = new AFRAME.THREE.Euler();
  var quat = new AFRAME.THREE.Quaternion();
  var rigRotation = (vrm, name, rotation = { x: 0, y: 0, z: 0 }, dampener = 1, lerpAmount = 0.3) => {
    const Part = vrm.humanoid.getBoneNode(VRMSchema.HumanoidBoneName[name]);
    if (!Part) {
      return;
    }
    euler.set(rotation.x * dampener, rotation.y * dampener, rotation.z * dampener);
    let quaternion = quat.setFromEuler(euler);
    Part.quaternion.slerp(quaternion, lerpAmount);
  };
  var v3 = new AFRAME.THREE.Vector3();
  var rigPosition = (vrm, name, position = { x: 0, y: 0, z: 0 }, dampener = 1, lerpAmount = 0.3) => {
    const Part = vrm.humanoid.getBoneNode(VRMSchema.HumanoidBoneName[name]);
    if (!Part) {
      return;
    }
    let vector = v3.set(position.x * dampener, position.y * dampener, position.z * dampener);
    Part.position.lerp(vector, lerpAmount);
  };
  var oldLookTarget = new AFRAME.THREE.Euler();
  var rigFace = (vrm, riggedFace) => {
    rigRotation(vrm, "Neck", riggedFace.head, 0.7);
    const Blendshape = vrm.blendShapeProxy;
    const PresetName = VRMSchema.BlendShapePresetName;
    riggedFace.eye.l = lerp(clamp(1 - riggedFace.eye.l, 0, 1), Blendshape.getValue(PresetName.Blink), 0.5);
    riggedFace.eye.r = lerp(clamp(1 - riggedFace.eye.r, 0, 1), Blendshape.getValue(PresetName.Blink), 0.5);
    riggedFace.eye = Kalidokit.Face.stabilizeBlink(riggedFace.eye, riggedFace.head.y);
    Blendshape.setValue(PresetName.Blink, riggedFace.eye.l);
    Blendshape.setValue(PresetName.I, lerp(riggedFace.mouth.shape.I, Blendshape.getValue(PresetName.I), 0.5));
    Blendshape.setValue(PresetName.A, lerp(riggedFace.mouth.shape.A, Blendshape.getValue(PresetName.A), 0.5));
    Blendshape.setValue(PresetName.E, lerp(riggedFace.mouth.shape.E, Blendshape.getValue(PresetName.E), 0.5));
    Blendshape.setValue(PresetName.O, lerp(riggedFace.mouth.shape.O, Blendshape.getValue(PresetName.O), 0.5));
    Blendshape.setValue(PresetName.U, lerp(riggedFace.mouth.shape.U, Blendshape.getValue(PresetName.U), 0.5));
    let lookTarget = euler.set(lerp(oldLookTarget.x, riggedFace.pupil.y, 0.4), lerp(oldLookTarget.y, riggedFace.pupil.x, 0.4), 0, "XYZ");
    oldLookTarget.copy(lookTarget);
    vrm.lookAt.applyer.lookAt(lookTarget);
  };
  var animateVRM = (vrm, results, riggedPose, riggedLeftHand, riggedRightHand) => {
    if (!vrm || !videoElement.$) {
      return;
    }
    let riggedFace;
    const faceLandmarks = results.faceLandmarks;
    const pose3DLandmarks = results.ea;
    const pose2DLandmarks = results.poseLandmarks;
    const leftHandLandmarks = results.rightHandLandmarks;
    const rightHandLandmarks = results.leftHandLandmarks;
    if (faceLandmarks) {
      riggedFace = Kalidokit.Face.solve(faceLandmarks, {
        runtime: "mediapipe",
        video: videoElement.$
      });
      rigFace(vrm, riggedFace);
    }
    if (pose2DLandmarks && pose3DLandmarks) {
      rigRotation(vrm, "Hips", riggedPose.Hips.rotation, 0.7);
      rigPosition(vrm, "Hips", {
        x: -riggedPose.Hips.position.x,
        y: riggedPose.Hips.position.y + 1,
        z: -riggedPose.Hips.position.z
      }, 1, 0.07);
      rigRotation(vrm, "Chest", riggedPose.Spine, 0.25, 0.3);
      rigRotation(vrm, "Spine", riggedPose.Spine, 0.45, 0.3);
      rigRotation(vrm, "RightUpperArm", riggedPose.RightUpperArm, 1, 0.3);
      rigRotation(vrm, "RightLowerArm", riggedPose.RightLowerArm, 1, 0.3);
      rigRotation(vrm, "LeftUpperArm", riggedPose.LeftUpperArm, 1, 0.3);
      rigRotation(vrm, "LeftLowerArm", riggedPose.LeftLowerArm, 1, 0.3);
      rigRotation(vrm, "LeftUpperLeg", riggedPose.LeftUpperLeg, 1, 0.3);
      rigRotation(vrm, "LeftLowerLeg", riggedPose.LeftLowerLeg, 1, 0.3);
      rigRotation(vrm, "RightUpperLeg", riggedPose.RightUpperLeg, 1, 0.3);
      rigRotation(vrm, "RightLowerLeg", riggedPose.RightLowerLeg, 1, 0.3);
    }
    if (leftHandLandmarks) {
      rigRotation(vrm, "LeftHand", {
        z: riggedPose.LeftHand.z,
        y: riggedLeftHand.LeftWrist.y,
        x: riggedLeftHand.LeftWrist.x
      });
      rigRotation(vrm, "LeftRingProximal", riggedLeftHand.LeftRingProximal);
      rigRotation(vrm, "LeftRingIntermediate", riggedLeftHand.LeftRingIntermediate);
      rigRotation(vrm, "LeftRingDistal", riggedLeftHand.LeftRingDistal);
      rigRotation(vrm, "LeftIndexProximal", riggedLeftHand.LeftIndexProximal);
      rigRotation(vrm, "LeftIndexIntermediate", riggedLeftHand.LeftIndexIntermediate);
      rigRotation(vrm, "LeftIndexDistal", riggedLeftHand.LeftIndexDistal);
      rigRotation(vrm, "LeftMiddleProximal", riggedLeftHand.LeftMiddleProximal);
      rigRotation(vrm, "LeftMiddleIntermediate", riggedLeftHand.LeftMiddleIntermediate);
      rigRotation(vrm, "LeftMiddleDistal", riggedLeftHand.LeftMiddleDistal);
      rigRotation(vrm, "LeftThumbProximal", riggedLeftHand.LeftThumbProximal);
      rigRotation(vrm, "LeftThumbIntermediate", riggedLeftHand.LeftThumbIntermediate);
      rigRotation(vrm, "LeftThumbDistal", riggedLeftHand.LeftThumbDistal);
      rigRotation(vrm, "LeftLittleProximal", riggedLeftHand.LeftLittleProximal);
      rigRotation(vrm, "LeftLittleIntermediate", riggedLeftHand.LeftLittleIntermediate);
      rigRotation(vrm, "LeftLittleDistal", riggedLeftHand.LeftLittleDistal);
    }
    if (rightHandLandmarks) {
      rigRotation(vrm, "RightHand", {
        z: riggedPose.RightHand.z,
        y: riggedRightHand.RightWrist.y,
        x: riggedRightHand.RightWrist.x
      });
      rigRotation(vrm, "RightRingProximal", riggedRightHand.RightRingProximal);
      rigRotation(vrm, "RightRingIntermediate", riggedRightHand.RightRingIntermediate);
      rigRotation(vrm, "RightRingDistal", riggedRightHand.RightRingDistal);
      rigRotation(vrm, "RightIndexProximal", riggedRightHand.RightIndexProximal);
      rigRotation(vrm, "RightIndexIntermediate", riggedRightHand.RightIndexIntermediate);
      rigRotation(vrm, "RightIndexDistal", riggedRightHand.RightIndexDistal);
      rigRotation(vrm, "RightMiddleProximal", riggedRightHand.RightMiddleProximal);
      rigRotation(vrm, "RightMiddleIntermediate", riggedRightHand.RightMiddleIntermediate);
      rigRotation(vrm, "RightMiddleDistal", riggedRightHand.RightMiddleDistal);
      rigRotation(vrm, "RightThumbProximal", riggedRightHand.RightThumbProximal);
      rigRotation(vrm, "RightThumbIntermediate", riggedRightHand.RightThumbIntermediate);
      rigRotation(vrm, "RightThumbDistal", riggedRightHand.RightThumbDistal);
      rigRotation(vrm, "RightLittleProximal", riggedRightHand.RightLittleProximal);
      rigRotation(vrm, "RightLittleIntermediate", riggedRightHand.RightLittleIntermediate);
      rigRotation(vrm, "RightLittleDistal", riggedRightHand.RightLittleDistal);
    }
  };
  var bones = Object.keys(VRMSchema.HumanoidBoneName);
  var videoElement = new Value();
  var canvasElement = new Value();
  var onResults = (results) => {
    if (!open_live.$)
      return;
    const faceLandmarks = results.faceLandmarks;
    const pose3DLandmarks = results.ea;
    const pose2DLandmarks = results.poseLandmarks;
    const leftHandLandmarks = results.rightHandLandmarks;
    const rightHandLandmarks = results.leftHandLandmarks;
    let riggedFace, riggedPose, riggedLeftHand, riggedRightHand;
    if (pose2DLandmarks && pose3DLandmarks) {
      riggedPose = Kalidokit.Pose.solve(pose3DLandmarks, pose2DLandmarks, {
        runtime: "mediapipe",
        video: videoElement.$
      });
    }
    if (leftHandLandmarks) {
      riggedLeftHand = Kalidokit.Hand.solve(leftHandLandmarks, "Left");
    }
    if (rightHandLandmarks) {
      riggedRightHand = Kalidokit.Hand.solve(rightHandLandmarks, "Right");
    }
    animateVRM(currentVRM.$, results, riggedPose, riggedLeftHand, riggedRightHand);
    animateVRM(mirrorVRM.$, results, riggedPose, riggedLeftHand, riggedRightHand);
  };
  var holistic = new import_holistic.Holistic({
    locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/holistic@0.5.1635989137/${file}`;
    }
  });
  holistic.setOptions({
    modelComplexity: 0.5,
    smoothLandmarks: true,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7,
    refineFaceLandmarks: true
  });
  holistic.onResults(onResults);
  var width = 320;
  var height = 240;
  videoElement.on(($ve) => {
    if (!$ve)
      return;
    canvasElement.$.width = width;
    canvasElement.$.height = height;
    const ctx = canvasElement.$.getContext("2d");
    ctx.translate(width, 0);
    ctx.scale(-1, 1);
    let camera2;
    open_live.on(($l) => {
      if (!camera2 && $l) {
        camera2 = new import_camera_utils.Camera($ve, {
          onFrame: async () => {
            ctx.drawImage($ve, 0, 0, width, height);
            await holistic.send({ image: canvasElement.$ });
          },
          width,
          height
        });
      }
      if ($l)
        camera2.start();
      if (!$l && camera2)
        camera2.stop();
    });
  });
  tick.on(() => {
    if (currentVRM.$) {
      currentVRM.$.update(0.01);
    }
    if (mirrorVRM.$) {
      mirrorVRM.$.update(0.01);
    }
  });
  function Random(items) {
    return items[Math.floor(Math.random() * items.length)];
  }
  talk.on(async ($talk) => {
    if (!$talk)
      return;
    const s2 = Math.sin(Math.PI * tick.$);
    const spl = $talk.split(" ");
    spl.push("pop");
    const intv = setInterval(() => {
      const item = spl.pop();
      if (!item) {
        clearInterval(intv);
        return;
      }
      mirrorVRM.$?.blendShapeProxy.setValue(VRMSchema.BlendShapePresetName[Random("OEIAU")], 0.5 + 2 * s2);
    }, 1 / 3.5 * 1e3);
  });

  // src/component/uniforms.ts
  AFRAME.registerComponent("uniforms", {
    init() {
      this.el.object3D.frustumCulled = false;
    },
    tick() {
      time.$.value = this.el.time;
      time.poke();
    }
  });

  // src/component/vary.ts
  var vec3 = new AFRAME.THREE.Vector3();
  var bb2 = new AFRAME.THREE.Box3();
  AFRAME.registerComponent("vary", {
    multiple: true,
    schema: {
      property: { type: "string", default: "position" },
      range: { type: "string", default: "-1 -1 -1 1 1 1" }
    },
    init() {
      const range = this.data.range.split(" ").map((v) => parseFloat(v));
      this.cancel = do_vary.on(($v) => {
        const o3d = this.el.object3D;
        bb2.setFromArray(range);
        o3d[this.data.property]?.set(bb2.min.x + Math.random() * (bb2.max.x - bb2.min.x), bb2.min.y + Math.random() * (bb2.max.y - bb2.min.y), bb2.min.z + Math.random() * (bb2.max.z - bb2.min.z));
      });
    },
    remove() {
      this.cancel();
    }
  });

  // src/component/random.ts
  AFRAME.registerComponent("random", {
    multiple: true,
    schema: {
      type: "string"
    },
    init() {
      const spi = this.data.split("|");
      const mix = spi[Math.floor(Math.random() * spi.length)];
      this.el.setAttribute("mixin", this.el.getAttribute("mixin") || ` ${mix}`);
    }
  });

  // src/ui/webcam.svelte
  function create_fragment(ctx) {
    let div;
    let video2;
    let t;
    let canvas;
    return {
      c() {
        div = element("div");
        video2 = element("video");
        t = space();
        canvas = element("canvas");
        attr(div, "class", "hidden svelte-2e2o1w");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, video2);
        ctx[2](video2);
        append(div, t);
        append(div, canvas);
        ctx[3](canvas);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        ctx[2](null);
        ctx[3](null);
      }
    };
  }
  function instance($$self, $$props, $$invalidate) {
    let videoElementSource;
    let canvasElementSource;
    function video_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        videoElementSource = $$value;
        $$invalidate(0, videoElementSource);
      });
    }
    function canvas_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        canvasElementSource = $$value;
        $$invalidate(1, canvasElementSource);
      });
    }
    $$self.$$.update = () => {
      if ($$self.$$.dirty & 3) {
        $: {
          if (canvasElementSource && !canvasElement.$) {
            canvasElement.set(canvasElementSource);
          }
          if (videoElementSource && !videoElement.$) {
            videoElement.set(videoElementSource);
          }
        }
      }
    };
    return [videoElementSource, canvasElementSource, video_binding, canvas_binding];
  }
  var Webcam = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance, create_fragment, safe_not_equal, {});
    }
  };
  var webcam_default = Webcam;

  // src/node/characters-assets.svelte
  function create_fragment2(ctx) {
    let a_mixin;
    return {
      c() {
        a_mixin = element("a-mixin");
        set_custom_element_data(a_mixin, "id", "character");
        set_custom_element_data(a_mixin, "ammo-body", "type: dynamic; mass: 1; linearDamping: 0.95; angularDamping: 1;angularFactor: 0 1 0;");
        set_custom_element_data(a_mixin, "ammo-shape", "type: capsule; fit: manual; halfExtents: 0.2 0.6 0.2; offset: 0 0.75 0");
      },
      m(target, anchor) {
        insert(target, a_mixin, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_mixin);
      }
    };
  }
  var Characters_assets = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment2, safe_not_equal, {});
    }
  };
  var characters_assets_default = Characters_assets;

  // src/component/wasd-controller.ts
  var vec32 = new AFRAME.THREE.Vector3();
  var quat2 = new AFRAME.THREE.Quaternion();
  function getRoot(o3d) {
    if (o3d.parent.name === "Root") {
      return o3d.parent;
    }
    return getRoot(o3d.parent);
  }
  AFRAME.registerComponent("wasd-controller", {
    schema: {
      speed: { type: "number", default: 0.5 },
      rot: { type: "number", default: 25e-4 }
    },
    init() {
      this.jump = AFRAME.utils.throttleTick(this.jump, 2e3, this);
    },
    jump() {
      this.el.emit("jump");
    },
    tick(_, delta) {
      if (guest.$)
        return;
      if (!this.el.body)
        return;
      const o3d = this.el.object3D;
      let force;
      let torq;
      vec32.set(0, 0, 0);
      let intensity = 1;
      let hop = 5;
      if (key_map.$["shift"]) {
        intensity = 1.5;
      }
      vec32.y = 5;
      if (key_map.$[" "] && o3d.position.y < 0.5) {
        hop = delta;
        this.jump();
        vec32.y = hop;
      }
      if (key_map.$["w"]) {
        vec32.z += -this.data.speed * delta * intensity;
      }
      if (key_map.$["s"]) {
        vec32.z += this.data.speed * delta * intensity;
      }
      if (key_map.$["a"]) {
        vec32.x += -this.data.speed * delta * intensity;
      }
      if (key_map.$["d"]) {
        vec32.x += this.data.speed * delta * intensity;
      }
      if (key_map.$["q"]) {
        const root = getRoot(camera.$);
        root.rotation.y += this.data.rot * delta;
      }
      if (key_map.$["e"]) {
        const root = getRoot(camera.$);
        root.rotation.y -= this.data.rot * delta;
      }
      if (Math.abs(vec32.length()) > 0 && camera.$) {
        camera.$.updateMatrixWorld();
        quat2.setFromRotationMatrix(camera.$.matrixWorld);
        const up = vec32.y;
        vec32.applyQuaternion(quat2);
        force = new Ammo.btVector3(vec32.x, up, vec32.z);
        this.el.body.applyForce(force);
        this.el.body.activate();
        Ammo.destroy(force);
      }
      if (torq)
        Ammo.destroy(torq);
    }
  });

  // src/component/sfxr.ts
  AFRAME.registerComponent("sfxr", {
    multiple: true,
    schema: {
      oldParams: { default: true },
      wave_type: { default: 1 },
      p_env_attack: { default: 0 },
      p_env_sustain: { default: 0.31718502829007483 },
      p_env_punch: { default: 0 },
      p_env_decay: { default: 0.2718540993592685 },
      p_base_freq: { default: 0.26126191208337196 },
      p_freq_limit: { default: 0 },
      p_freq_ramp: { default: 0.43787689856926615 },
      p_freq_dramp: { default: 0 },
      p_vib_strength: { default: 0 },
      p_vib_speed: { default: 0 },
      p_arp_mod: { default: 0 },
      p_arp_speed: { default: 0 },
      p_duty: { default: 1 },
      p_duty_ramp: { default: 0 },
      p_repeat_speed: { default: 0.7558565452384385 },
      p_pha_offset: { default: 0 },
      p_pha_ramp: { default: 0 },
      p_lpf_freq: { default: 1 },
      p_lpf_ramp: { default: 0 },
      p_lpf_resonance: { default: 0 },
      p_hpf_freq: { default: 0 },
      p_hpf_ramp: { default: 0 },
      sound_vol: { default: 0.25 },
      sample_rate: { default: 44100 },
      sample_size: { default: 8 },
      autoplay: { type: "boolean", default: false },
      spatial: { type: "boolean", default: true }
    },
    init: function() {
      if (this.id) {
        this.event = this.event.bind(this);
        this.el.addEventListener(this.id, this.event);
      }
      if (this.autoplay) {
        this.event();
      }
    },
    event() {
      if (!this.audio) {
        this.audio = new SoundEffect(this.data).generate();
      }
      this.audio.getAudio().play();
    },
    remove() {
      if (this.cancel)
        clearTimeout(this.cancel);
      this.el.removeEventlistener(this.id, this.event);
    }
  });

  // src/sound/action.ts
  var sfx_jump = {
    "oldParams": true,
    "wave_type": 0,
    "p_env_attack": 0,
    "p_env_sustain": 0.14827504779514308,
    "p_env_punch": 0,
    "p_env_decay": 0.2604416321207049,
    "p_base_freq": 0.3492950945673611,
    "p_freq_limit": 0,
    "p_freq_ramp": 0.1370009340411704,
    "p_freq_dramp": 0,
    "p_vib_strength": 0,
    "p_vib_speed": 0,
    "p_arp_mod": 0,
    "p_arp_speed": 0,
    "p_duty": 0.4063339547539369,
    "p_duty_ramp": 0,
    "p_repeat_speed": 0,
    "p_pha_offset": 0,
    "p_pha_ramp": 0,
    "p_lpf_freq": 1,
    "p_lpf_ramp": 0,
    "p_lpf_resonance": 0,
    "p_hpf_freq": 0.25097654676858755,
    "p_hpf_ramp": 0,
    "sound_vol": 1e-3,
    "sample_rate": 44100,
    "sample_size": 8
  };

  // src/node/characters.svelte
  function create_fragment3(ctx) {
    let a_entity0;
    let a_entity0_vrm_value;
    let a_entity0_scale_value;
    let a_entity0_sfxr__jump_value;
    let t;
    let a_entity1;
    let a_entity1_vrm_value;
    return {
      c() {
        a_entity0 = element("a-entity");
        t = space();
        a_entity1 = element("a-entity");
        set_custom_element_data(a_entity0, "mixin", "shadow character");
        set_custom_element_data(a_entity0, "position", "0 1 0");
        set_custom_element_data(a_entity0, "vrm", a_entity0_vrm_value = "src: " + ctx[0] + "; current: true");
        set_custom_element_data(a_entity0, "look-controls", "");
        set_custom_element_data(a_entity0, "scale", a_entity0_scale_value = ctx[1].x + " " + ctx[1].y + " " + ctx[1].z);
        set_custom_element_data(a_entity0, "host", "current");
        set_custom_element_data(a_entity0, "wasd-controller", "");
        set_custom_element_data(a_entity0, "net-avatar", "");
        set_custom_element_data(a_entity0, "sfxr__jump", a_entity0_sfxr__jump_value = AFRAME.utils.styleParser.stringify(sfx_jump));
        set_custom_element_data(a_entity1, "mixin", "shadow character");
        set_custom_element_data(a_entity1, "position", "0 1 -1");
        set_custom_element_data(a_entity1, "rotation", "0 180 0");
        set_custom_element_data(a_entity1, "host", "doer");
        set_custom_element_data(a_entity1, "net-avatar", "");
        set_custom_element_data(a_entity1, "vrm", a_entity1_vrm_value = "src: " + ctx[2] + "; mirror: true");
      },
      m(target, anchor) {
        insert(target, a_entity0, anchor);
        insert(target, t, anchor);
        insert(target, a_entity1, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & 1 && a_entity0_vrm_value !== (a_entity0_vrm_value = "src: " + ctx2[0] + "; current: true")) {
          set_custom_element_data(a_entity0, "vrm", a_entity0_vrm_value);
        }
        if (dirty & 2 && a_entity0_scale_value !== (a_entity0_scale_value = ctx2[1].x + " " + ctx2[1].y + " " + ctx2[1].z)) {
          set_custom_element_data(a_entity0, "scale", a_entity0_scale_value);
        }
        if (dirty & 4 && a_entity1_vrm_value !== (a_entity1_vrm_value = "src: " + ctx2[2] + "; mirror: true")) {
          set_custom_element_data(a_entity1, "vrm", a_entity1_vrm_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_entity0);
        if (detaching)
          detach(t);
        if (detaching)
          detach(a_entity1);
      }
    };
  }
  function instance2($$self, $$props, $$invalidate) {
    let $avatar_current;
    let $size;
    let $avatar_doer;
    component_subscribe($$self, avatar_current, ($$value) => $$invalidate(0, $avatar_current = $$value));
    component_subscribe($$self, size, ($$value) => $$invalidate(1, $size = $$value));
    component_subscribe($$self, avatar_doer, ($$value) => $$invalidate(2, $avatar_doer = $$value));
    return [$avatar_current, $size, $avatar_doer];
  }
  var Characters = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance2, create_fragment3, safe_not_equal, {});
    }
  };
  var characters_default = Characters;

  // node_modules/three/build/three.module.js
  if (Number.EPSILON === void 0) {
    Number.EPSILON = Math.pow(2, -52);
  }
  if (Number.isInteger === void 0) {
    Number.isInteger = function(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
  }
  if (Math.sign === void 0) {
    Math.sign = function(x) {
      return x < 0 ? -1 : x > 0 ? 1 : +x;
    };
  }
  if ("name" in Function.prototype === false) {
    Object.defineProperty(Function.prototype, "name", {
      get: function() {
        return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
      }
    });
  }
  if (Object.assign === void 0) {
    (function() {
      Object.assign = function(target) {
        if (target === void 0 || target === null) {
          throw new TypeError("Cannot convert undefined or null to object");
        }
        var output = Object(target);
        for (var index = 1; index < arguments.length; index++) {
          var source = arguments[index];
          if (source !== void 0 && source !== null) {
            for (var nextKey in source) {
              if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
                output[nextKey] = source[nextKey];
              }
            }
          }
        }
        return output;
      };
    })();
  }
  function EventDispatcher() {
  }
  Object.assign(EventDispatcher.prototype, {
    addEventListener: function(type, listener) {
      if (this._listeners === void 0)
        this._listeners = {};
      var listeners = this._listeners;
      if (listeners[type] === void 0) {
        listeners[type] = [];
      }
      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    },
    hasEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return false;
      var listeners = this._listeners;
      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
    },
    removeEventListener: function(type, listener) {
      if (this._listeners === void 0)
        return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];
      if (listenerArray !== void 0) {
        var index = listenerArray.indexOf(listener);
        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    },
    dispatchEvent: function(event) {
      if (this._listeners === void 0)
        return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];
      if (listenerArray !== void 0) {
        event.target = this;
        var array = listenerArray.slice(0);
        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
      }
    }
  });
  var REVISION = "103";
  var CullFaceNone = 0;
  var CullFaceBack = 1;
  var CullFaceFront = 2;
  var PCFShadowMap = 1;
  var PCFSoftShadowMap = 2;
  var FrontSide = 0;
  var BackSide = 1;
  var DoubleSide = 2;
  var FlatShading = 1;
  var NoColors = 0;
  var FaceColors = 1;
  var VertexColors = 2;
  var NoBlending = 0;
  var NormalBlending = 1;
  var AdditiveBlending = 2;
  var SubtractiveBlending = 3;
  var MultiplyBlending = 4;
  var CustomBlending = 5;
  var AddEquation = 100;
  var SubtractEquation = 101;
  var ReverseSubtractEquation = 102;
  var MinEquation = 103;
  var MaxEquation = 104;
  var ZeroFactor = 200;
  var OneFactor = 201;
  var SrcColorFactor = 202;
  var OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = 207;
  var DstColorFactor = 208;
  var OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = 210;
  var NeverDepth = 0;
  var AlwaysDepth = 1;
  var LessDepth = 2;
  var LessEqualDepth = 3;
  var EqualDepth = 4;
  var GreaterEqualDepth = 5;
  var GreaterDepth = 6;
  var NotEqualDepth = 7;
  var MultiplyOperation = 0;
  var MixOperation = 1;
  var AddOperation = 2;
  var NoToneMapping = 0;
  var LinearToneMapping = 1;
  var ReinhardToneMapping = 2;
  var Uncharted2ToneMapping = 3;
  var CineonToneMapping = 4;
  var ACESFilmicToneMapping = 5;
  var UVMapping = 300;
  var CubeReflectionMapping = 301;
  var CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = 304;
  var SphericalReflectionMapping = 305;
  var CubeUVReflectionMapping = 306;
  var CubeUVRefractionMapping = 307;
  var RepeatWrapping = 1e3;
  var ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = 1002;
  var NearestFilter = 1003;
  var NearestMipMapNearestFilter = 1004;
  var NearestMipMapLinearFilter = 1005;
  var LinearFilter = 1006;
  var LinearMipMapNearestFilter = 1007;
  var LinearMipMapLinearFilter = 1008;
  var UnsignedByteType = 1009;
  var ByteType = 1010;
  var ShortType = 1011;
  var UnsignedShortType = 1012;
  var IntType = 1013;
  var UnsignedIntType = 1014;
  var FloatType = 1015;
  var HalfFloatType = 1016;
  var UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = 1018;
  var UnsignedShort565Type = 1019;
  var UnsignedInt248Type = 1020;
  var AlphaFormat = 1021;
  var RGBFormat = 1022;
  var RGBAFormat = 1023;
  var LuminanceFormat = 1024;
  var LuminanceAlphaFormat = 1025;
  var DepthFormat = 1026;
  var DepthStencilFormat = 1027;
  var RedFormat = 1028;
  var RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = 36196;
  var RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = 37821;
  var LoopOnce = 2200;
  var LoopRepeat = 2201;
  var LoopPingPong = 2202;
  var InterpolateDiscrete = 2300;
  var InterpolateLinear = 2301;
  var InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = 2401;
  var WrapAroundEnding = 2402;
  var TrianglesDrawMode = 0;
  var TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = 2;
  var LinearEncoding = 3e3;
  var sRGBEncoding = 3001;
  var GammaEncoding = 3007;
  var RGBEEncoding = 3002;
  var RGBM7Encoding = 3004;
  var RGBM16Encoding = 3005;
  var RGBDEncoding = 3006;
  var BasicDepthPacking = 3200;
  var RGBADepthPacking = 3201;
  var TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = 1;
  var _Math = {
    DEG2RAD: Math.PI / 180,
    RAD2DEG: 180 / Math.PI,
    generateUUID: function() {
      var lut = [];
      for (var i = 0; i < 256; i++) {
        lut[i] = (i < 16 ? "0" : "") + i.toString(16);
      }
      return function generateUUID() {
        var d0 = Math.random() * 4294967295 | 0;
        var d1 = Math.random() * 4294967295 | 0;
        var d2 = Math.random() * 4294967295 | 0;
        var d3 = Math.random() * 4294967295 | 0;
        var uuid = lut[d0 & 255] + lut[d0 >> 8 & 255] + lut[d0 >> 16 & 255] + lut[d0 >> 24 & 255] + "-" + lut[d1 & 255] + lut[d1 >> 8 & 255] + "-" + lut[d1 >> 16 & 15 | 64] + lut[d1 >> 24 & 255] + "-" + lut[d2 & 63 | 128] + lut[d2 >> 8 & 255] + "-" + lut[d2 >> 16 & 255] + lut[d2 >> 24 & 255] + lut[d3 & 255] + lut[d3 >> 8 & 255] + lut[d3 >> 16 & 255] + lut[d3 >> 24 & 255];
        return uuid.toUpperCase();
      };
    }(),
    clamp: function(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },
    euclideanModulo: function(n, m) {
      return (n % m + m) % m;
    },
    mapLinear: function(x, a1, a2, b1, b2) {
      return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
    },
    lerp: function(x, y, t) {
      return (1 - t) * x + t * y;
    },
    smoothstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * (3 - 2 * x);
    },
    smootherstep: function(x, min, max) {
      if (x <= min)
        return 0;
      if (x >= max)
        return 1;
      x = (x - min) / (max - min);
      return x * x * x * (x * (x * 6 - 15) + 10);
    },
    randInt: function(low, high) {
      return low + Math.floor(Math.random() * (high - low + 1));
    },
    randFloat: function(low, high) {
      return low + Math.random() * (high - low);
    },
    randFloatSpread: function(range) {
      return range * (0.5 - Math.random());
    },
    degToRad: function(degrees) {
      return degrees * _Math.DEG2RAD;
    },
    radToDeg: function(radians) {
      return radians * _Math.RAD2DEG;
    },
    isPowerOfTwo: function(value) {
      return (value & value - 1) === 0 && value !== 0;
    },
    ceilPowerOfTwo: function(value) {
      return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
    },
    floorPowerOfTwo: function(value) {
      return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
    }
  };
  function Vector2(x, y) {
    this.x = x || 0;
    this.y = y || 0;
  }
  Object.defineProperties(Vector2.prototype, {
    "width": {
      get: function() {
        return this.x;
      },
      set: function(value) {
        this.x = value;
      }
    },
    "height": {
      get: function() {
        return this.y;
      },
      set: function(value) {
        this.y = value;
      }
    }
  });
  Object.assign(Vector2.prototype, {
    isVector2: true,
    set: function(x, y) {
      this.x = x;
      this.y = y;
      return this;
    },
    setScalar: function(scalar) {
      this.x = scalar;
      this.y = scalar;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        default:
          throw new Error("index is out of range: " + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      return this;
    },
    add: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      return this;
    },
    addScalar: function(s2) {
      this.x += s2;
      this.y += s2;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      return this;
    },
    addScaledVector: function(v, s2) {
      this.x += v.x * s2;
      this.y += v.y * s2;
      return this;
    },
    sub: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      return this;
    },
    subScalar: function(s2) {
      this.x -= s2;
      this.y -= s2;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      return this;
    },
    multiply: function(v) {
      this.x *= v.x;
      this.y *= v.y;
      return this;
    },
    multiplyScalar: function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      return this;
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    applyMatrix3: function(m) {
      var x = this.x, y = this.y;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6];
      this.y = e[1] * x + e[4] * y + e[7];
      return this;
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      return this;
    },
    clampScalar: function() {
      var min = new Vector2();
      var max = new Vector2();
      return function clampScalar(minVal, maxVal) {
        min.set(minVal, minVal);
        max.set(maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    clampLength: function(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      return this;
    },
    roundToZero: function() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y;
    },
    cross: function(v) {
      return this.x * v.y - this.y * v.x;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    angle: function() {
      var angle = Math.atan2(this.y, this.x);
      if (angle < 0)
        angle += 2 * Math.PI;
      return angle;
    },
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
      var dx = this.x - v.x, dy = this.y - v.y;
      return dx * dx + dy * dy;
    },
    manhattanDistanceTo: function(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
    },
    setLength: function(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function(v) {
      return v.x === this.x && v.y === this.y;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      return this;
    },
    rotateAround: function(center, angle) {
      var c = Math.cos(angle), s2 = Math.sin(angle);
      var x = this.x - center.x;
      var y = this.y - center.y;
      this.x = x * c - y * s2 + center.x;
      this.y = x * s2 + y * c + center.y;
      return this;
    }
  });
  function Quaternion(x, y, z, w) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._w = w !== void 0 ? w : 1;
  }
  Object.assign(Quaternion, {
    slerp: function(qa, qb, qm, t) {
      return qm.copy(qa).slerp(qb, t);
    },
    slerpFlat: function(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
      var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
        var s2 = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
        if (sqrSin > Number.EPSILON) {
          var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
          s2 = Math.sin(s2 * len) / sin;
          t = Math.sin(t * len) / sin;
        }
        var tDir = t * dir;
        x0 = x0 * s2 + x1 * tDir;
        y0 = y0 * s2 + y1 * tDir;
        z0 = z0 * s2 + z1 * tDir;
        w0 = w0 * s2 + w1 * tDir;
        if (s2 === 1 - t) {
          var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
          x0 *= f;
          y0 *= f;
          z0 *= f;
          w0 *= f;
        }
      }
      dst[dstOffset] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
    }
  });
  Object.defineProperties(Quaternion.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(value) {
        this._x = value;
        this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(value) {
        this._y = value;
        this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(value) {
        this._z = value;
        this.onChangeCallback();
      }
    },
    w: {
      get: function() {
        return this._w;
      },
      set: function(value) {
        this._w = value;
        this.onChangeCallback();
      }
    }
  });
  Object.assign(Quaternion.prototype, {
    isQuaternion: true,
    set: function(x, y, z, w) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
      this.onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._w);
    },
    copy: function(quaternion) {
      this._x = quaternion.x;
      this._y = quaternion.y;
      this._z = quaternion.z;
      this._w = quaternion.w;
      this.onChangeCallback();
      return this;
    },
    setFromEuler: function(euler2, update3) {
      if (!(euler2 && euler2.isEuler)) {
        throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
      }
      var x = euler2._x, y = euler2._y, z = euler2._z, order = euler2.order;
      var cos = Math.cos;
      var sin = Math.sin;
      var c1 = cos(x / 2);
      var c2 = cos(y / 2);
      var c3 = cos(z / 2);
      var s1 = sin(x / 2);
      var s2 = sin(y / 2);
      var s3 = sin(z / 2);
      if (order === "XYZ") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "YXZ") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === "ZXY") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "ZYX") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      } else if (order === "YZX") {
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
      } else if (order === "XZY") {
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
      }
      if (update3 !== false)
        this.onChangeCallback();
      return this;
    },
    setFromAxisAngle: function(axis, angle) {
      var halfAngle = angle / 2, s2 = Math.sin(halfAngle);
      this._x = axis.x * s2;
      this._y = axis.y * s2;
      this._z = axis.z * s2;
      this._w = Math.cos(halfAngle);
      this.onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(m) {
      var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s2;
      if (trace > 0) {
        s2 = 0.5 / Math.sqrt(trace + 1);
        this._w = 0.25 / s2;
        this._x = (m32 - m23) * s2;
        this._y = (m13 - m31) * s2;
        this._z = (m21 - m12) * s2;
      } else if (m11 > m22 && m11 > m33) {
        s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
        this._w = (m32 - m23) / s2;
        this._x = 0.25 * s2;
        this._y = (m12 + m21) / s2;
        this._z = (m13 + m31) / s2;
      } else if (m22 > m33) {
        s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
        this._w = (m13 - m31) / s2;
        this._x = (m12 + m21) / s2;
        this._y = 0.25 * s2;
        this._z = (m23 + m32) / s2;
      } else {
        s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
        this._w = (m21 - m12) / s2;
        this._x = (m13 + m31) / s2;
        this._y = (m23 + m32) / s2;
        this._z = 0.25 * s2;
      }
      this.onChangeCallback();
      return this;
    },
    setFromUnitVectors: function(vFrom, vTo) {
      var EPS = 1e-6;
      var r = vFrom.dot(vTo) + 1;
      if (r < EPS) {
        r = 0;
        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
          this._x = -vFrom.y;
          this._y = vFrom.x;
          this._z = 0;
          this._w = r;
        } else {
          this._x = 0;
          this._y = -vFrom.z;
          this._z = vFrom.y;
          this._w = r;
        }
      } else {
        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
        this._w = r;
      }
      return this.normalize();
    },
    angleTo: function(q2) {
      return 2 * Math.acos(Math.abs(_Math.clamp(this.dot(q2), -1, 1)));
    },
    rotateTowards: function(q2, step) {
      var angle = this.angleTo(q2);
      if (angle === 0)
        return this;
      var t = Math.min(1, step / angle);
      this.slerp(q2, t);
      return this;
    },
    inverse: function() {
      return this.conjugate();
    },
    conjugate: function() {
      this._x *= -1;
      this._y *= -1;
      this._z *= -1;
      this.onChangeCallback();
      return this;
    },
    dot: function(v) {
      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
    },
    lengthSq: function() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
    },
    length: function() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
    },
    normalize: function() {
      var l = this.length();
      if (l === 0) {
        this._x = 0;
        this._y = 0;
        this._z = 0;
        this._w = 1;
      } else {
        l = 1 / l;
        this._x = this._x * l;
        this._y = this._y * l;
        this._z = this._z * l;
        this._w = this._w * l;
      }
      this.onChangeCallback();
      return this;
    },
    multiply: function(q2, p2) {
      if (p2 !== void 0) {
        console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
        return this.multiplyQuaternions(q2, p2);
      }
      return this.multiplyQuaternions(this, q2);
    },
    premultiply: function(q2) {
      return this.multiplyQuaternions(q2, this);
    },
    multiplyQuaternions: function(a, b) {
      var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
      var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
      this.onChangeCallback();
      return this;
    },
    slerp: function(qb, t) {
      if (t === 0)
        return this;
      if (t === 1)
        return this.copy(qb);
      var x = this._x, y = this._y, z = this._z, w = this._w;
      var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
      if (cosHalfTheta < 0) {
        this._w = -qb._w;
        this._x = -qb._x;
        this._y = -qb._y;
        this._z = -qb._z;
        cosHalfTheta = -cosHalfTheta;
      } else {
        this.copy(qb);
      }
      if (cosHalfTheta >= 1) {
        this._w = w;
        this._x = x;
        this._y = y;
        this._z = z;
        return this;
      }
      var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
      if (sqrSinHalfTheta <= Number.EPSILON) {
        var s2 = 1 - t;
        this._w = s2 * w + t * this._w;
        this._x = s2 * x + t * this._x;
        this._y = s2 * y + t * this._y;
        this._z = s2 * z + t * this._z;
        return this.normalize();
      }
      var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
      var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
      var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
      this._w = w * ratioA + this._w * ratioB;
      this._x = x * ratioA + this._x * ratioB;
      this._y = y * ratioA + this._y * ratioB;
      this._z = z * ratioA + this._z * ratioB;
      this.onChangeCallback();
      return this;
    },
    equals: function(quaternion) {
      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      this._x = array[offset];
      this._y = array[offset + 1];
      this._z = array[offset + 2];
      this._w = array[offset + 3];
      this.onChangeCallback();
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._w;
      return array;
    },
    onChange: function(callback) {
      this.onChangeCallback = callback;
      return this;
    },
    onChangeCallback: function() {
    }
  });
  function Vector3(x, y, z) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
  }
  Object.assign(Vector3.prototype, {
    isVector3: true,
    set: function(x, y, z) {
      this.x = x;
      this.y = y;
      this.z = z;
      return this;
    },
    setScalar: function(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setZ: function(z) {
      this.z = z;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        default:
          throw new Error("index is out of range: " + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      return this;
    },
    add: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      return this;
    },
    addScalar: function(s2) {
      this.x += s2;
      this.y += s2;
      this.z += s2;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      return this;
    },
    addScaledVector: function(v, s2) {
      this.x += v.x * s2;
      this.y += v.y * s2;
      this.z += v.z * s2;
      return this;
    },
    sub: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      return this;
    },
    subScalar: function(s2) {
      this.x -= s2;
      this.y -= s2;
      this.z -= s2;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      return this;
    },
    multiply: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
        return this.multiplyVectors(v, w);
      }
      this.x *= v.x;
      this.y *= v.y;
      this.z *= v.z;
      return this;
    },
    multiplyScalar: function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    },
    multiplyVectors: function(a, b) {
      this.x = a.x * b.x;
      this.y = a.y * b.y;
      this.z = a.z * b.z;
      return this;
    },
    applyEuler: function() {
      var quaternion = new Quaternion();
      return function applyEuler(euler2) {
        if (!(euler2 && euler2.isEuler)) {
          console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
        }
        return this.applyQuaternion(quaternion.setFromEuler(euler2));
      };
    }(),
    applyAxisAngle: function() {
      var quaternion = new Quaternion();
      return function applyAxisAngle(axis, angle) {
        return this.applyQuaternion(quaternion.setFromAxisAngle(axis, angle));
      };
    }(),
    applyMatrix3: function(m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[3] * y + e[6] * z;
      this.y = e[1] * x + e[4] * y + e[7] * z;
      this.z = e[2] * x + e[5] * y + e[8] * z;
      return this;
    },
    applyMatrix4: function(m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
      this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
      this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
      this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
      return this;
    },
    applyQuaternion: function(q2) {
      var x = this.x, y = this.y, z = this.z;
      var qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
      var ix = qw * x + qy * z - qz * y;
      var iy = qw * y + qz * x - qx * z;
      var iz = qw * z + qx * y - qy * x;
      var iw = -qx * x - qy * y - qz * z;
      this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
      return this;
    },
    project: function(camera2) {
      return this.applyMatrix4(camera2.matrixWorldInverse).applyMatrix4(camera2.projectionMatrix);
    },
    unproject: function(camera2) {
      return this.applyMatrix4(camera2.projectionMatrixInverse).applyMatrix4(camera2.matrixWorld);
    },
    transformDirection: function(m) {
      var x = this.x, y = this.y, z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z;
      this.y = e[1] * x + e[5] * y + e[9] * z;
      this.z = e[2] * x + e[6] * y + e[10] * z;
      return this.normalize();
    },
    divide: function(v) {
      this.x /= v.x;
      this.y /= v.y;
      this.z /= v.z;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      return this;
    },
    clampScalar: function() {
      var min = new Vector3();
      var max = new Vector3();
      return function clampScalar(minVal, maxVal) {
        min.set(minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    clampLength: function(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      return this;
    },
    roundToZero: function() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    cross: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
        return this.crossVectors(v, w);
      }
      return this.crossVectors(this, v);
    },
    crossVectors: function(a, b) {
      var ax = a.x, ay = a.y, az = a.z;
      var bx = b.x, by = b.y, bz = b.z;
      this.x = ay * bz - az * by;
      this.y = az * bx - ax * bz;
      this.z = ax * by - ay * bx;
      return this;
    },
    projectOnVector: function(vector) {
      var scalar = vector.dot(this) / vector.lengthSq();
      return this.copy(vector).multiplyScalar(scalar);
    },
    projectOnPlane: function() {
      var v1 = new Vector3();
      return function projectOnPlane(planeNormal) {
        v1.copy(this).projectOnVector(planeNormal);
        return this.sub(v1);
      };
    }(),
    reflect: function() {
      var v1 = new Vector3();
      return function reflect(normal) {
        return this.sub(v1.copy(normal).multiplyScalar(2 * this.dot(normal)));
      };
    }(),
    angleTo: function(v) {
      var theta = this.dot(v) / Math.sqrt(this.lengthSq() * v.lengthSq());
      return Math.acos(_Math.clamp(theta, -1, 1));
    },
    distanceTo: function(v) {
      return Math.sqrt(this.distanceToSquared(v));
    },
    distanceToSquared: function(v) {
      var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
      return dx * dx + dy * dy + dz * dz;
    },
    manhattanDistanceTo: function(v) {
      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
    },
    setFromSpherical: function(s2) {
      return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
    },
    setFromSphericalCoords: function(radius, phi, theta) {
      var sinPhiRadius = Math.sin(phi) * radius;
      this.x = sinPhiRadius * Math.sin(theta);
      this.y = Math.cos(phi) * radius;
      this.z = sinPhiRadius * Math.cos(theta);
      return this;
    },
    setFromCylindrical: function(c) {
      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
    },
    setFromCylindricalCoords: function(radius, theta, y) {
      this.x = radius * Math.sin(theta);
      this.y = y;
      this.z = radius * Math.cos(theta);
      return this;
    },
    setFromMatrixPosition: function(m) {
      var e = m.elements;
      this.x = e[12];
      this.y = e[13];
      this.z = e[14];
      return this;
    },
    setFromMatrixScale: function(m) {
      var sx = this.setFromMatrixColumn(m, 0).length();
      var sy = this.setFromMatrixColumn(m, 1).length();
      var sz = this.setFromMatrixColumn(m, 2).length();
      this.x = sx;
      this.y = sy;
      this.z = sz;
      return this;
    },
    setFromMatrixColumn: function(m, index) {
      return this.fromArray(m.elements, index * 4);
    },
    equals: function(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      return this;
    }
  });
  function Matrix3() {
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  Object.assign(Matrix3.prototype, {
    isMatrix3: true,
    set: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      var te = this.elements;
      te[0] = n11;
      te[1] = n21;
      te[2] = n31;
      te[3] = n12;
      te[4] = n22;
      te[5] = n32;
      te[6] = n13;
      te[7] = n23;
      te[8] = n33;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new this.constructor().fromArray(this.elements);
    },
    copy: function(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      return this;
    },
    setFromMatrix4: function(m) {
      var me = m.elements;
      this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
      return this;
    },
    applyToBufferAttribute: function() {
      var v1 = new Vector3();
      return function applyToBufferAttribute(attribute) {
        for (var i = 0, l = attribute.count; i < l; i++) {
          v1.x = attribute.getX(i);
          v1.y = attribute.getY(i);
          v1.z = attribute.getZ(i);
          v1.applyMatrix3(this);
          attribute.setXYZ(i, v1.x, v1.y, v1.z);
        }
        return attribute;
      };
    }(),
    multiply: function(m) {
      return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
      return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0], a12 = ae[3], a13 = ae[6];
      var a21 = ae[1], a22 = ae[4], a23 = ae[7];
      var a31 = ae[2], a32 = ae[5], a33 = ae[8];
      var b11 = be[0], b12 = be[3], b13 = be[6];
      var b21 = be[1], b22 = be[4], b23 = be[7];
      var b31 = be[2], b32 = be[5], b33 = be[8];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31;
      te[3] = a11 * b12 + a12 * b22 + a13 * b32;
      te[6] = a11 * b13 + a12 * b23 + a13 * b33;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31;
      te[4] = a21 * b12 + a22 * b22 + a23 * b32;
      te[7] = a21 * b13 + a22 * b23 + a23 * b33;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31;
      te[5] = a31 * b12 + a32 * b22 + a33 * b32;
      te[8] = a31 * b13 + a32 * b23 + a33 * b33;
      return this;
    },
    multiplyScalar: function(s2) {
      var te = this.elements;
      te[0] *= s2;
      te[3] *= s2;
      te[6] *= s2;
      te[1] *= s2;
      te[4] *= s2;
      te[7] *= s2;
      te[2] *= s2;
      te[5] *= s2;
      te[8] *= s2;
      return this;
    },
    determinant: function() {
      var te = this.elements;
      var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
      return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    },
    getInverse: function(matrix, throwOnDegenerate) {
      if (matrix && matrix.isMatrix4) {
        console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
      }
      var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
      if (det === 0) {
        var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
        if (throwOnDegenerate === true) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }
        return this.identity();
      }
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n31 * n23 - n33 * n21) * detInv;
      te[2] = (n32 * n21 - n31 * n22) * detInv;
      te[3] = t12 * detInv;
      te[4] = (n33 * n11 - n31 * n13) * detInv;
      te[5] = (n31 * n12 - n32 * n11) * detInv;
      te[6] = t13 * detInv;
      te[7] = (n21 * n13 - n23 * n11) * detInv;
      te[8] = (n22 * n11 - n21 * n12) * detInv;
      return this;
    },
    transpose: function() {
      var tmp2, m = this.elements;
      tmp2 = m[1];
      m[1] = m[3];
      m[3] = tmp2;
      tmp2 = m[2];
      m[2] = m[6];
      m[6] = tmp2;
      tmp2 = m[5];
      m[5] = m[7];
      m[7] = tmp2;
      return this;
    },
    getNormalMatrix: function(matrix4) {
      return this.setFromMatrix4(matrix4).getInverse(this).transpose();
    },
    transposeIntoArray: function(r) {
      var m = this.elements;
      r[0] = m[0];
      r[1] = m[3];
      r[2] = m[6];
      r[3] = m[1];
      r[4] = m[4];
      r[5] = m[7];
      r[6] = m[2];
      r[7] = m[5];
      r[8] = m[8];
      return this;
    },
    setUvTransform: function(tx, ty, sx, sy, rotation, cx, cy) {
      var c = Math.cos(rotation);
      var s2 = Math.sin(rotation);
      this.set(sx * c, sx * s2, -sx * (c * cx + s2 * cy) + cx + tx, -sy * s2, sy * c, -sy * (-s2 * cx + c * cy) + cy + ty, 0, 0, 1);
    },
    scale: function(sx, sy) {
      var te = this.elements;
      te[0] *= sx;
      te[3] *= sx;
      te[6] *= sx;
      te[1] *= sy;
      te[4] *= sy;
      te[7] *= sy;
      return this;
    },
    rotate: function(theta) {
      var c = Math.cos(theta);
      var s2 = Math.sin(theta);
      var te = this.elements;
      var a11 = te[0], a12 = te[3], a13 = te[6];
      var a21 = te[1], a22 = te[4], a23 = te[7];
      te[0] = c * a11 + s2 * a21;
      te[3] = c * a12 + s2 * a22;
      te[6] = c * a13 + s2 * a23;
      te[1] = -s2 * a11 + c * a21;
      te[4] = -s2 * a12 + c * a22;
      te[7] = -s2 * a13 + c * a23;
      return this;
    },
    translate: function(tx, ty) {
      var te = this.elements;
      te[0] += tx * te[2];
      te[3] += tx * te[5];
      te[6] += tx * te[8];
      te[1] += ty * te[2];
      te[4] += ty * te[5];
      te[7] += ty * te[8];
      return this;
    },
    equals: function(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 9; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      for (var i = 0; i < 9; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      return array;
    }
  });
  var _canvas;
  var ImageUtils = {
    getDataURL: function(image) {
      var canvas;
      if (typeof HTMLCanvasElement == "undefined") {
        return image.src;
      } else if (image instanceof HTMLCanvasElement) {
        canvas = image;
      } else {
        if (_canvas === void 0)
          _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
        _canvas.width = image.width;
        _canvas.height = image.height;
        var context2 = _canvas.getContext("2d");
        if (image instanceof ImageData) {
          context2.putImageData(image, 0, 0);
        } else {
          context2.drawImage(image, 0, 0, image.width, image.height);
        }
        canvas = _canvas;
      }
      if (canvas.width > 2048 || canvas.height > 2048) {
        return canvas.toDataURL("image/jpeg", 0.6);
      } else {
        return canvas.toDataURL("image/png");
      }
    }
  };
  var textureId = 0;
  function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    Object.defineProperty(this, "id", { value: textureId++ });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.image = image !== void 0 ? image : Texture.DEFAULT_IMAGE;
    this.mipmaps = [];
    this.mapping = mapping !== void 0 ? mapping : Texture.DEFAULT_MAPPING;
    this.wrapS = wrapS !== void 0 ? wrapS : ClampToEdgeWrapping;
    this.wrapT = wrapT !== void 0 ? wrapT : ClampToEdgeWrapping;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearMipMapLinearFilter;
    this.anisotropy = anisotropy !== void 0 ? anisotropy : 1;
    this.format = format !== void 0 ? format : RGBAFormat;
    this.type = type !== void 0 ? type : UnsignedByteType;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.encoding = encoding !== void 0 ? encoding : LinearEncoding;
    this.version = 0;
    this.onUpdate = null;
  }
  Texture.DEFAULT_IMAGE = void 0;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Texture,
    isTexture: true,
    updateMatrix: function() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.image = source.image;
      this.mipmaps = source.mipmaps.slice(0);
      this.mapping = source.mapping;
      this.wrapS = source.wrapS;
      this.wrapT = source.wrapT;
      this.magFilter = source.magFilter;
      this.minFilter = source.minFilter;
      this.anisotropy = source.anisotropy;
      this.format = source.format;
      this.type = source.type;
      this.offset.copy(source.offset);
      this.repeat.copy(source.repeat);
      this.center.copy(source.center);
      this.rotation = source.rotation;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrix.copy(source.matrix);
      this.generateMipmaps = source.generateMipmaps;
      this.premultiplyAlpha = source.premultiplyAlpha;
      this.flipY = source.flipY;
      this.unpackAlignment = source.unpackAlignment;
      this.encoding = source.encoding;
      return this;
    },
    toJSON: function(meta) {
      var isRootObject = meta === void 0 || typeof meta === "string";
      if (!isRootObject && meta.textures[this.uuid] !== void 0) {
        return meta.textures[this.uuid];
      }
      var output = {
        metadata: {
          version: 4.5,
          type: "Texture",
          generator: "Texture.toJSON"
        },
        uuid: this.uuid,
        name: this.name,
        mapping: this.mapping,
        repeat: [this.repeat.x, this.repeat.y],
        offset: [this.offset.x, this.offset.y],
        center: [this.center.x, this.center.y],
        rotation: this.rotation,
        wrap: [this.wrapS, this.wrapT],
        format: this.format,
        type: this.type,
        encoding: this.encoding,
        minFilter: this.minFilter,
        magFilter: this.magFilter,
        anisotropy: this.anisotropy,
        flipY: this.flipY,
        premultiplyAlpha: this.premultiplyAlpha,
        unpackAlignment: this.unpackAlignment
      };
      if (this.image !== void 0) {
        var image = this.image;
        if (image.uuid === void 0) {
          image.uuid = _Math.generateUUID();
        }
        if (!isRootObject && meta.images[image.uuid] === void 0) {
          var url;
          if (Array.isArray(image)) {
            url = [];
            for (var i = 0, l = image.length; i < l; i++) {
              url.push(ImageUtils.getDataURL(image[i]));
            }
          } else {
            url = ImageUtils.getDataURL(image);
          }
          meta.images[image.uuid] = {
            uuid: image.uuid,
            url
          };
        }
        output.image = image.uuid;
      }
      if (!isRootObject) {
        meta.textures[this.uuid] = output;
      }
      return output;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    },
    transformUv: function(uv) {
      if (this.mapping !== UVMapping)
        return uv;
      uv.applyMatrix3(this.matrix);
      if (uv.x < 0 || uv.x > 1) {
        switch (this.wrapS) {
          case RepeatWrapping:
            uv.x = uv.x - Math.floor(uv.x);
            break;
          case ClampToEdgeWrapping:
            uv.x = uv.x < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.x) % 2) === 1) {
              uv.x = Math.ceil(uv.x) - uv.x;
            } else {
              uv.x = uv.x - Math.floor(uv.x);
            }
            break;
        }
      }
      if (uv.y < 0 || uv.y > 1) {
        switch (this.wrapT) {
          case RepeatWrapping:
            uv.y = uv.y - Math.floor(uv.y);
            break;
          case ClampToEdgeWrapping:
            uv.y = uv.y < 0 ? 0 : 1;
            break;
          case MirroredRepeatWrapping:
            if (Math.abs(Math.floor(uv.y) % 2) === 1) {
              uv.y = Math.ceil(uv.y) - uv.y;
            } else {
              uv.y = uv.y - Math.floor(uv.y);
            }
            break;
        }
      }
      if (this.flipY) {
        uv.y = 1 - uv.y;
      }
      return uv;
    }
  });
  Object.defineProperty(Texture.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  function Vector4(x, y, z, w) {
    this.x = x || 0;
    this.y = y || 0;
    this.z = z || 0;
    this.w = w !== void 0 ? w : 1;
  }
  Object.assign(Vector4.prototype, {
    isVector4: true,
    set: function(x, y, z, w) {
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
      return this;
    },
    setScalar: function(scalar) {
      this.x = scalar;
      this.y = scalar;
      this.z = scalar;
      this.w = scalar;
      return this;
    },
    setX: function(x) {
      this.x = x;
      return this;
    },
    setY: function(y) {
      this.y = y;
      return this;
    },
    setZ: function(z) {
      this.z = z;
      return this;
    },
    setW: function(w) {
      this.w = w;
      return this;
    },
    setComponent: function(index, value) {
      switch (index) {
        case 0:
          this.x = value;
          break;
        case 1:
          this.y = value;
          break;
        case 2:
          this.z = value;
          break;
        case 3:
          this.w = value;
          break;
        default:
          throw new Error("index is out of range: " + index);
      }
      return this;
    },
    getComponent: function(index) {
      switch (index) {
        case 0:
          return this.x;
        case 1:
          return this.y;
        case 2:
          return this.z;
        case 3:
          return this.w;
        default:
          throw new Error("index is out of range: " + index);
      }
    },
    clone: function() {
      return new this.constructor(this.x, this.y, this.z, this.w);
    },
    copy: function(v) {
      this.x = v.x;
      this.y = v.y;
      this.z = v.z;
      this.w = v.w !== void 0 ? v.w : 1;
      return this;
    },
    add: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
        return this.addVectors(v, w);
      }
      this.x += v.x;
      this.y += v.y;
      this.z += v.z;
      this.w += v.w;
      return this;
    },
    addScalar: function(s2) {
      this.x += s2;
      this.y += s2;
      this.z += s2;
      this.w += s2;
      return this;
    },
    addVectors: function(a, b) {
      this.x = a.x + b.x;
      this.y = a.y + b.y;
      this.z = a.z + b.z;
      this.w = a.w + b.w;
      return this;
    },
    addScaledVector: function(v, s2) {
      this.x += v.x * s2;
      this.y += v.y * s2;
      this.z += v.z * s2;
      this.w += v.w * s2;
      return this;
    },
    sub: function(v, w) {
      if (w !== void 0) {
        console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
        return this.subVectors(v, w);
      }
      this.x -= v.x;
      this.y -= v.y;
      this.z -= v.z;
      this.w -= v.w;
      return this;
    },
    subScalar: function(s2) {
      this.x -= s2;
      this.y -= s2;
      this.z -= s2;
      this.w -= s2;
      return this;
    },
    subVectors: function(a, b) {
      this.x = a.x - b.x;
      this.y = a.y - b.y;
      this.z = a.z - b.z;
      this.w = a.w - b.w;
      return this;
    },
    multiplyScalar: function(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      this.w *= scalar;
      return this;
    },
    applyMatrix4: function(m) {
      var x = this.x, y = this.y, z = this.z, w = this.w;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
      this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
      return this;
    },
    divideScalar: function(scalar) {
      return this.multiplyScalar(1 / scalar);
    },
    setAxisAngleFromQuaternion: function(q2) {
      this.w = 2 * Math.acos(q2.w);
      var s2 = Math.sqrt(1 - q2.w * q2.w);
      if (s2 < 1e-4) {
        this.x = 1;
        this.y = 0;
        this.z = 0;
      } else {
        this.x = q2.x / s2;
        this.y = q2.y / s2;
        this.z = q2.z / s2;
      }
      return this;
    },
    setAxisAngleFromRotationMatrix: function(m) {
      var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
          this.set(1, 0, 0, 0);
          return this;
        }
        angle = Math.PI;
        var xx = (m11 + 1) / 2;
        var yy = (m22 + 1) / 2;
        var zz = (m33 + 1) / 2;
        var xy = (m12 + m21) / 4;
        var xz = (m13 + m31) / 4;
        var yz = (m23 + m32) / 4;
        if (xx > yy && xx > zz) {
          if (xx < epsilon) {
            x = 0;
            y = 0.707106781;
            z = 0.707106781;
          } else {
            x = Math.sqrt(xx);
            y = xy / x;
            z = xz / x;
          }
        } else if (yy > zz) {
          if (yy < epsilon) {
            x = 0.707106781;
            y = 0;
            z = 0.707106781;
          } else {
            y = Math.sqrt(yy);
            x = xy / y;
            z = yz / y;
          }
        } else {
          if (zz < epsilon) {
            x = 0.707106781;
            y = 0.707106781;
            z = 0;
          } else {
            z = Math.sqrt(zz);
            x = xz / z;
            y = yz / z;
          }
        }
        this.set(x, y, z, angle);
        return this;
      }
      var s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
      if (Math.abs(s2) < 1e-3)
        s2 = 1;
      this.x = (m32 - m23) / s2;
      this.y = (m13 - m31) / s2;
      this.z = (m21 - m12) / s2;
      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
      return this;
    },
    min: function(v) {
      this.x = Math.min(this.x, v.x);
      this.y = Math.min(this.y, v.y);
      this.z = Math.min(this.z, v.z);
      this.w = Math.min(this.w, v.w);
      return this;
    },
    max: function(v) {
      this.x = Math.max(this.x, v.x);
      this.y = Math.max(this.y, v.y);
      this.z = Math.max(this.z, v.z);
      this.w = Math.max(this.w, v.w);
      return this;
    },
    clamp: function(min, max) {
      this.x = Math.max(min.x, Math.min(max.x, this.x));
      this.y = Math.max(min.y, Math.min(max.y, this.y));
      this.z = Math.max(min.z, Math.min(max.z, this.z));
      this.w = Math.max(min.w, Math.min(max.w, this.w));
      return this;
    },
    clampScalar: function() {
      var min, max;
      return function clampScalar(minVal, maxVal) {
        if (min === void 0) {
          min = new Vector4();
          max = new Vector4();
        }
        min.set(minVal, minVal, minVal, minVal);
        max.set(maxVal, maxVal, maxVal, maxVal);
        return this.clamp(min, max);
      };
    }(),
    clampLength: function(min, max) {
      var length = this.length();
      return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
    },
    floor: function() {
      this.x = Math.floor(this.x);
      this.y = Math.floor(this.y);
      this.z = Math.floor(this.z);
      this.w = Math.floor(this.w);
      return this;
    },
    ceil: function() {
      this.x = Math.ceil(this.x);
      this.y = Math.ceil(this.y);
      this.z = Math.ceil(this.z);
      this.w = Math.ceil(this.w);
      return this;
    },
    round: function() {
      this.x = Math.round(this.x);
      this.y = Math.round(this.y);
      this.z = Math.round(this.z);
      this.w = Math.round(this.w);
      return this;
    },
    roundToZero: function() {
      this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
      this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
      this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
      this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
      return this;
    },
    negate: function() {
      this.x = -this.x;
      this.y = -this.y;
      this.z = -this.z;
      this.w = -this.w;
      return this;
    },
    dot: function(v) {
      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
    },
    lengthSq: function() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
    },
    length: function() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
    },
    manhattanLength: function() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
    },
    normalize: function() {
      return this.divideScalar(this.length() || 1);
    },
    setLength: function(length) {
      return this.normalize().multiplyScalar(length);
    },
    lerp: function(v, alpha) {
      this.x += (v.x - this.x) * alpha;
      this.y += (v.y - this.y) * alpha;
      this.z += (v.z - this.z) * alpha;
      this.w += (v.w - this.w) * alpha;
      return this;
    },
    lerpVectors: function(v1, v2, alpha) {
      return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
    },
    equals: function(v) {
      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      this.x = array[offset];
      this.y = array[offset + 1];
      this.z = array[offset + 2];
      this.w = array[offset + 3];
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this.x;
      array[offset + 1] = this.y;
      array[offset + 2] = this.z;
      array[offset + 3] = this.w;
      return array;
    },
    fromBufferAttribute: function(attribute, index, offset) {
      if (offset !== void 0) {
        console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
      }
      this.x = attribute.getX(index);
      this.y = attribute.getY(index);
      this.z = attribute.getZ(index);
      this.w = attribute.getW(index);
      return this;
    }
  });
  function WebGLRenderTarget(width2, height2, options) {
    this.width = width2;
    this.height = height2;
    this.scissor = new Vector4(0, 0, width2, height2);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width2, height2);
    options = options || {};
    this.texture = new Texture(void 0, void 0, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;
    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : true;
    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;
  }
  WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: WebGLRenderTarget,
    isWebGLRenderTarget: true,
    setSize: function(width2, height2) {
      if (this.width !== width2 || this.height !== height2) {
        this.width = width2;
        this.height = height2;
        this.dispose();
      }
      this.viewport.set(0, 0, width2, height2);
      this.scissor.set(0, 0, width2, height2);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.width = source.width;
      this.height = source.height;
      this.viewport.copy(source.viewport);
      this.texture = source.texture.clone();
      this.depthBuffer = source.depthBuffer;
      this.stencilBuffer = source.stencilBuffer;
      this.depthTexture = source.depthTexture;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  function WebGLMultisampleRenderTarget(width2, height2, options) {
    WebGLRenderTarget.call(this, width2, height2, options);
    this.samples = 4;
  }
  WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
    constructor: WebGLMultisampleRenderTarget,
    isWebGLMultisampleRenderTarget: true,
    copy: function(source) {
      WebGLRenderTarget.prototype.copy.call(this, source);
      this.samples = source.samples;
      return this;
    }
  });
  function WebGLRenderTargetCube(width2, height2, options) {
    WebGLRenderTarget.call(this, width2, height2, options);
  }
  WebGLRenderTargetCube.prototype = Object.create(WebGLRenderTarget.prototype);
  WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
  WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
  function DataTexture(data, width2, height2, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { data, width: width2, height: height2 };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
  DataTexture.prototype = Object.create(Texture.prototype);
  DataTexture.prototype.constructor = DataTexture;
  DataTexture.prototype.isDataTexture = true;
  function Box3(min, max) {
    this.min = min !== void 0 ? min : new Vector3(Infinity, Infinity, Infinity);
    this.max = max !== void 0 ? max : new Vector3(-Infinity, -Infinity, -Infinity);
  }
  Object.assign(Box3.prototype, {
    isBox3: true,
    set: function(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromArray: function(array) {
      var minX = Infinity;
      var minY = Infinity;
      var minZ = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var x = array[i];
        var y = array[i + 1];
        var z = array[i + 2];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    },
    setFromBufferAttribute: function(attribute) {
      var minX = Infinity;
      var minY = Infinity;
      var minZ = Infinity;
      var maxX = -Infinity;
      var maxY = -Infinity;
      var maxZ = -Infinity;
      for (var i = 0, l = attribute.count; i < l; i++) {
        var x = attribute.getX(i);
        var y = attribute.getY(i);
        var z = attribute.getZ(i);
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (z < minZ)
          minZ = z;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
        if (z > maxZ)
          maxZ = z;
      }
      this.min.set(minX, minY, minZ);
      this.max.set(maxX, maxY, maxZ);
      return this;
    },
    setFromPoints: function(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    },
    setFromCenterAndSize: function() {
      var v1 = new Vector3();
      return function setFromCenterAndSize(center, size2) {
        var halfSize = v1.copy(size2).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
    }(),
    setFromObject: function(object) {
      this.makeEmpty();
      return this.expandByObject(object);
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = this.min.z = Infinity;
      this.max.x = this.max.y = this.max.z = -Infinity;
      return this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
    },
    getCenter: function(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getCenter() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getSize() target is now required");
        target = new Vector3();
      }
      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    expandByObject: function() {
      var scope, i, l;
      var v1 = new Vector3();
      function traverse(node) {
        var geometry2 = node.geometry;
        if (geometry2 !== void 0) {
          if (geometry2.isGeometry) {
            var vertices = geometry2.vertices;
            for (i = 0, l = vertices.length; i < l; i++) {
              v1.copy(vertices[i]);
              v1.applyMatrix4(node.matrixWorld);
              scope.expandByPoint(v1);
            }
          } else if (geometry2.isBufferGeometry) {
            var attribute = geometry2.attributes.position;
            if (attribute !== void 0) {
              for (i = 0, l = attribute.count; i < l; i++) {
                v1.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
                scope.expandByPoint(v1);
              }
            }
          }
        }
      }
      return function expandByObject(object) {
        scope = this;
        object.updateMatrixWorld(true);
        object.traverse(traverse);
        return this;
      };
    }(),
    containsPoint: function(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
    },
    containsBox: function(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
    },
    getParameter: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .getParameter() target is now required");
        target = new Vector3();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
    },
    intersectsBox: function(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
    },
    intersectsSphere: function() {
      var closestPoint = new Vector3();
      return function intersectsSphere(sphere) {
        this.clampPoint(sphere.center, closestPoint);
        return closestPoint.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      };
    }(),
    intersectsPlane: function(plane) {
      var min, max;
      if (plane.normal.x > 0) {
        min = plane.normal.x * this.min.x;
        max = plane.normal.x * this.max.x;
      } else {
        min = plane.normal.x * this.max.x;
        max = plane.normal.x * this.min.x;
      }
      if (plane.normal.y > 0) {
        min += plane.normal.y * this.min.y;
        max += plane.normal.y * this.max.y;
      } else {
        min += plane.normal.y * this.max.y;
        max += plane.normal.y * this.min.y;
      }
      if (plane.normal.z > 0) {
        min += plane.normal.z * this.min.z;
        max += plane.normal.z * this.max.z;
      } else {
        min += plane.normal.z * this.max.z;
        max += plane.normal.z * this.min.z;
      }
      return min <= -plane.constant && max >= -plane.constant;
    },
    intersectsTriangle: function() {
      var v0 = new Vector3();
      var v1 = new Vector3();
      var v2 = new Vector3();
      var f0 = new Vector3();
      var f1 = new Vector3();
      var f2 = new Vector3();
      var testAxis = new Vector3();
      var center = new Vector3();
      var extents = new Vector3();
      var triangleNormal = new Vector3();
      function satForAxes(axes) {
        var i, j;
        for (i = 0, j = axes.length - 3; i <= j; i += 3) {
          testAxis.fromArray(axes, i);
          var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
          var p0 = v0.dot(testAxis);
          var p1 = v1.dot(testAxis);
          var p2 = v2.dot(testAxis);
          if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
            return false;
          }
        }
        return true;
      }
      return function intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }
        this.getCenter(center);
        extents.subVectors(this.max, center);
        v0.subVectors(triangle.a, center);
        v1.subVectors(triangle.b, center);
        v2.subVectors(triangle.c, center);
        f0.subVectors(v1, v0);
        f1.subVectors(v2, v1);
        f2.subVectors(v0, v2);
        var axes = [
          0,
          -f0.z,
          f0.y,
          0,
          -f1.z,
          f1.y,
          0,
          -f2.z,
          f2.y,
          f0.z,
          0,
          -f0.x,
          f1.z,
          0,
          -f1.x,
          f2.z,
          0,
          -f2.x,
          -f0.y,
          f0.x,
          0,
          -f1.y,
          f1.x,
          0,
          -f2.y,
          f2.x,
          0
        ];
        if (!satForAxes(axes)) {
          return false;
        }
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
          return false;
        }
        triangleNormal.crossVectors(f0, f1);
        axes = [triangleNormal.x, triangleNormal.y, triangleNormal.z];
        return satForAxes(axes);
      };
    }(),
    clampPoint: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box3: .clampPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var v1 = new Vector3();
      return function distanceToPoint(point) {
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
    }(),
    getBoundingSphere: function() {
      var v1 = new Vector3();
      return function getBoundingSphere(target) {
        if (target === void 0) {
          console.error("THREE.Box3: .getBoundingSphere() target is now required");
        }
        this.getCenter(target.center);
        target.radius = this.getSize(v1).length() * 0.5;
        return target;
      };
    }(),
    intersect: function(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      if (this.isEmpty())
        this.makeEmpty();
      return this;
    },
    union: function(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    applyMatrix4: function() {
      var points = [
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3(),
        new Vector3()
      ];
      return function applyMatrix4(matrix) {
        if (this.isEmpty())
          return this;
        points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
        points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
        points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
        points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
        points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
        points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
        points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
        points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
        this.setFromPoints(points);
        return this;
      };
    }(),
    translate: function(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  });
  function Sphere(center, radius) {
    this.center = center !== void 0 ? center : new Vector3();
    this.radius = radius !== void 0 ? radius : 0;
  }
  Object.assign(Sphere.prototype, {
    set: function(center, radius) {
      this.center.copy(center);
      this.radius = radius;
      return this;
    },
    setFromPoints: function() {
      var box = new Box3();
      return function setFromPoints(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== void 0) {
          center.copy(optionalCenter);
        } else {
          box.setFromPoints(points).getCenter(center);
        }
        var maxRadiusSq = 0;
        for (var i = 0, il = points.length; i < il; i++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(sphere) {
      this.center.copy(sphere.center);
      this.radius = sphere.radius;
      return this;
    },
    empty: function() {
      return this.radius <= 0;
    },
    containsPoint: function(point) {
      return point.distanceToSquared(this.center) <= this.radius * this.radius;
    },
    distanceToPoint: function(point) {
      return point.distanceTo(this.center) - this.radius;
    },
    intersectsSphere: function(sphere) {
      var radiusSum = this.radius + sphere.radius;
      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
    },
    intersectsBox: function(box) {
      return box.intersectsSphere(this);
    },
    intersectsPlane: function(plane) {
      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
    },
    clampPoint: function(point, target) {
      var deltaLengthSq = this.center.distanceToSquared(point);
      if (target === void 0) {
        console.warn("THREE.Sphere: .clampPoint() target is now required");
        target = new Vector3();
      }
      target.copy(point);
      if (deltaLengthSq > this.radius * this.radius) {
        target.sub(this.center).normalize();
        target.multiplyScalar(this.radius).add(this.center);
      }
      return target;
    },
    getBoundingBox: function(target) {
      if (target === void 0) {
        console.warn("THREE.Sphere: .getBoundingBox() target is now required");
        target = new Box3();
      }
      target.set(this.center, this.center);
      target.expandByScalar(this.radius);
      return target;
    },
    applyMatrix4: function(matrix) {
      this.center.applyMatrix4(matrix);
      this.radius = this.radius * matrix.getMaxScaleOnAxis();
      return this;
    },
    translate: function(offset) {
      this.center.add(offset);
      return this;
    },
    equals: function(sphere) {
      return sphere.center.equals(this.center) && sphere.radius === this.radius;
    }
  });
  function Plane(normal, constant) {
    this.normal = normal !== void 0 ? normal : new Vector3(1, 0, 0);
    this.constant = constant !== void 0 ? constant : 0;
  }
  Object.assign(Plane.prototype, {
    set: function(normal, constant) {
      this.normal.copy(normal);
      this.constant = constant;
      return this;
    },
    setComponents: function(x, y, z, w) {
      this.normal.set(x, y, z);
      this.constant = w;
      return this;
    },
    setFromNormalAndCoplanarPoint: function(normal, point) {
      this.normal.copy(normal);
      this.constant = -point.dot(this.normal);
      return this;
    },
    setFromCoplanarPoints: function() {
      var v1 = new Vector3();
      var v2 = new Vector3();
      return function setFromCoplanarPoints(a, b, c) {
        var normal = v1.subVectors(c, b).cross(v2.subVectors(a, b)).normalize();
        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(plane) {
      this.normal.copy(plane.normal);
      this.constant = plane.constant;
      return this;
    },
    normalize: function() {
      var inverseNormalLength = 1 / this.normal.length();
      this.normal.multiplyScalar(inverseNormalLength);
      this.constant *= inverseNormalLength;
      return this;
    },
    negate: function() {
      this.constant *= -1;
      this.normal.negate();
      return this;
    },
    distanceToPoint: function(point) {
      return this.normal.dot(point) + this.constant;
    },
    distanceToSphere: function(sphere) {
      return this.distanceToPoint(sphere.center) - sphere.radius;
    },
    projectPoint: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .projectPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
    },
    intersectLine: function() {
      var v1 = new Vector3();
      return function intersectLine(line, target) {
        if (target === void 0) {
          console.warn("THREE.Plane: .intersectLine() target is now required");
          target = new Vector3();
        }
        var direction = line.delta(v1);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }
          return void 0;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return void 0;
        }
        return target.copy(direction).multiplyScalar(t).add(line.start);
      };
    }(),
    intersectsLine: function(line) {
      var startSign = this.distanceToPoint(line.start);
      var endSign = this.distanceToPoint(line.end);
      return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
    },
    intersectsBox: function(box) {
      return box.intersectsPlane(this);
    },
    intersectsSphere: function(sphere) {
      return sphere.intersectsPlane(this);
    },
    coplanarPoint: function(target) {
      if (target === void 0) {
        console.warn("THREE.Plane: .coplanarPoint() target is now required");
        target = new Vector3();
      }
      return target.copy(this.normal).multiplyScalar(-this.constant);
    },
    applyMatrix4: function() {
      var v1 = new Vector3();
      var m1 = new Matrix3();
      return function applyMatrix4(matrix, optionalNormalMatrix) {
        var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix(matrix);
        var referencePoint = this.coplanarPoint(v1).applyMatrix4(matrix);
        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      };
    }(),
    translate: function(offset) {
      this.constant -= offset.dot(this.normal);
      return this;
    },
    equals: function(plane) {
      return plane.normal.equals(this.normal) && plane.constant === this.constant;
    }
  });
  function Frustum(p0, p1, p2, p3, p4, p5) {
    this.planes = [
      p0 !== void 0 ? p0 : new Plane(),
      p1 !== void 0 ? p1 : new Plane(),
      p2 !== void 0 ? p2 : new Plane(),
      p3 !== void 0 ? p3 : new Plane(),
      p4 !== void 0 ? p4 : new Plane(),
      p5 !== void 0 ? p5 : new Plane()
    ];
  }
  Object.assign(Frustum.prototype, {
    set: function(p0, p1, p2, p3, p4, p5) {
      var planes = this.planes;
      planes[0].copy(p0);
      planes[1].copy(p1);
      planes[2].copy(p2);
      planes[3].copy(p3);
      planes[4].copy(p4);
      planes[5].copy(p5);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(frustum) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        planes[i].copy(frustum.planes[i]);
      }
      return this;
    },
    setFromMatrix: function(m) {
      var planes = this.planes;
      var me = m.elements;
      var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
      var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
      var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
      var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
      planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
      planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
      planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
      planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
      planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
      return this;
    },
    intersectsObject: function() {
      var sphere = new Sphere();
      return function intersectsObject(object) {
        var geometry2 = object.geometry;
        if (geometry2.boundingSphere === null)
          geometry2.computeBoundingSphere();
        sphere.copy(geometry2.boundingSphere).applyMatrix4(object.matrixWorld);
        return this.intersectsSphere(sphere);
      };
    }(),
    intersectsSprite: function() {
      var sphere = new Sphere();
      return function intersectsSprite(sprite) {
        sphere.center.set(0, 0, 0);
        sphere.radius = 0.7071067811865476;
        sphere.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(sphere);
      };
    }(),
    intersectsSphere: function(sphere) {
      var planes = this.planes;
      var center = sphere.center;
      var negRadius = -sphere.radius;
      for (var i = 0; i < 6; i++) {
        var distance = planes[i].distanceToPoint(center);
        if (distance < negRadius) {
          return false;
        }
      }
      return true;
    },
    intersectsBox: function() {
      var p2 = new Vector3();
      return function intersectsBox(box) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          var plane = planes[i];
          p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(p2) < 0) {
            return false;
          }
        }
        return true;
      };
    }(),
    containsPoint: function(point) {
      var planes = this.planes;
      for (var i = 0; i < 6; i++) {
        if (planes[i].distanceToPoint(point) < 0) {
          return false;
        }
      }
      return true;
    }
  });
  function Matrix4() {
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (arguments.length > 0) {
      console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
    }
  }
  Object.assign(Matrix4.prototype, {
    isMatrix4: true,
    set: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      var te = this.elements;
      te[0] = n11;
      te[4] = n12;
      te[8] = n13;
      te[12] = n14;
      te[1] = n21;
      te[5] = n22;
      te[9] = n23;
      te[13] = n24;
      te[2] = n31;
      te[6] = n32;
      te[10] = n33;
      te[14] = n34;
      te[3] = n41;
      te[7] = n42;
      te[11] = n43;
      te[15] = n44;
      return this;
    },
    identity: function() {
      this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    clone: function() {
      return new Matrix4().fromArray(this.elements);
    },
    copy: function(m) {
      var te = this.elements;
      var me = m.elements;
      te[0] = me[0];
      te[1] = me[1];
      te[2] = me[2];
      te[3] = me[3];
      te[4] = me[4];
      te[5] = me[5];
      te[6] = me[6];
      te[7] = me[7];
      te[8] = me[8];
      te[9] = me[9];
      te[10] = me[10];
      te[11] = me[11];
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      te[15] = me[15];
      return this;
    },
    copyPosition: function(m) {
      var te = this.elements, me = m.elements;
      te[12] = me[12];
      te[13] = me[13];
      te[14] = me[14];
      return this;
    },
    extractBasis: function(xAxis, yAxis, zAxis) {
      xAxis.setFromMatrixColumn(this, 0);
      yAxis.setFromMatrixColumn(this, 1);
      zAxis.setFromMatrixColumn(this, 2);
      return this;
    },
    makeBasis: function(xAxis, yAxis, zAxis) {
      this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
      return this;
    },
    extractRotation: function() {
      var v1 = new Vector3();
      return function extractRotation(m) {
        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / v1.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / v1.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / v1.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      };
    }(),
    makeRotationFromEuler: function(euler2) {
      if (!(euler2 && euler2.isEuler)) {
        console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
      }
      var te = this.elements;
      var x = euler2.x, y = euler2.y, z = euler2.z;
      var a = Math.cos(x), b = Math.sin(x);
      var c = Math.cos(y), d = Math.sin(y);
      var e = Math.cos(z), f = Math.sin(z);
      if (euler2.order === "XYZ") {
        var ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = -c * f;
        te[8] = d;
        te[1] = af + be * d;
        te[5] = ae - bf * d;
        te[9] = -b * c;
        te[2] = bf - ae * d;
        te[6] = be + af * d;
        te[10] = a * c;
      } else if (euler2.order === "YXZ") {
        var ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce + df * b;
        te[4] = de * b - cf;
        te[8] = a * d;
        te[1] = a * f;
        te[5] = a * e;
        te[9] = -b;
        te[2] = cf * b - de;
        te[6] = df + ce * b;
        te[10] = a * c;
      } else if (euler2.order === "ZXY") {
        var ce = c * e, cf = c * f, de = d * e, df = d * f;
        te[0] = ce - df * b;
        te[4] = -a * f;
        te[8] = de + cf * b;
        te[1] = cf + de * b;
        te[5] = a * e;
        te[9] = df - ce * b;
        te[2] = -a * d;
        te[6] = b;
        te[10] = a * c;
      } else if (euler2.order === "ZYX") {
        var ae = a * e, af = a * f, be = b * e, bf = b * f;
        te[0] = c * e;
        te[4] = be * d - af;
        te[8] = ae * d + bf;
        te[1] = c * f;
        te[5] = bf * d + ae;
        te[9] = af * d - be;
        te[2] = -d;
        te[6] = b * c;
        te[10] = a * c;
      } else if (euler2.order === "YZX") {
        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = bd - ac * f;
        te[8] = bc * f + ad;
        te[1] = f;
        te[5] = a * e;
        te[9] = -b * e;
        te[2] = -d * e;
        te[6] = ad * f + bc;
        te[10] = ac - bd * f;
      } else if (euler2.order === "XZY") {
        var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
        te[0] = c * e;
        te[4] = -f;
        te[8] = d * e;
        te[1] = ac * f + bd;
        te[5] = a * e;
        te[9] = ad * f - bc;
        te[2] = bc * f - ad;
        te[6] = b * e;
        te[10] = bd * f + ac;
      }
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return this;
    },
    makeRotationFromQuaternion: function() {
      var zero = new Vector3(0, 0, 0);
      var one = new Vector3(1, 1, 1);
      return function makeRotationFromQuaternion(q2) {
        return this.compose(zero, q2, one);
      };
    }(),
    lookAt: function() {
      var x = new Vector3();
      var y = new Vector3();
      var z = new Vector3();
      return function lookAt(eye, target, up) {
        var te = this.elements;
        z.subVectors(eye, target);
        if (z.lengthSq() === 0) {
          z.z = 1;
        }
        z.normalize();
        x.crossVectors(up, z);
        if (x.lengthSq() === 0) {
          if (Math.abs(up.z) === 1) {
            z.x += 1e-4;
          } else {
            z.z += 1e-4;
          }
          z.normalize();
          x.crossVectors(up, z);
        }
        x.normalize();
        y.crossVectors(z, x);
        te[0] = x.x;
        te[4] = y.x;
        te[8] = z.x;
        te[1] = x.y;
        te[5] = y.y;
        te[9] = z.y;
        te[2] = x.z;
        te[6] = y.z;
        te[10] = z.z;
        return this;
      };
    }(),
    multiply: function(m, n) {
      if (n !== void 0) {
        console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
        return this.multiplyMatrices(m, n);
      }
      return this.multiplyMatrices(this, m);
    },
    premultiply: function(m) {
      return this.multiplyMatrices(m, this);
    },
    multiplyMatrices: function(a, b) {
      var ae = a.elements;
      var be = b.elements;
      var te = this.elements;
      var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
      var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
      var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
      var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
      var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
      var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
      var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
      var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
      return this;
    },
    multiplyScalar: function(s2) {
      var te = this.elements;
      te[0] *= s2;
      te[4] *= s2;
      te[8] *= s2;
      te[12] *= s2;
      te[1] *= s2;
      te[5] *= s2;
      te[9] *= s2;
      te[13] *= s2;
      te[2] *= s2;
      te[6] *= s2;
      te[10] *= s2;
      te[14] *= s2;
      te[3] *= s2;
      te[7] *= s2;
      te[11] *= s2;
      te[15] *= s2;
      return this;
    },
    applyToBufferAttribute: function() {
      var v1 = new Vector3();
      return function applyToBufferAttribute(attribute) {
        for (var i = 0, l = attribute.count; i < l; i++) {
          v1.x = attribute.getX(i);
          v1.y = attribute.getY(i);
          v1.z = attribute.getZ(i);
          v1.applyMatrix4(this);
          attribute.setXYZ(i, v1.x, v1.y, v1.z);
        }
        return attribute;
      };
    }(),
    determinant: function() {
      var te = this.elements;
      var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
      var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
      var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
      var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
    },
    transpose: function() {
      var te = this.elements;
      var tmp2;
      tmp2 = te[1];
      te[1] = te[4];
      te[4] = tmp2;
      tmp2 = te[2];
      te[2] = te[8];
      te[8] = tmp2;
      tmp2 = te[6];
      te[6] = te[9];
      te[9] = tmp2;
      tmp2 = te[3];
      te[3] = te[12];
      te[12] = tmp2;
      tmp2 = te[7];
      te[7] = te[13];
      te[13] = tmp2;
      tmp2 = te[11];
      te[11] = te[14];
      te[14] = tmp2;
      return this;
    },
    setPosition: function(v) {
      var te = this.elements;
      te[12] = v.x;
      te[13] = v.y;
      te[14] = v.z;
      return this;
    },
    getInverse: function(m, throwOnDegenerate) {
      var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
      var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
      if (det === 0) {
        var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
        if (throwOnDegenerate === true) {
          throw new Error(msg);
        } else {
          console.warn(msg);
        }
        return this.identity();
      }
      var detInv = 1 / det;
      te[0] = t11 * detInv;
      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
      te[4] = t12 * detInv;
      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
      te[8] = t13 * detInv;
      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
      te[12] = t14 * detInv;
      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
      return this;
    },
    scale: function(v) {
      var te = this.elements;
      var x = v.x, y = v.y, z = v.z;
      te[0] *= x;
      te[4] *= y;
      te[8] *= z;
      te[1] *= x;
      te[5] *= y;
      te[9] *= z;
      te[2] *= x;
      te[6] *= y;
      te[10] *= z;
      te[3] *= x;
      te[7] *= y;
      te[11] *= z;
      return this;
    },
    getMaxScaleOnAxis: function() {
      var te = this.elements;
      var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
      var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
      var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
    },
    makeTranslation: function(x, y, z) {
      this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
      return this;
    },
    makeRotationX: function(theta) {
      var c = Math.cos(theta), s2 = Math.sin(theta);
      this.set(1, 0, 0, 0, 0, c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationY: function(theta) {
      var c = Math.cos(theta), s2 = Math.sin(theta);
      this.set(c, 0, s2, 0, 0, 1, 0, 0, -s2, 0, c, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationZ: function(theta) {
      var c = Math.cos(theta), s2 = Math.sin(theta);
      this.set(c, -s2, 0, 0, s2, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      return this;
    },
    makeRotationAxis: function(axis, angle) {
      var c = Math.cos(angle);
      var s2 = Math.sin(angle);
      var t = 1 - c;
      var x = axis.x, y = axis.y, z = axis.z;
      var tx = t * x, ty = t * y;
      this.set(tx * x + c, tx * y - s2 * z, tx * z + s2 * y, 0, tx * y + s2 * z, ty * y + c, ty * z - s2 * x, 0, tx * z - s2 * y, ty * z + s2 * x, t * z * z + c, 0, 0, 0, 0, 1);
      return this;
    },
    makeScale: function(x, y, z) {
      this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
      return this;
    },
    makeShear: function(x, y, z) {
      this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
      return this;
    },
    compose: function(position, quaternion, scale3) {
      var te = this.elements;
      var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
      var x2 = x + x, y2 = y + y, z2 = z + z;
      var xx = x * x2, xy = x * y2, xz = x * z2;
      var yy = y * y2, yz = y * z2, zz = z * z2;
      var wx = w * x2, wy = w * y2, wz = w * z2;
      var sx = scale3.x, sy = scale3.y, sz = scale3.z;
      te[0] = (1 - (yy + zz)) * sx;
      te[1] = (xy + wz) * sx;
      te[2] = (xz - wy) * sx;
      te[3] = 0;
      te[4] = (xy - wz) * sy;
      te[5] = (1 - (xx + zz)) * sy;
      te[6] = (yz + wx) * sy;
      te[7] = 0;
      te[8] = (xz + wy) * sz;
      te[9] = (yz - wx) * sz;
      te[10] = (1 - (xx + yy)) * sz;
      te[11] = 0;
      te[12] = position.x;
      te[13] = position.y;
      te[14] = position.z;
      te[15] = 1;
      return this;
    },
    decompose: function() {
      var vector = new Vector3();
      var matrix = new Matrix4();
      return function decompose(position, quaternion, scale3) {
        var te = this.elements;
        var sx = vector.set(te[0], te[1], te[2]).length();
        var sy = vector.set(te[4], te[5], te[6]).length();
        var sz = vector.set(te[8], te[9], te[10]).length();
        var det = this.determinant();
        if (det < 0)
          sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];
        matrix.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        matrix.elements[0] *= invSX;
        matrix.elements[1] *= invSX;
        matrix.elements[2] *= invSX;
        matrix.elements[4] *= invSY;
        matrix.elements[5] *= invSY;
        matrix.elements[6] *= invSY;
        matrix.elements[8] *= invSZ;
        matrix.elements[9] *= invSZ;
        matrix.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(matrix);
        scale3.x = sx;
        scale3.y = sy;
        scale3.z = sz;
        return this;
      };
    }(),
    makePerspective: function(left, right, top, bottom, near, far) {
      if (far === void 0) {
        console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
      }
      var te = this.elements;
      var x = 2 * near / (right - left);
      var y = 2 * near / (top - bottom);
      var a = (right + left) / (right - left);
      var b = (top + bottom) / (top - bottom);
      var c = -(far + near) / (far - near);
      var d = -2 * far * near / (far - near);
      te[0] = x;
      te[4] = 0;
      te[8] = a;
      te[12] = 0;
      te[1] = 0;
      te[5] = y;
      te[9] = b;
      te[13] = 0;
      te[2] = 0;
      te[6] = 0;
      te[10] = c;
      te[14] = d;
      te[3] = 0;
      te[7] = 0;
      te[11] = -1;
      te[15] = 0;
      return this;
    },
    makeOrthographic: function(left, right, top, bottom, near, far) {
      var te = this.elements;
      var w = 1 / (right - left);
      var h = 1 / (top - bottom);
      var p2 = 1 / (far - near);
      var x = (right + left) * w;
      var y = (top + bottom) * h;
      var z = (far + near) * p2;
      te[0] = 2 * w;
      te[4] = 0;
      te[8] = 0;
      te[12] = -x;
      te[1] = 0;
      te[5] = 2 * h;
      te[9] = 0;
      te[13] = -y;
      te[2] = 0;
      te[6] = 0;
      te[10] = -2 * p2;
      te[14] = -z;
      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[15] = 1;
      return this;
    },
    equals: function(matrix) {
      var te = this.elements;
      var me = matrix.elements;
      for (var i = 0; i < 16; i++) {
        if (te[i] !== me[i])
          return false;
      }
      return true;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      for (var i = 0; i < 16; i++) {
        this.elements[i] = array[i + offset];
      }
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      var te = this.elements;
      array[offset] = te[0];
      array[offset + 1] = te[1];
      array[offset + 2] = te[2];
      array[offset + 3] = te[3];
      array[offset + 4] = te[4];
      array[offset + 5] = te[5];
      array[offset + 6] = te[6];
      array[offset + 7] = te[7];
      array[offset + 8] = te[8];
      array[offset + 9] = te[9];
      array[offset + 10] = te[10];
      array[offset + 11] = te[11];
      array[offset + 12] = te[12];
      array[offset + 13] = te[13];
      array[offset + 14] = te[14];
      array[offset + 15] = te[15];
      return array;
    }
  });
  var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
  var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
  var alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
  var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif";
  var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
  var begin_vertex = "vec3 transformed = vec3( position );";
  var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
  var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	return vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n#else\n	if( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n		return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n	}\n	return 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE  = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS  = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	return specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	vec3 F = F_Schlick( specularColor, dotNV );\n	vec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n	vec3 FssEss = F * brdf.x + brdf.y;\n	float Ess = brdf.x + brdf.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
  var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
  var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		if ( clipped ) discard;\n	#endif\n#endif";
  var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
  var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	varying vec3 vViewPosition;\n#endif";
  var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n	vViewPosition = - mvPosition.xyz;\n#endif";
  var color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";
  var color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
  var color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";
  var color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";
  var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}";
  var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif";
  var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = normalMatrix * objectTangent;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
  var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
  var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
  var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
  var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
  var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
  var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n	float maxComponent = max( max( value.r, value.g ), value.b );\n	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n	M = ceil( M * 255.0 ) / 255.0;\n	return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n	float maxRGB = max( value.r, max( value.g, value.b ) );\n	float D = max( maxRange / maxRGB, 1.0 );\n	D = min( floor( D ) / 255.0, 1.0 );\n	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n	vec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n	Xp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n	vec4 vResult;\n	vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n	float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n	vResult.w = fract( Le );\n	vResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n	return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n	float Le = value.z * 255.0 + value.w;\n	vec3 Xp_Y_XYZp;\n	Xp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n	Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n	Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n	vec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n	return vec4( max( vRGB, 0.0 ), 1.0 );\n}";
  var envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		reflectVec = normalize( reflectVec );\n		sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n		sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		reflectVec = normalize( reflectVec );\n		vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
  var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	uniform int maxMipLevel;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
  var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
  var envmap_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
  var fog_vertex = "#ifdef USE_FOG\n	fogDepth = -mvPosition.z;\n#endif";
  var fog_pars_vertex = "#ifdef USE_FOG\n	varying float fogDepth;\n#endif";
  var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
  var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float fogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
  var gradientmap_pars_fragment = "#ifdef TOON\n	uniform sampler2D gradientMap;\n	vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n		float dotNL = dot( normal, lightDirection );\n		vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n		#ifdef USE_GRADIENTMAP\n			return texture2D( gradientMap, coord ).rgb;\n		#else\n			return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n		#endif\n	}\n#endif";
  var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
  var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
  var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif";
  var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n		float shadowCameraNear;\n		float shadowCameraFar;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		directLight.color = pointLight.color;\n		directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n		directLight.visible = ( directLight.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( angleCos > spotLight.coneCos ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif";
  var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n			sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif";
  var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
  var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifdef TOON\n		vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	#else\n		float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n		vec3 irradiance = dotNL * directLight.color;\n	#endif\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)";
  var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";
  var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n	return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.specularRoughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	#ifndef STANDARD\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	#ifndef ENVMAP_TYPE_CUBE_UV\n		reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifndef STANDARD\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		float dotNL = dotNV;\n		float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n	#else\n		float clearCoatDHR = 0.0;\n	#endif\n	float clearCoatInv = 1.0 - clearCoatDHR;\n	#if defined( ENVMAP_TYPE_CUBE_UV )\n		vec3 singleScattering = vec3( 0.0 );\n		vec3 multiScattering = vec3( 0.0 );\n		vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n		BRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n		vec3 diffuse = material.diffuseColor;\n		reflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n		reflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n		reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n	#else\n		reflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#endif\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
  var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearCoatRadiance = vec3( 0.0 );\n#endif";
  var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n		irradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n	#ifndef STANDARD\n		clearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n	#endif\n#endif";
  var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";
  var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
  var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n#endif";
  var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
  var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n		gl_Position.z *= gl_Position.w;\n	#endif\n#endif";
  var map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif";
  var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
  var map_particle_fragment = "#ifdef USE_MAP\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	vec4 mapTexel = texture2D( map, uv );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
  var map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform mat3 uvTransform;\n	uniform sampler2D map;\n#endif";
  var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
  var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
  var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
  var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";
  var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif";
  var normal_fragment_begin = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			bitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n	#endif\n#endif";
  var normal_fragment_maps = "#ifdef USE_NORMALMAP\n	#ifdef OBJECTSPACE_NORMALMAP\n		normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		#ifdef FLIP_SIDED\n			normal = - normal;\n		#endif\n		#ifdef DOUBLE_SIDED\n			normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#endif\n		normal = normalize( normalMatrix * normal );\n	#else\n		#ifdef USE_TANGENT\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy = normalScale * mapN.xy;\n			normal = normalize( vTBN * mapN );\n		#else\n			normal = perturbNormal2Arb( -vViewPosition, normal );\n		#endif\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
  var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	#ifdef OBJECTSPACE_NORMALMAP\n		uniform mat3 normalMatrix;\n	#else\n		vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n			vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n			vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n			vec2 st0 = dFdx( vUv.st );\n			vec2 st1 = dFdy( vUv.st );\n			float scale = sign( st1.t * st0.s - st0.t * st1.s );\n			vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n			vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n			vec3 N = normalize( surf_norm );\n			mat3 tsn = mat3( S, T, N );\n			vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n			mapN.xy *= normalScale;\n			mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n			return normalize( tsn * mapN );\n		}\n	#endif\n#endif";
  var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
  var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
  var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
  var dithering_fragment = "#if defined( DITHERING )\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
  var dithering_pars_fragment = "#if defined( DITHERING )\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
  var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
  var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
  var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			shadow = (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
  var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif";
  var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif";
  var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	#pragma unroll_loop\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}";
  var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
  var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureSize;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureSize ) );\n			float y = floor( j / float( boneTextureSize ) );\n			float dx = 1.0 / float( boneTextureSize );\n			float dy = 1.0 / float( boneTextureSize );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif";
  var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
  var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
  var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
  var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
  var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
  var tonemapping_pars_fragment = "#ifndef saturate\n	#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
  var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";
  var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif";
  var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
  var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";
  var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";
  var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";
  var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n	vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
  var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
  var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = mapTexelToLinear( texColor );\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
  var depth_frag = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}";
  var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}";
  var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
  var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
  var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV;\n	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	vec4 texColor = texture2D( tEquirect, sampleUV );\n	gl_FragColor = mapTexelToLinear( texColor );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}";
  var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
  var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
  var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n		matcapColor = matcapTexelToLinear( matcapColor );\n	#else\n		vec4 matcapColor = vec4( 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#ifndef FLAT_SHADED\n		vNormal = normalize( transformedNormal );\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
  var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
  var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
  var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	varying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
  var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
  var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <fog_fragment>\n}";
  var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
  var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}";
  var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
  var ShaderChunk = {
    alphamap_fragment,
    alphamap_pars_fragment,
    alphatest_fragment,
    aomap_fragment,
    aomap_pars_fragment,
    begin_vertex,
    beginnormal_vertex,
    bsdfs,
    bumpmap_pars_fragment,
    clipping_planes_fragment,
    clipping_planes_pars_fragment,
    clipping_planes_pars_vertex,
    clipping_planes_vertex,
    color_fragment,
    color_pars_fragment,
    color_pars_vertex,
    color_vertex,
    common,
    cube_uv_reflection_fragment,
    defaultnormal_vertex,
    displacementmap_pars_vertex,
    displacementmap_vertex,
    emissivemap_fragment,
    emissivemap_pars_fragment,
    encodings_fragment,
    encodings_pars_fragment,
    envmap_fragment,
    envmap_pars_fragment,
    envmap_pars_vertex,
    envmap_physical_pars_fragment,
    envmap_vertex,
    fog_vertex,
    fog_pars_vertex,
    fog_fragment,
    fog_pars_fragment,
    gradientmap_pars_fragment,
    lightmap_fragment,
    lightmap_pars_fragment,
    lights_lambert_vertex,
    lights_pars_begin,
    lights_phong_fragment,
    lights_phong_pars_fragment,
    lights_physical_fragment,
    lights_physical_pars_fragment,
    lights_fragment_begin,
    lights_fragment_maps,
    lights_fragment_end,
    logdepthbuf_fragment,
    logdepthbuf_pars_fragment,
    logdepthbuf_pars_vertex,
    logdepthbuf_vertex,
    map_fragment,
    map_pars_fragment,
    map_particle_fragment,
    map_particle_pars_fragment,
    metalnessmap_fragment,
    metalnessmap_pars_fragment,
    morphnormal_vertex,
    morphtarget_pars_vertex,
    morphtarget_vertex,
    normal_fragment_begin,
    normal_fragment_maps,
    normalmap_pars_fragment,
    packing,
    premultiplied_alpha_fragment,
    project_vertex,
    dithering_fragment,
    dithering_pars_fragment,
    roughnessmap_fragment,
    roughnessmap_pars_fragment,
    shadowmap_pars_fragment,
    shadowmap_pars_vertex,
    shadowmap_vertex,
    shadowmask_pars_fragment,
    skinbase_vertex,
    skinning_pars_vertex,
    skinning_vertex,
    skinnormal_vertex,
    specularmap_fragment,
    specularmap_pars_fragment,
    tonemapping_fragment,
    tonemapping_pars_fragment,
    uv_pars_fragment,
    uv_pars_vertex,
    uv_vertex,
    uv2_pars_fragment,
    uv2_pars_vertex,
    uv2_vertex,
    worldpos_vertex,
    background_frag,
    background_vert,
    cube_frag,
    cube_vert,
    depth_frag,
    depth_vert,
    distanceRGBA_frag,
    distanceRGBA_vert,
    equirect_frag,
    equirect_vert,
    linedashed_frag,
    linedashed_vert,
    meshbasic_frag,
    meshbasic_vert,
    meshlambert_frag,
    meshlambert_vert,
    meshmatcap_frag,
    meshmatcap_vert,
    meshphong_frag,
    meshphong_vert,
    meshphysical_frag,
    meshphysical_vert,
    normal_frag,
    normal_vert,
    points_frag,
    points_vert,
    shadow_frag,
    shadow_vert,
    sprite_frag,
    sprite_vert
  };
  function cloneUniforms(src) {
    var dst = {};
    for (var u in src) {
      dst[u] = {};
      for (var p2 in src[u]) {
        var property = src[u][p2];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
          dst[u][p2] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p2] = property.slice();
        } else {
          dst[u][p2] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    var merged = {};
    for (var u = 0; u < uniforms.length; u++) {
      var tmp2 = cloneUniforms(uniforms[u]);
      for (var p2 in tmp2) {
        merged[p2] = tmp2[p2];
      }
    }
    return merged;
  }
  var ColorKeywords = {
    "aliceblue": 15792383,
    "antiquewhite": 16444375,
    "aqua": 65535,
    "aquamarine": 8388564,
    "azure": 15794175,
    "beige": 16119260,
    "bisque": 16770244,
    "black": 0,
    "blanchedalmond": 16772045,
    "blue": 255,
    "blueviolet": 9055202,
    "brown": 10824234,
    "burlywood": 14596231,
    "cadetblue": 6266528,
    "chartreuse": 8388352,
    "chocolate": 13789470,
    "coral": 16744272,
    "cornflowerblue": 6591981,
    "cornsilk": 16775388,
    "crimson": 14423100,
    "cyan": 65535,
    "darkblue": 139,
    "darkcyan": 35723,
    "darkgoldenrod": 12092939,
    "darkgray": 11119017,
    "darkgreen": 25600,
    "darkgrey": 11119017,
    "darkkhaki": 12433259,
    "darkmagenta": 9109643,
    "darkolivegreen": 5597999,
    "darkorange": 16747520,
    "darkorchid": 10040012,
    "darkred": 9109504,
    "darksalmon": 15308410,
    "darkseagreen": 9419919,
    "darkslateblue": 4734347,
    "darkslategray": 3100495,
    "darkslategrey": 3100495,
    "darkturquoise": 52945,
    "darkviolet": 9699539,
    "deeppink": 16716947,
    "deepskyblue": 49151,
    "dimgray": 6908265,
    "dimgrey": 6908265,
    "dodgerblue": 2003199,
    "firebrick": 11674146,
    "floralwhite": 16775920,
    "forestgreen": 2263842,
    "fuchsia": 16711935,
    "gainsboro": 14474460,
    "ghostwhite": 16316671,
    "gold": 16766720,
    "goldenrod": 14329120,
    "gray": 8421504,
    "green": 32768,
    "greenyellow": 11403055,
    "grey": 8421504,
    "honeydew": 15794160,
    "hotpink": 16738740,
    "indianred": 13458524,
    "indigo": 4915330,
    "ivory": 16777200,
    "khaki": 15787660,
    "lavender": 15132410,
    "lavenderblush": 16773365,
    "lawngreen": 8190976,
    "lemonchiffon": 16775885,
    "lightblue": 11393254,
    "lightcoral": 15761536,
    "lightcyan": 14745599,
    "lightgoldenrodyellow": 16448210,
    "lightgray": 13882323,
    "lightgreen": 9498256,
    "lightgrey": 13882323,
    "lightpink": 16758465,
    "lightsalmon": 16752762,
    "lightseagreen": 2142890,
    "lightskyblue": 8900346,
    "lightslategray": 7833753,
    "lightslategrey": 7833753,
    "lightsteelblue": 11584734,
    "lightyellow": 16777184,
    "lime": 65280,
    "limegreen": 3329330,
    "linen": 16445670,
    "magenta": 16711935,
    "maroon": 8388608,
    "mediumaquamarine": 6737322,
    "mediumblue": 205,
    "mediumorchid": 12211667,
    "mediumpurple": 9662683,
    "mediumseagreen": 3978097,
    "mediumslateblue": 8087790,
    "mediumspringgreen": 64154,
    "mediumturquoise": 4772300,
    "mediumvioletred": 13047173,
    "midnightblue": 1644912,
    "mintcream": 16121850,
    "mistyrose": 16770273,
    "moccasin": 16770229,
    "navajowhite": 16768685,
    "navy": 128,
    "oldlace": 16643558,
    "olive": 8421376,
    "olivedrab": 7048739,
    "orange": 16753920,
    "orangered": 16729344,
    "orchid": 14315734,
    "palegoldenrod": 15657130,
    "palegreen": 10025880,
    "paleturquoise": 11529966,
    "palevioletred": 14381203,
    "papayawhip": 16773077,
    "peachpuff": 16767673,
    "peru": 13468991,
    "pink": 16761035,
    "plum": 14524637,
    "powderblue": 11591910,
    "purple": 8388736,
    "rebeccapurple": 6697881,
    "red": 16711680,
    "rosybrown": 12357519,
    "royalblue": 4286945,
    "saddlebrown": 9127187,
    "salmon": 16416882,
    "sandybrown": 16032864,
    "seagreen": 3050327,
    "seashell": 16774638,
    "sienna": 10506797,
    "silver": 12632256,
    "skyblue": 8900331,
    "slateblue": 6970061,
    "slategray": 7372944,
    "slategrey": 7372944,
    "snow": 16775930,
    "springgreen": 65407,
    "steelblue": 4620980,
    "tan": 13808780,
    "teal": 32896,
    "thistle": 14204888,
    "tomato": 16737095,
    "turquoise": 4251856,
    "violet": 15631086,
    "wheat": 16113331,
    "white": 16777215,
    "whitesmoke": 16119285,
    "yellow": 16776960,
    "yellowgreen": 10145074
  };
  function Color(r, g, b) {
    if (g === void 0 && b === void 0) {
      return this.set(r);
    }
    return this.setRGB(r, g, b);
  }
  Object.assign(Color.prototype, {
    isColor: true,
    r: 1,
    g: 1,
    b: 1,
    set: function(value) {
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
      return this;
    },
    setScalar: function(scalar) {
      this.r = scalar;
      this.g = scalar;
      this.b = scalar;
      return this;
    },
    setHex: function(hex) {
      hex = Math.floor(hex);
      this.r = (hex >> 16 & 255) / 255;
      this.g = (hex >> 8 & 255) / 255;
      this.b = (hex & 255) / 255;
      return this;
    },
    setRGB: function(r, g, b) {
      this.r = r;
      this.g = g;
      this.b = b;
      return this;
    },
    setHSL: function() {
      function hue2rgb(p2, q2, t) {
        if (t < 0)
          t += 1;
        if (t > 1)
          t -= 1;
        if (t < 1 / 6)
          return p2 + (q2 - p2) * 6 * t;
        if (t < 1 / 2)
          return q2;
        if (t < 2 / 3)
          return p2 + (q2 - p2) * 6 * (2 / 3 - t);
        return p2;
      }
      return function setHSL(h, s2, l) {
        h = _Math.euclideanModulo(h, 1);
        s2 = _Math.clamp(s2, 0, 1);
        l = _Math.clamp(l, 0, 1);
        if (s2 === 0) {
          this.r = this.g = this.b = l;
        } else {
          var p2 = l <= 0.5 ? l * (1 + s2) : l + s2 - l * s2;
          var q2 = 2 * l - p2;
          this.r = hue2rgb(q2, p2, h + 1 / 3);
          this.g = hue2rgb(q2, p2, h);
          this.b = hue2rgb(q2, p2, h - 1 / 3);
        }
        return this;
      };
    }(),
    setStyle: function(style) {
      function handleAlpha(string) {
        if (string === void 0)
          return;
        if (parseFloat(string) < 1) {
          console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
        }
      }
      var m;
      if (m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)) {
        var color;
        var name = m[1];
        var components = m[2];
        switch (name) {
          case "rgb":
          case "rgba":
            if (color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(255, parseInt(color[1], 10)) / 255;
              this.g = Math.min(255, parseInt(color[2], 10)) / 255;
              this.b = Math.min(255, parseInt(color[3], 10)) / 255;
              handleAlpha(color[5]);
              return this;
            }
            if (color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              this.r = Math.min(100, parseInt(color[1], 10)) / 100;
              this.g = Math.min(100, parseInt(color[2], 10)) / 100;
              this.b = Math.min(100, parseInt(color[3], 10)) / 100;
              handleAlpha(color[5]);
              return this;
            }
            break;
          case "hsl":
          case "hsla":
            if (color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)) {
              var h = parseFloat(color[1]) / 360;
              var s2 = parseInt(color[2], 10) / 100;
              var l = parseInt(color[3], 10) / 100;
              handleAlpha(color[5]);
              return this.setHSL(h, s2, l);
            }
            break;
        }
      } else if (m = /^\#([A-Fa-f0-9]+)$/.exec(style)) {
        var hex = m[1];
        var size2 = hex.length;
        if (size2 === 3) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
          this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
          this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
          return this;
        } else if (size2 === 6) {
          this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
          this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
          this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
          return this;
        }
      }
      if (style && style.length > 0) {
        var hex = ColorKeywords[style];
        if (hex !== void 0) {
          this.setHex(hex);
        } else {
          console.warn("THREE.Color: Unknown color " + style);
        }
      }
      return this;
    },
    clone: function() {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function(color) {
      this.r = color.r;
      this.g = color.g;
      this.b = color.b;
      return this;
    },
    copyGammaToLinear: function(color, gammaFactor) {
      if (gammaFactor === void 0)
        gammaFactor = 2;
      this.r = Math.pow(color.r, gammaFactor);
      this.g = Math.pow(color.g, gammaFactor);
      this.b = Math.pow(color.b, gammaFactor);
      return this;
    },
    copyLinearToGamma: function(color, gammaFactor) {
      if (gammaFactor === void 0)
        gammaFactor = 2;
      var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
      this.r = Math.pow(color.r, safeInverse);
      this.g = Math.pow(color.g, safeInverse);
      this.b = Math.pow(color.b, safeInverse);
      return this;
    },
    convertGammaToLinear: function(gammaFactor) {
      this.copyGammaToLinear(this, gammaFactor);
      return this;
    },
    convertLinearToGamma: function(gammaFactor) {
      this.copyLinearToGamma(this, gammaFactor);
      return this;
    },
    copySRGBToLinear: function() {
      function SRGBToLinear(c) {
        return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
      }
      return function copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      };
    }(),
    copyLinearToSRGB: function() {
      function LinearToSRGB(c) {
        return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
      }
      return function copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      };
    }(),
    convertSRGBToLinear: function() {
      this.copySRGBToLinear(this);
      return this;
    },
    convertLinearToSRGB: function() {
      this.copyLinearToSRGB(this);
      return this;
    },
    getHex: function() {
      return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
    },
    getHexString: function() {
      return ("000000" + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function(target) {
      if (target === void 0) {
        console.warn("THREE.Color: .getHSL() target is now required");
        target = { h: 0, s: 0, l: 0 };
      }
      var r = this.r, g = this.g, b = this.b;
      var max = Math.max(r, g, b);
      var min = Math.min(r, g, b);
      var hue, saturation;
      var lightness = (min + max) / 2;
      if (min === max) {
        hue = 0;
        saturation = 0;
      } else {
        var delta = max - min;
        saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
        switch (max) {
          case r:
            hue = (g - b) / delta + (g < b ? 6 : 0);
            break;
          case g:
            hue = (b - r) / delta + 2;
            break;
          case b:
            hue = (r - g) / delta + 4;
            break;
        }
        hue /= 6;
      }
      target.h = hue;
      target.s = saturation;
      target.l = lightness;
      return target;
    },
    getStyle: function() {
      return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
    },
    offsetHSL: function() {
      var hsl = {};
      return function(h, s2, l) {
        this.getHSL(hsl);
        hsl.h += h;
        hsl.s += s2;
        hsl.l += l;
        this.setHSL(hsl.h, hsl.s, hsl.l);
        return this;
      };
    }(),
    add: function(color) {
      this.r += color.r;
      this.g += color.g;
      this.b += color.b;
      return this;
    },
    addColors: function(color1, color2) {
      this.r = color1.r + color2.r;
      this.g = color1.g + color2.g;
      this.b = color1.b + color2.b;
      return this;
    },
    addScalar: function(s2) {
      this.r += s2;
      this.g += s2;
      this.b += s2;
      return this;
    },
    sub: function(color) {
      this.r = Math.max(0, this.r - color.r);
      this.g = Math.max(0, this.g - color.g);
      this.b = Math.max(0, this.b - color.b);
      return this;
    },
    multiply: function(color) {
      this.r *= color.r;
      this.g *= color.g;
      this.b *= color.b;
      return this;
    },
    multiplyScalar: function(s2) {
      this.r *= s2;
      this.g *= s2;
      this.b *= s2;
      return this;
    },
    lerp: function(color, alpha) {
      this.r += (color.r - this.r) * alpha;
      this.g += (color.g - this.g) * alpha;
      this.b += (color.b - this.b) * alpha;
      return this;
    },
    lerpHSL: function() {
      var hslA = { h: 0, s: 0, l: 0 };
      var hslB = { h: 0, s: 0, l: 0 };
      return function lerpHSL(color, alpha) {
        this.getHSL(hslA);
        color.getHSL(hslB);
        var h = _Math.lerp(hslA.h, hslB.h, alpha);
        var s2 = _Math.lerp(hslA.s, hslB.s, alpha);
        var l = _Math.lerp(hslA.l, hslB.l, alpha);
        this.setHSL(h, s2, l);
        return this;
      };
    }(),
    equals: function(c) {
      return c.r === this.r && c.g === this.g && c.b === this.b;
    },
    fromArray: function(array, offset) {
      if (offset === void 0)
        offset = 0;
      this.r = array[offset];
      this.g = array[offset + 1];
      this.b = array[offset + 2];
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this.r;
      array[offset + 1] = this.g;
      array[offset + 2] = this.b;
      return array;
    },
    toJSON: function() {
      return this.getHex();
    }
  });
  var UniformsLib = {
    common: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() },
      alphaMap: { value: null }
    },
    specularmap: {
      specularMap: { value: null }
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      refractionRatio: { value: 0.98 },
      maxMipLevel: { value: 0 }
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 }
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 }
    },
    emissivemap: {
      emissiveMap: { value: null }
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpScale: { value: 1 }
    },
    normalmap: {
      normalMap: { value: null },
      normalScale: { value: new Vector2(1, 1) }
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 }
    },
    roughnessmap: {
      roughnessMap: { value: null }
    },
    metalnessmap: {
      metalnessMap: { value: null }
    },
    gradientmap: {
      gradientMap: { value: null }
    },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) }
    },
    lights: {
      ambientLightColor: { value: [] },
      directionalLights: { value: [], properties: {
        direction: {},
        color: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: { value: [], properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {}
      } },
      spotShadowMap: { value: [] },
      spotShadowMatrix: { value: [] },
      pointLights: { value: [], properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
        shadow: {},
        shadowBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {}
      } },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: { value: [], properties: {
        direction: {},
        skyColor: {},
        groundColor: {}
      } },
      rectAreaLights: { value: [], properties: {
        color: {},
        position: {},
        width: {},
        height: {}
      } }
    },
    points: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      uvTransform: { value: new Matrix3() }
    },
    sprite: {
      diffuse: { value: new Color(15658734) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      uvTransform: { value: new Matrix3() }
    }
  };
  var ShaderLib = {
    basic: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.meshbasic_vert,
      fragmentShader: ShaderChunk.meshbasic_frag
    },
    lambert: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) }
        }
      ]),
      vertexShader: ShaderChunk.meshlambert_vert,
      fragmentShader: ShaderChunk.meshlambert_frag
    },
    phong: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.specularmap,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.gradientmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 }
        }
      ]),
      vertexShader: ShaderChunk.meshphong_vert,
      fragmentShader: ShaderChunk.meshphong_frag
    },
    standard: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.envmap,
        UniformsLib.aomap,
        UniformsLib.lightmap,
        UniformsLib.emissivemap,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.roughnessmap,
        UniformsLib.metalnessmap,
        UniformsLib.fog,
        UniformsLib.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 0.5 },
          metalness: { value: 0.5 },
          envMapIntensity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.meshphysical_vert,
      fragmentShader: ShaderChunk.meshphysical_frag
    },
    matcap: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        UniformsLib.fog,
        {
          matcap: { value: null }
        }
      ]),
      vertexShader: ShaderChunk.meshmatcap_vert,
      fragmentShader: ShaderChunk.meshmatcap_frag
    },
    points: {
      uniforms: mergeUniforms([
        UniformsLib.points,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.points_vert,
      fragmentShader: ShaderChunk.points_frag
    },
    dashed: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 }
        }
      ]),
      vertexShader: ShaderChunk.linedashed_vert,
      fragmentShader: ShaderChunk.linedashed_frag
    },
    depth: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap
      ]),
      vertexShader: ShaderChunk.depth_vert,
      fragmentShader: ShaderChunk.depth_frag
    },
    normal: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.bumpmap,
        UniformsLib.normalmap,
        UniformsLib.displacementmap,
        {
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.normal_vert,
      fragmentShader: ShaderChunk.normal_frag
    },
    sprite: {
      uniforms: mergeUniforms([
        UniformsLib.sprite,
        UniformsLib.fog
      ]),
      vertexShader: ShaderChunk.sprite_vert,
      fragmentShader: ShaderChunk.sprite_frag
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null }
      },
      vertexShader: ShaderChunk.background_vert,
      fragmentShader: ShaderChunk.background_frag
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 }
      },
      vertexShader: ShaderChunk.cube_vert,
      fragmentShader: ShaderChunk.cube_frag
    },
    equirect: {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: ShaderChunk.equirect_vert,
      fragmentShader: ShaderChunk.equirect_frag
    },
    distanceRGBA: {
      uniforms: mergeUniforms([
        UniformsLib.common,
        UniformsLib.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 }
        }
      ]),
      vertexShader: ShaderChunk.distanceRGBA_vert,
      fragmentShader: ShaderChunk.distanceRGBA_frag
    },
    shadow: {
      uniforms: mergeUniforms([
        UniformsLib.lights,
        UniformsLib.fog,
        {
          color: { value: new Color(0) },
          opacity: { value: 1 }
        }
      ]),
      vertexShader: ShaderChunk.shadow_vert,
      fragmentShader: ShaderChunk.shadow_frag
    }
  };
  ShaderLib.physical = {
    uniforms: mergeUniforms([
      ShaderLib.standard.uniforms,
      {
        clearCoat: { value: 0 },
        clearCoatRoughness: { value: 0 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  };
  function WebGLAnimation() {
    var context2 = null;
    var isAnimating = false;
    var animationLoop = null;
    function onAnimationFrame(time2, frame) {
      if (isAnimating === false)
        return;
      animationLoop(time2, frame);
      context2.requestAnimationFrame(onAnimationFrame);
    }
    return {
      start: function() {
        if (isAnimating === true)
          return;
        if (animationLoop === null)
          return;
        context2.requestAnimationFrame(onAnimationFrame);
        isAnimating = true;
      },
      stop: function() {
        isAnimating = false;
      },
      setAnimationLoop: function(callback) {
        animationLoop = callback;
      },
      setContext: function(value) {
        context2 = value;
      }
    };
  }
  function WebGLAttributes(gl) {
    var buffers = /* @__PURE__ */ new WeakMap();
    function createBuffer(attribute, bufferType) {
      var array = attribute.array;
      var usage = attribute.dynamic ? 35048 : 35044;
      var buffer = gl.createBuffer();
      gl.bindBuffer(bufferType, buffer);
      gl.bufferData(bufferType, array, usage);
      attribute.onUploadCallback();
      var type = 5126;
      if (array instanceof Float32Array) {
        type = 5126;
      } else if (array instanceof Float64Array) {
        console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
      } else if (array instanceof Uint16Array) {
        type = 5123;
      } else if (array instanceof Int16Array) {
        type = 5122;
      } else if (array instanceof Uint32Array) {
        type = 5125;
      } else if (array instanceof Int32Array) {
        type = 5124;
      } else if (array instanceof Int8Array) {
        type = 5120;
      } else if (array instanceof Uint8Array) {
        type = 5121;
      }
      return {
        buffer,
        type,
        bytesPerElement: array.BYTES_PER_ELEMENT,
        version: attribute.version
      };
    }
    function updateBuffer(buffer, attribute, bufferType) {
      var array = attribute.array;
      var updateRange = attribute.updateRange;
      gl.bindBuffer(bufferType, buffer);
      if (attribute.dynamic === false) {
        gl.bufferData(bufferType, array, 35044);
      } else if (updateRange.count === -1) {
        gl.bufferSubData(bufferType, 0, array);
      } else if (updateRange.count === 0) {
        console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.");
      } else {
        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
        updateRange.count = -1;
      }
    }
    function get(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      return buffers.get(attribute);
    }
    function remove(attribute) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      var data = buffers.get(attribute);
      if (data) {
        gl.deleteBuffer(data.buffer);
        buffers.delete(attribute);
      }
    }
    function update3(attribute, bufferType) {
      if (attribute.isInterleavedBufferAttribute)
        attribute = attribute.data;
      var data = buffers.get(attribute);
      if (data === void 0) {
        buffers.set(attribute, createBuffer(attribute, bufferType));
      } else if (data.version < attribute.version) {
        updateBuffer(data.buffer, attribute, bufferType);
        data.version = attribute.version;
      }
    }
    return {
      get,
      remove,
      update: update3
    };
  }
  function Face3(a, b, c, normal, color, materialIndex) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = normal && normal.isVector3 ? normal : new Vector3();
    this.vertexNormals = Array.isArray(normal) ? normal : [];
    this.color = color && color.isColor ? color : new Color();
    this.vertexColors = Array.isArray(color) ? color : [];
    this.materialIndex = materialIndex !== void 0 ? materialIndex : 0;
  }
  Object.assign(Face3.prototype, {
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.a = source.a;
      this.b = source.b;
      this.c = source.c;
      this.normal.copy(source.normal);
      this.color.copy(source.color);
      this.materialIndex = source.materialIndex;
      for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
        this.vertexNormals[i] = source.vertexNormals[i].clone();
      }
      for (var i = 0, il = source.vertexColors.length; i < il; i++) {
        this.vertexColors[i] = source.vertexColors[i].clone();
      }
      return this;
    }
  });
  function Euler(x, y, z, order) {
    this._x = x || 0;
    this._y = y || 0;
    this._z = z || 0;
    this._order = order || Euler.DefaultOrder;
  }
  Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
  Euler.DefaultOrder = "XYZ";
  Object.defineProperties(Euler.prototype, {
    x: {
      get: function() {
        return this._x;
      },
      set: function(value) {
        this._x = value;
        this.onChangeCallback();
      }
    },
    y: {
      get: function() {
        return this._y;
      },
      set: function(value) {
        this._y = value;
        this.onChangeCallback();
      }
    },
    z: {
      get: function() {
        return this._z;
      },
      set: function(value) {
        this._z = value;
        this.onChangeCallback();
      }
    },
    order: {
      get: function() {
        return this._order;
      },
      set: function(value) {
        this._order = value;
        this.onChangeCallback();
      }
    }
  });
  Object.assign(Euler.prototype, {
    isEuler: true,
    set: function(x, y, z, order) {
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order || this._order;
      this.onChangeCallback();
      return this;
    },
    clone: function() {
      return new this.constructor(this._x, this._y, this._z, this._order);
    },
    copy: function(euler2) {
      this._x = euler2._x;
      this._y = euler2._y;
      this._z = euler2._z;
      this._order = euler2._order;
      this.onChangeCallback();
      return this;
    },
    setFromRotationMatrix: function(m, order, update3) {
      var clamp2 = _Math.clamp;
      var te = m.elements;
      var m11 = te[0], m12 = te[4], m13 = te[8];
      var m21 = te[1], m22 = te[5], m23 = te[9];
      var m31 = te[2], m32 = te[6], m33 = te[10];
      order = order || this._order;
      if (order === "XYZ") {
        this._y = Math.asin(clamp2(m13, -1, 1));
        if (Math.abs(m13) < 0.99999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
      } else if (order === "YXZ") {
        this._x = Math.asin(-clamp2(m23, -1, 1));
        if (Math.abs(m23) < 0.99999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
      } else if (order === "ZXY") {
        this._x = Math.asin(clamp2(m32, -1, 1));
        if (Math.abs(m32) < 0.99999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
      } else if (order === "ZYX") {
        this._y = Math.asin(-clamp2(m31, -1, 1));
        if (Math.abs(m31) < 0.99999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
      } else if (order === "YZX") {
        this._z = Math.asin(clamp2(m21, -1, 1));
        if (Math.abs(m21) < 0.99999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
      } else if (order === "XZY") {
        this._z = Math.asin(-clamp2(m12, -1, 1));
        if (Math.abs(m12) < 0.99999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
      } else {
        console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
      }
      this._order = order;
      if (update3 !== false)
        this.onChangeCallback();
      return this;
    },
    setFromQuaternion: function() {
      var matrix = new Matrix4();
      return function setFromQuaternion(q2, order, update3) {
        matrix.makeRotationFromQuaternion(q2);
        return this.setFromRotationMatrix(matrix, order, update3);
      };
    }(),
    setFromVector3: function(v, order) {
      return this.set(v.x, v.y, v.z, order || this._order);
    },
    reorder: function() {
      var q2 = new Quaternion();
      return function reorder(newOrder) {
        q2.setFromEuler(this);
        return this.setFromQuaternion(q2, newOrder);
      };
    }(),
    equals: function(euler2) {
      return euler2._x === this._x && euler2._y === this._y && euler2._z === this._z && euler2._order === this._order;
    },
    fromArray: function(array) {
      this._x = array[0];
      this._y = array[1];
      this._z = array[2];
      if (array[3] !== void 0)
        this._order = array[3];
      this.onChangeCallback();
      return this;
    },
    toArray: function(array, offset) {
      if (array === void 0)
        array = [];
      if (offset === void 0)
        offset = 0;
      array[offset] = this._x;
      array[offset + 1] = this._y;
      array[offset + 2] = this._z;
      array[offset + 3] = this._order;
      return array;
    },
    toVector3: function(optionalResult) {
      if (optionalResult) {
        return optionalResult.set(this._x, this._y, this._z);
      } else {
        return new Vector3(this._x, this._y, this._z);
      }
    },
    onChange: function(callback) {
      this.onChangeCallback = callback;
      return this;
    },
    onChangeCallback: function() {
    }
  });
  function Layers() {
    this.mask = 1 | 0;
  }
  Object.assign(Layers.prototype, {
    set: function(channel) {
      this.mask = 1 << channel | 0;
    },
    enable: function(channel) {
      this.mask |= 1 << channel | 0;
    },
    toggle: function(channel) {
      this.mask ^= 1 << channel | 0;
    },
    disable: function(channel) {
      this.mask &= ~(1 << channel | 0);
    },
    test: function(layers) {
      return (this.mask & layers.mask) !== 0;
    }
  });
  var object3DId = 0;
  function Object3D() {
    Object.defineProperty(this, "id", { value: object3DId++ });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = Object3D.DefaultUp.clone();
    var position = new Vector3();
    var rotation = new Euler();
    var quaternion = new Quaternion();
    var scale3 = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation.onChange(onRotationChange);
    quaternion.onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale3
      },
      modelViewMatrix: {
        value: new Matrix4()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.userData = {};
  }
  Object3D.DefaultUp = new Vector3(0, 1, 0);
  Object3D.DefaultMatrixAutoUpdate = true;
  Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Object3D,
    isObject3D: true,
    onBeforeRender: function() {
    },
    onAfterRender: function() {
    },
    applyMatrix: function(matrix) {
      this.matrix.multiplyMatrices(matrix, this.matrix);
      this.matrix.decompose(this.position, this.quaternion, this.scale);
    },
    applyQuaternion: function(q2) {
      this.quaternion.premultiply(q2);
      return this;
    },
    setRotationFromAxisAngle: function(axis, angle) {
      this.quaternion.setFromAxisAngle(axis, angle);
    },
    setRotationFromEuler: function(euler2) {
      this.quaternion.setFromEuler(euler2, true);
    },
    setRotationFromMatrix: function(m) {
      this.quaternion.setFromRotationMatrix(m);
    },
    setRotationFromQuaternion: function(q2) {
      this.quaternion.copy(q2);
    },
    rotateOnAxis: function() {
      var q1 = new Quaternion();
      return function rotateOnAxis(axis, angle) {
        q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(q1);
        return this;
      };
    }(),
    rotateOnWorldAxis: function() {
      var q1 = new Quaternion();
      return function rotateOnWorldAxis(axis, angle) {
        q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(q1);
        return this;
      };
    }(),
    rotateX: function() {
      var v1 = new Vector3(1, 0, 0);
      return function rotateX(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    rotateY: function() {
      var v1 = new Vector3(0, 1, 0);
      return function rotateY(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    rotateZ: function() {
      var v1 = new Vector3(0, 0, 1);
      return function rotateZ(angle) {
        return this.rotateOnAxis(v1, angle);
      };
    }(),
    translateOnAxis: function() {
      var v1 = new Vector3();
      return function translateOnAxis(axis, distance) {
        v1.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(v1.multiplyScalar(distance));
        return this;
      };
    }(),
    translateX: function() {
      var v1 = new Vector3(1, 0, 0);
      return function translateX(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    translateY: function() {
      var v1 = new Vector3(0, 1, 0);
      return function translateY(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    translateZ: function() {
      var v1 = new Vector3(0, 0, 1);
      return function translateZ(distance) {
        return this.translateOnAxis(v1, distance);
      };
    }(),
    localToWorld: function(vector) {
      return vector.applyMatrix4(this.matrixWorld);
    },
    worldToLocal: function() {
      var m1 = new Matrix4();
      return function worldToLocal(vector) {
        return vector.applyMatrix4(m1.getInverse(this.matrixWorld));
      };
    }(),
    lookAt: function() {
      var q1 = new Quaternion();
      var m1 = new Matrix4();
      var target = new Vector3();
      var position = new Vector3();
      return function lookAt(x, y, z) {
        if (x.isVector3) {
          target.copy(x);
        } else {
          target.set(x, y, z);
        }
        var parent = this.parent;
        this.updateWorldMatrix(true, false);
        position.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          m1.lookAt(position, target, this.up);
        } else {
          m1.lookAt(target, position, this.up);
        }
        this.quaternion.setFromRotationMatrix(m1);
        if (parent) {
          m1.extractRotation(parent.matrixWorld);
          q1.setFromRotationMatrix(m1);
          this.quaternion.premultiply(q1.inverse());
        }
      };
    }(),
    add: function(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.add(arguments[i]);
        }
        return this;
      }
      if (object === this) {
        console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
        return this;
      }
      if (object && object.isObject3D) {
        if (object.parent !== null) {
          object.parent.remove(object);
        }
        object.parent = this;
        object.dispatchEvent({ type: "added" });
        this.children.push(object);
      } else {
        console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
      }
      return this;
    },
    remove: function(object) {
      if (arguments.length > 1) {
        for (var i = 0; i < arguments.length; i++) {
          this.remove(arguments[i]);
        }
        return this;
      }
      var index = this.children.indexOf(object);
      if (index !== -1) {
        object.parent = null;
        object.dispatchEvent({ type: "removed" });
        this.children.splice(index, 1);
      }
      return this;
    },
    getObjectById: function(id) {
      return this.getObjectByProperty("id", id);
    },
    getObjectByName: function(name) {
      return this.getObjectByProperty("name", name);
    },
    getObjectByProperty: function(name, value) {
      if (this[name] === value)
        return this;
      for (var i = 0, l = this.children.length; i < l; i++) {
        var child = this.children[i];
        var object = child.getObjectByProperty(name, value);
        if (object !== void 0) {
          return object;
        }
      }
      return void 0;
    },
    getWorldPosition: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldPosition() target is now required");
        target = new Vector3();
      }
      this.updateMatrixWorld(true);
      return target.setFromMatrixPosition(this.matrixWorld);
    },
    getWorldQuaternion: function() {
      var position = new Vector3();
      var scale3 = new Vector3();
      return function getWorldQuaternion(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
          target = new Quaternion();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, target, scale3);
        return target;
      };
    }(),
    getWorldScale: function() {
      var position = new Vector3();
      var quaternion = new Quaternion();
      return function getWorldScale(target) {
        if (target === void 0) {
          console.warn("THREE.Object3D: .getWorldScale() target is now required");
          target = new Vector3();
        }
        this.updateMatrixWorld(true);
        this.matrixWorld.decompose(position, quaternion, target);
        return target;
      };
    }(),
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Object3D: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateMatrixWorld(true);
      var e = this.matrixWorld.elements;
      return target.set(e[8], e[9], e[10]).normalize();
    },
    raycast: function() {
    },
    traverse: function(callback) {
      callback(this);
      var children2 = this.children;
      for (var i = 0, l = children2.length; i < l; i++) {
        children2[i].traverse(callback);
      }
    },
    traverseVisible: function(callback) {
      if (this.visible === false)
        return;
      callback(this);
      var children2 = this.children;
      for (var i = 0, l = children2.length; i < l; i++) {
        children2[i].traverseVisible(callback);
      }
    },
    traverseAncestors: function(callback) {
      var parent = this.parent;
      if (parent !== null) {
        callback(parent);
        parent.traverseAncestors(callback);
      }
    },
    updateMatrix: function() {
      this.matrix.compose(this.position, this.quaternion, this.scale);
      this.matrixWorldNeedsUpdate = true;
    },
    updateMatrixWorld: function(force) {
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.matrixWorldNeedsUpdate || force) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
        this.matrixWorldNeedsUpdate = false;
        force = true;
      }
      var children2 = this.children;
      for (var i = 0, l = children2.length; i < l; i++) {
        children2[i].updateMatrixWorld(force);
      }
    },
    updateWorldMatrix: function(updateParents, updateChildren) {
      var parent = this.parent;
      if (updateParents === true && parent !== null) {
        parent.updateWorldMatrix(true, false);
      }
      if (this.matrixAutoUpdate)
        this.updateMatrix();
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      if (updateChildren === true) {
        var children2 = this.children;
        for (var i = 0, l = children2.length; i < l; i++) {
          children2[i].updateWorldMatrix(false, true);
        }
      }
    },
    toJSON: function(meta) {
      var isRootObject = meta === void 0 || typeof meta === "string";
      var output = {};
      if (isRootObject) {
        meta = {
          geometries: {},
          materials: {},
          textures: {},
          images: {},
          shapes: {}
        };
        output.metadata = {
          version: 4.5,
          type: "Object",
          generator: "Object3D.toJSON"
        };
      }
      var object = {};
      object.uuid = this.uuid;
      object.type = this.type;
      if (this.name !== "")
        object.name = this.name;
      if (this.castShadow === true)
        object.castShadow = true;
      if (this.receiveShadow === true)
        object.receiveShadow = true;
      if (this.visible === false)
        object.visible = false;
      if (this.frustumCulled === false)
        object.frustumCulled = false;
      if (this.renderOrder !== 0)
        object.renderOrder = this.renderOrder;
      if (JSON.stringify(this.userData) !== "{}")
        object.userData = this.userData;
      object.layers = this.layers.mask;
      object.matrix = this.matrix.toArray();
      if (this.matrixAutoUpdate === false)
        object.matrixAutoUpdate = false;
      if (this.isMesh && this.drawMode !== TrianglesDrawMode)
        object.drawMode = this.drawMode;
      function serialize(library, element2) {
        if (library[element2.uuid] === void 0) {
          library[element2.uuid] = element2.toJSON(meta);
        }
        return element2.uuid;
      }
      if (this.isMesh || this.isLine || this.isPoints) {
        object.geometry = serialize(meta.geometries, this.geometry);
        var parameters = this.geometry.parameters;
        if (parameters !== void 0 && parameters.shapes !== void 0) {
          var shapes = parameters.shapes;
          if (Array.isArray(shapes)) {
            for (var i = 0, l = shapes.length; i < l; i++) {
              var shape = shapes[i];
              serialize(meta.shapes, shape);
            }
          } else {
            serialize(meta.shapes, shapes);
          }
        }
      }
      if (this.material !== void 0) {
        if (Array.isArray(this.material)) {
          var uuids = [];
          for (var i = 0, l = this.material.length; i < l; i++) {
            uuids.push(serialize(meta.materials, this.material[i]));
          }
          object.material = uuids;
        } else {
          object.material = serialize(meta.materials, this.material);
        }
      }
      if (this.children.length > 0) {
        object.children = [];
        for (var i = 0; i < this.children.length; i++) {
          object.children.push(this.children[i].toJSON(meta).object);
        }
      }
      if (isRootObject) {
        var geometries = extractFromCache(meta.geometries);
        var materials = extractFromCache(meta.materials);
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        var shapes = extractFromCache(meta.shapes);
        if (geometries.length > 0)
          output.geometries = geometries;
        if (materials.length > 0)
          output.materials = materials;
        if (textures.length > 0)
          output.textures = textures;
        if (images.length > 0)
          output.images = images;
        if (shapes.length > 0)
          output.shapes = shapes;
      }
      output.object = object;
      return output;
      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var data = cache[key];
          delete data.metadata;
          values.push(data);
        }
        return values;
      }
    },
    clone: function(recursive) {
      return new this.constructor().copy(this, recursive);
    },
    copy: function(source, recursive) {
      if (recursive === void 0)
        recursive = true;
      this.name = source.name;
      this.up.copy(source.up);
      this.position.copy(source.position);
      this.quaternion.copy(source.quaternion);
      this.scale.copy(source.scale);
      this.matrix.copy(source.matrix);
      this.matrixWorld.copy(source.matrixWorld);
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
      this.layers.mask = source.layers.mask;
      this.visible = source.visible;
      this.castShadow = source.castShadow;
      this.receiveShadow = source.receiveShadow;
      this.frustumCulled = source.frustumCulled;
      this.renderOrder = source.renderOrder;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      if (recursive === true) {
        for (var i = 0; i < source.children.length; i++) {
          var child = source.children[i];
          this.add(child.clone());
        }
      }
      return this;
    }
  });
  var geometryId = 0;
  function Geometry() {
    Object.defineProperty(this, "id", { value: geometryId += 2 });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Geometry";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.elementsNeedUpdate = false;
    this.verticesNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.lineDistancesNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Geometry,
    isGeometry: true,
    applyMatrix: function(matrix) {
      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
      for (var i = 0, il = this.vertices.length; i < il; i++) {
        var vertex = this.vertices[i];
        vertex.applyMatrix4(matrix);
      }
      for (var i = 0, il = this.faces.length; i < il; i++) {
        var face = this.faces[i];
        face.normal.applyMatrix3(normalMatrix).normalize();
        for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
          face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
        }
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      this.verticesNeedUpdate = true;
      this.normalsNeedUpdate = true;
      return this;
    },
    rotateX: function() {
      var m1 = new Matrix4();
      return function rotateX(angle) {
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateY: function() {
      var m1 = new Matrix4();
      return function rotateY(angle) {
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateZ: function() {
      var m1 = new Matrix4();
      return function rotateZ(angle) {
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    translate: function() {
      var m1 = new Matrix4();
      return function translate(x, y, z) {
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    scale: function() {
      var m1 = new Matrix4();
      return function scale3(x, y, z) {
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    lookAt: function() {
      var obj = new Object3D();
      return function lookAt(vector) {
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
      };
    }(),
    fromBufferGeometry: function(geometry2) {
      var scope = this;
      var indices = geometry2.index !== null ? geometry2.index.array : void 0;
      var attributes = geometry2.attributes;
      var positions = attributes.position.array;
      var normals = attributes.normal !== void 0 ? attributes.normal.array : void 0;
      var colors = attributes.color !== void 0 ? attributes.color.array : void 0;
      var uvs = attributes.uv !== void 0 ? attributes.uv.array : void 0;
      var uvs2 = attributes.uv2 !== void 0 ? attributes.uv2.array : void 0;
      if (uvs2 !== void 0)
        this.faceVertexUvs[1] = [];
      for (var i = 0, j = 0; i < positions.length; i += 3, j += 2) {
        scope.vertices.push(new Vector3().fromArray(positions, i));
        if (colors !== void 0) {
          scope.colors.push(new Color().fromArray(colors, i));
        }
      }
      function addFace(a, b, c, materialIndex) {
        var vertexColors = colors === void 0 ? [] : [
          scope.colors[a].clone(),
          scope.colors[b].clone(),
          scope.colors[c].clone()
        ];
        var vertexNormals = normals === void 0 ? [] : [
          new Vector3().fromArray(normals, a * 3),
          new Vector3().fromArray(normals, b * 3),
          new Vector3().fromArray(normals, c * 3)
        ];
        var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
        scope.faces.push(face);
        if (uvs !== void 0) {
          scope.faceVertexUvs[0].push([
            new Vector2().fromArray(uvs, a * 2),
            new Vector2().fromArray(uvs, b * 2),
            new Vector2().fromArray(uvs, c * 2)
          ]);
        }
        if (uvs2 !== void 0) {
          scope.faceVertexUvs[1].push([
            new Vector2().fromArray(uvs2, a * 2),
            new Vector2().fromArray(uvs2, b * 2),
            new Vector2().fromArray(uvs2, c * 2)
          ]);
        }
      }
      var groups = geometry2.groups;
      if (groups.length > 0) {
        for (var i = 0; i < groups.length; i++) {
          var group = groups[i];
          var start2 = group.start;
          var count2 = group.count;
          for (var j = start2, jl = start2 + count2; j < jl; j += 3) {
            if (indices !== void 0) {
              addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
            } else {
              addFace(j, j + 1, j + 2, group.materialIndex);
            }
          }
        }
      } else {
        if (indices !== void 0) {
          for (var i = 0; i < indices.length; i += 3) {
            addFace(indices[i], indices[i + 1], indices[i + 2]);
          }
        } else {
          for (var i = 0; i < positions.length / 3; i += 3) {
            addFace(i, i + 1, i + 2);
          }
        }
      }
      this.computeFaceNormals();
      if (geometry2.boundingBox !== null) {
        this.boundingBox = geometry2.boundingBox.clone();
      }
      if (geometry2.boundingSphere !== null) {
        this.boundingSphere = geometry2.boundingSphere.clone();
      }
      return this;
    },
    center: function() {
      var offset = new Vector3();
      return function center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(offset).negate();
        this.translate(offset.x, offset.y, offset.z);
        return this;
      };
    }(),
    normalize: function() {
      this.computeBoundingSphere();
      var center = this.boundingSphere.center;
      var radius = this.boundingSphere.radius;
      var s2 = radius === 0 ? 1 : 1 / radius;
      var matrix = new Matrix4();
      matrix.set(s2, 0, 0, -s2 * center.x, 0, s2, 0, -s2 * center.y, 0, 0, s2, -s2 * center.z, 0, 0, 0, 1);
      this.applyMatrix(matrix);
      return this;
    },
    computeFaceNormals: function() {
      var cb = new Vector3(), ab = new Vector3();
      for (var f = 0, fl = this.faces.length; f < fl; f++) {
        var face = this.faces[f];
        var vA = this.vertices[face.a];
        var vB = this.vertices[face.b];
        var vC = this.vertices[face.c];
        cb.subVectors(vC, vB);
        ab.subVectors(vA, vB);
        cb.cross(ab);
        cb.normalize();
        face.normal.copy(cb);
      }
    },
    computeVertexNormals: function(areaWeighted) {
      if (areaWeighted === void 0)
        areaWeighted = true;
      var v, vl, f, fl, face, vertices;
      vertices = new Array(this.vertices.length);
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v] = new Vector3();
      }
      if (areaWeighted) {
        var vA, vB, vC;
        var cb = new Vector3(), ab = new Vector3();
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vA = this.vertices[face.a];
          vB = this.vertices[face.b];
          vC = this.vertices[face.c];
          cb.subVectors(vC, vB);
          ab.subVectors(vA, vB);
          cb.cross(ab);
          vertices[face.a].add(cb);
          vertices[face.b].add(cb);
          vertices[face.c].add(cb);
        }
      } else {
        this.computeFaceNormals();
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          vertices[face.a].add(face.normal);
          vertices[face.b].add(face.normal);
          vertices[face.c].add(face.normal);
        }
      }
      for (v = 0, vl = this.vertices.length; v < vl; v++) {
        vertices[v].normalize();
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        var vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(vertices[face.a]);
          vertexNormals[1].copy(vertices[face.b]);
          vertexNormals[2].copy(vertices[face.c]);
        } else {
          vertexNormals[0] = vertices[face.a].clone();
          vertexNormals[1] = vertices[face.b].clone();
          vertexNormals[2] = vertices[face.c].clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeFlatVertexNormals: function() {
      var f, fl, face;
      this.computeFaceNormals();
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        var vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          vertexNormals[0].copy(face.normal);
          vertexNormals[1].copy(face.normal);
          vertexNormals[2].copy(face.normal);
        } else {
          vertexNormals[0] = face.normal.clone();
          vertexNormals[1] = face.normal.clone();
          vertexNormals[2] = face.normal.clone();
        }
      }
      if (this.faces.length > 0) {
        this.normalsNeedUpdate = true;
      }
    },
    computeMorphNormals: function() {
      var i, il, f, fl, face;
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        if (!face.__originalFaceNormal) {
          face.__originalFaceNormal = face.normal.clone();
        } else {
          face.__originalFaceNormal.copy(face.normal);
        }
        if (!face.__originalVertexNormals)
          face.__originalVertexNormals = [];
        for (i = 0, il = face.vertexNormals.length; i < il; i++) {
          if (!face.__originalVertexNormals[i]) {
            face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
          } else {
            face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
          }
        }
      }
      var tmpGeo = new Geometry();
      tmpGeo.faces = this.faces;
      for (i = 0, il = this.morphTargets.length; i < il; i++) {
        if (!this.morphNormals[i]) {
          this.morphNormals[i] = {};
          this.morphNormals[i].faceNormals = [];
          this.morphNormals[i].vertexNormals = [];
          var dstNormalsFace = this.morphNormals[i].faceNormals;
          var dstNormalsVertex = this.morphNormals[i].vertexNormals;
          var faceNormal, vertexNormals;
          for (f = 0, fl = this.faces.length; f < fl; f++) {
            faceNormal = new Vector3();
            vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
            dstNormalsFace.push(faceNormal);
            dstNormalsVertex.push(vertexNormals);
          }
        }
        var morphNormals = this.morphNormals[i];
        tmpGeo.vertices = this.morphTargets[i].vertices;
        tmpGeo.computeFaceNormals();
        tmpGeo.computeVertexNormals();
        var faceNormal, vertexNormals;
        for (f = 0, fl = this.faces.length; f < fl; f++) {
          face = this.faces[f];
          faceNormal = morphNormals.faceNormals[f];
          vertexNormals = morphNormals.vertexNormals[f];
          faceNormal.copy(face.normal);
          vertexNormals.a.copy(face.vertexNormals[0]);
          vertexNormals.b.copy(face.vertexNormals[1]);
          vertexNormals.c.copy(face.vertexNormals[2]);
        }
      }
      for (f = 0, fl = this.faces.length; f < fl; f++) {
        face = this.faces[f];
        face.normal = face.__originalFaceNormal;
        face.vertexNormals = face.__originalVertexNormals;
      }
    },
    computeBoundingBox: function() {
      if (this.boundingBox === null) {
        this.boundingBox = new Box3();
      }
      this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new Sphere();
      }
      this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function(geometry2, matrix, materialIndexOffset) {
      if (!(geometry2 && geometry2.isGeometry)) {
        console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry2);
        return;
      }
      var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry2.vertices, faces1 = this.faces, faces2 = geometry2.faces, uvs1 = this.faceVertexUvs[0], uvs2 = geometry2.faceVertexUvs[0], colors1 = this.colors, colors2 = geometry2.colors;
      if (materialIndexOffset === void 0)
        materialIndexOffset = 0;
      if (matrix !== void 0) {
        normalMatrix = new Matrix3().getNormalMatrix(matrix);
      }
      for (var i = 0, il = vertices2.length; i < il; i++) {
        var vertex = vertices2[i];
        var vertexCopy = vertex.clone();
        if (matrix !== void 0)
          vertexCopy.applyMatrix4(matrix);
        vertices1.push(vertexCopy);
      }
      for (var i = 0, il = colors2.length; i < il; i++) {
        colors1.push(colors2[i].clone());
      }
      for (i = 0, il = faces2.length; i < il; i++) {
        var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
        faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
        faceCopy.normal.copy(face.normal);
        if (normalMatrix !== void 0) {
          faceCopy.normal.applyMatrix3(normalMatrix).normalize();
        }
        for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
          normal = faceVertexNormals[j].clone();
          if (normalMatrix !== void 0) {
            normal.applyMatrix3(normalMatrix).normalize();
          }
          faceCopy.vertexNormals.push(normal);
        }
        faceCopy.color.copy(face.color);
        for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
          color = faceVertexColors[j];
          faceCopy.vertexColors.push(color.clone());
        }
        faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
        faces1.push(faceCopy);
      }
      for (i = 0, il = uvs2.length; i < il; i++) {
        var uv = uvs2[i], uvCopy = [];
        if (uv === void 0) {
          continue;
        }
        for (var j = 0, jl = uv.length; j < jl; j++) {
          uvCopy.push(uv[j].clone());
        }
        uvs1.push(uvCopy);
      }
    },
    mergeMesh: function(mesh) {
      if (!(mesh && mesh.isMesh)) {
        console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
        return;
      }
      if (mesh.matrixAutoUpdate)
        mesh.updateMatrix();
      this.merge(mesh.geometry, mesh.matrix);
    },
    mergeVertices: function() {
      var verticesMap = {};
      var unique = [], changes = [];
      var v, key;
      var precisionPoints = 4;
      var precision = Math.pow(10, precisionPoints);
      var i, il, face;
      var indices, j, jl;
      for (i = 0, il = this.vertices.length; i < il; i++) {
        v = this.vertices[i];
        key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
        if (verticesMap[key] === void 0) {
          verticesMap[key] = i;
          unique.push(this.vertices[i]);
          changes[i] = unique.length - 1;
        } else {
          changes[i] = changes[verticesMap[key]];
        }
      }
      var faceIndicesToRemove = [];
      for (i = 0, il = this.faces.length; i < il; i++) {
        face = this.faces[i];
        face.a = changes[face.a];
        face.b = changes[face.b];
        face.c = changes[face.c];
        indices = [face.a, face.b, face.c];
        for (var n = 0; n < 3; n++) {
          if (indices[n] === indices[(n + 1) % 3]) {
            faceIndicesToRemove.push(i);
            break;
          }
        }
      }
      for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
        var idx = faceIndicesToRemove[i];
        this.faces.splice(idx, 1);
        for (j = 0, jl = this.faceVertexUvs.length; j < jl; j++) {
          this.faceVertexUvs[j].splice(idx, 1);
        }
      }
      var diff = this.vertices.length - unique.length;
      this.vertices = unique;
      return diff;
    },
    setFromPoints: function(points) {
      this.vertices = [];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function() {
      var faces = this.faces;
      var length = faces.length;
      for (var i = 0; i < length; i++) {
        faces[i]._id = i;
      }
      function materialIndexSort(a, b) {
        return a.materialIndex - b.materialIndex;
      }
      faces.sort(materialIndexSort);
      var uvs1 = this.faceVertexUvs[0];
      var uvs2 = this.faceVertexUvs[1];
      var newUvs1, newUvs2;
      if (uvs1 && uvs1.length === length)
        newUvs1 = [];
      if (uvs2 && uvs2.length === length)
        newUvs2 = [];
      for (var i = 0; i < length; i++) {
        var id = faces[i]._id;
        if (newUvs1)
          newUvs1.push(uvs1[id]);
        if (newUvs2)
          newUvs2.push(uvs2[id]);
      }
      if (newUvs1)
        this.faceVertexUvs[0] = newUvs1;
      if (newUvs2)
        this.faceVertexUvs[1] = newUvs2;
    },
    toJSON: function() {
      var data = {
        metadata: {
          version: 4.5,
          type: "Geometry",
          generator: "Geometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.parameters !== void 0) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      var vertices = [];
      for (var i = 0; i < this.vertices.length; i++) {
        var vertex = this.vertices[i];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
      var faces = [];
      var normals = [];
      var normalsHash = {};
      var colors = [];
      var colorsHash = {};
      var uvs = [];
      var uvsHash = {};
      for (var i = 0; i < this.faces.length; i++) {
        var face = this.faces[i];
        var hasMaterial = true;
        var hasFaceUv = false;
        var hasFaceVertexUv = this.faceVertexUvs[0][i] !== void 0;
        var hasFaceNormal = face.normal.length() > 0;
        var hasFaceVertexNormal = face.vertexNormals.length > 0;
        var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
        var hasFaceVertexColor = face.vertexColors.length > 0;
        var faceType = 0;
        faceType = setBit(faceType, 0, 0);
        faceType = setBit(faceType, 1, hasMaterial);
        faceType = setBit(faceType, 2, hasFaceUv);
        faceType = setBit(faceType, 3, hasFaceVertexUv);
        faceType = setBit(faceType, 4, hasFaceNormal);
        faceType = setBit(faceType, 5, hasFaceVertexNormal);
        faceType = setBit(faceType, 6, hasFaceColor);
        faceType = setBit(faceType, 7, hasFaceVertexColor);
        faces.push(faceType);
        faces.push(face.a, face.b, face.c);
        faces.push(face.materialIndex);
        if (hasFaceVertexUv) {
          var faceVertexUvs = this.faceVertexUvs[0][i];
          faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
        }
        if (hasFaceNormal) {
          faces.push(getNormalIndex(face.normal));
        }
        if (hasFaceVertexNormal) {
          var vertexNormals = face.vertexNormals;
          faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
        }
        if (hasFaceColor) {
          faces.push(getColorIndex(face.color));
        }
        if (hasFaceVertexColor) {
          var vertexColors = face.vertexColors;
          faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
        }
      }
      function setBit(value, position, enabled) {
        return enabled ? value | 1 << position : value & ~(1 << position);
      }
      function getNormalIndex(normal) {
        var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
        if (normalsHash[hash] !== void 0) {
          return normalsHash[hash];
        }
        normalsHash[hash] = normals.length / 3;
        normals.push(normal.x, normal.y, normal.z);
        return normalsHash[hash];
      }
      function getColorIndex(color) {
        var hash = color.r.toString() + color.g.toString() + color.b.toString();
        if (colorsHash[hash] !== void 0) {
          return colorsHash[hash];
        }
        colorsHash[hash] = colors.length;
        colors.push(color.getHex());
        return colorsHash[hash];
      }
      function getUvIndex(uv) {
        var hash = uv.x.toString() + uv.y.toString();
        if (uvsHash[hash] !== void 0) {
          return uvsHash[hash];
        }
        uvsHash[hash] = uvs.length / 2;
        uvs.push(uv.x, uv.y);
        return uvsHash[hash];
      }
      data.data = {};
      data.data.vertices = vertices;
      data.data.normals = normals;
      if (colors.length > 0)
        data.data.colors = colors;
      if (uvs.length > 0)
        data.data.uvs = [uvs];
      data.data.faces = faces;
      return data;
    },
    clone: function() {
      return new Geometry().copy(this);
    },
    copy: function(source) {
      var i, il, j, jl, k, kl;
      this.vertices = [];
      this.colors = [];
      this.faces = [];
      this.faceVertexUvs = [[]];
      this.morphTargets = [];
      this.morphNormals = [];
      this.skinWeights = [];
      this.skinIndices = [];
      this.lineDistances = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      var vertices = source.vertices;
      for (i = 0, il = vertices.length; i < il; i++) {
        this.vertices.push(vertices[i].clone());
      }
      var colors = source.colors;
      for (i = 0, il = colors.length; i < il; i++) {
        this.colors.push(colors[i].clone());
      }
      var faces = source.faces;
      for (i = 0, il = faces.length; i < il; i++) {
        this.faces.push(faces[i].clone());
      }
      for (i = 0, il = source.faceVertexUvs.length; i < il; i++) {
        var faceVertexUvs = source.faceVertexUvs[i];
        if (this.faceVertexUvs[i] === void 0) {
          this.faceVertexUvs[i] = [];
        }
        for (j = 0, jl = faceVertexUvs.length; j < jl; j++) {
          var uvs = faceVertexUvs[j], uvsCopy = [];
          for (k = 0, kl = uvs.length; k < kl; k++) {
            var uv = uvs[k];
            uvsCopy.push(uv.clone());
          }
          this.faceVertexUvs[i].push(uvsCopy);
        }
      }
      var morphTargets = source.morphTargets;
      for (i = 0, il = morphTargets.length; i < il; i++) {
        var morphTarget = {};
        morphTarget.name = morphTargets[i].name;
        if (morphTargets[i].vertices !== void 0) {
          morphTarget.vertices = [];
          for (j = 0, jl = morphTargets[i].vertices.length; j < jl; j++) {
            morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
          }
        }
        if (morphTargets[i].normals !== void 0) {
          morphTarget.normals = [];
          for (j = 0, jl = morphTargets[i].normals.length; j < jl; j++) {
            morphTarget.normals.push(morphTargets[i].normals[j].clone());
          }
        }
        this.morphTargets.push(morphTarget);
      }
      var morphNormals = source.morphNormals;
      for (i = 0, il = morphNormals.length; i < il; i++) {
        var morphNormal = {};
        if (morphNormals[i].vertexNormals !== void 0) {
          morphNormal.vertexNormals = [];
          for (j = 0, jl = morphNormals[i].vertexNormals.length; j < jl; j++) {
            var srcVertexNormal = morphNormals[i].vertexNormals[j];
            var destVertexNormal = {};
            destVertexNormal.a = srcVertexNormal.a.clone();
            destVertexNormal.b = srcVertexNormal.b.clone();
            destVertexNormal.c = srcVertexNormal.c.clone();
            morphNormal.vertexNormals.push(destVertexNormal);
          }
        }
        if (morphNormals[i].faceNormals !== void 0) {
          morphNormal.faceNormals = [];
          for (j = 0, jl = morphNormals[i].faceNormals.length; j < jl; j++) {
            morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
          }
        }
        this.morphNormals.push(morphNormal);
      }
      var skinWeights = source.skinWeights;
      for (i = 0, il = skinWeights.length; i < il; i++) {
        this.skinWeights.push(skinWeights[i].clone());
      }
      var skinIndices = source.skinIndices;
      for (i = 0, il = skinIndices.length; i < il; i++) {
        this.skinIndices.push(skinIndices[i].clone());
      }
      var lineDistances = source.lineDistances;
      for (i = 0, il = lineDistances.length; i < il; i++) {
        this.lineDistances.push(lineDistances[i]);
      }
      var boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      var boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.elementsNeedUpdate = source.elementsNeedUpdate;
      this.verticesNeedUpdate = source.verticesNeedUpdate;
      this.uvsNeedUpdate = source.uvsNeedUpdate;
      this.normalsNeedUpdate = source.normalsNeedUpdate;
      this.colorsNeedUpdate = source.colorsNeedUpdate;
      this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
      this.groupsNeedUpdate = source.groupsNeedUpdate;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  function BufferAttribute(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized === true;
    this.dynamic = false;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(BufferAttribute.prototype, {
    isBufferAttribute: true,
    onUploadCallback: function() {
    },
    setArray: function(array) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.count = array !== void 0 ? array.length / this.itemSize : 0;
      this.array = array;
      return this;
    },
    setDynamic: function(value) {
      this.dynamic = value;
      return this;
    },
    copy: function(source) {
      this.name = source.name;
      this.array = new source.array.constructor(source.array);
      this.itemSize = source.itemSize;
      this.count = source.count;
      this.normalized = source.normalized;
      this.dynamic = source.dynamic;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.itemSize;
      index2 *= attribute.itemSize;
      for (var i = 0, l = this.itemSize; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    copyArray: function(array) {
      this.array.set(array);
      return this;
    },
    copyColorsArray: function(colors) {
      var array = this.array, offset = 0;
      for (var i = 0, l = colors.length; i < l; i++) {
        var color = colors[i];
        if (color === void 0) {
          console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
          color = new Color();
        }
        array[offset++] = color.r;
        array[offset++] = color.g;
        array[offset++] = color.b;
      }
      return this;
    },
    copyVector2sArray: function(vectors) {
      var array = this.array, offset = 0;
      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
          vector = new Vector2();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
      }
      return this;
    },
    copyVector3sArray: function(vectors) {
      var array = this.array, offset = 0;
      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
          vector = new Vector3();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
      }
      return this;
    },
    copyVector4sArray: function(vectors) {
      var array = this.array, offset = 0;
      for (var i = 0, l = vectors.length; i < l; i++) {
        var vector = vectors[i];
        if (vector === void 0) {
          console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
          vector = new Vector4();
        }
        array[offset++] = vector.x;
        array[offset++] = vector.y;
        array[offset++] = vector.z;
        array[offset++] = vector.w;
      }
      return this;
    },
    set: function(value, offset) {
      if (offset === void 0)
        offset = 0;
      this.array.set(value, offset);
      return this;
    },
    getX: function(index) {
      return this.array[index * this.itemSize];
    },
    setX: function(index, x) {
      this.array[index * this.itemSize] = x;
      return this;
    },
    getY: function(index) {
      return this.array[index * this.itemSize + 1];
    },
    setY: function(index, y) {
      this.array[index * this.itemSize + 1] = y;
      return this;
    },
    getZ: function(index) {
      return this.array[index * this.itemSize + 2];
    },
    setZ: function(index, z) {
      this.array[index * this.itemSize + 2] = z;
      return this;
    },
    getW: function(index) {
      return this.array[index * this.itemSize + 3];
    },
    setW: function(index, w) {
      this.array[index * this.itemSize + 3] = w;
      return this;
    },
    setXY: function(index, x, y) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index *= this.itemSize;
      this.array[index + 0] = x;
      this.array[index + 1] = y;
      this.array[index + 2] = z;
      this.array[index + 3] = w;
      return this;
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    },
    clone: function() {
      return new this.constructor(this.array, this.itemSize).copy(this);
    }
  });
  function Int8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
  }
  Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
  function Uint8BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
  }
  Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
  function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
  }
  Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
  function Int16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
  }
  Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
  function Uint16BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
  }
  Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
  function Int32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
  }
  Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
  function Uint32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
  }
  Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
  function Float32BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
  }
  Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
  function Float64BufferAttribute(array, itemSize, normalized) {
    BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
  }
  Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
  Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
  function DirectGeometry() {
    this.vertices = [];
    this.normals = [];
    this.colors = [];
    this.uvs = [];
    this.uvs2 = [];
    this.groups = [];
    this.morphTargets = {};
    this.skinWeights = [];
    this.skinIndices = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.verticesNeedUpdate = false;
    this.normalsNeedUpdate = false;
    this.colorsNeedUpdate = false;
    this.uvsNeedUpdate = false;
    this.groupsNeedUpdate = false;
  }
  Object.assign(DirectGeometry.prototype, {
    computeGroups: function(geometry2) {
      var group;
      var groups = [];
      var materialIndex = void 0;
      var faces = geometry2.faces;
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        if (face.materialIndex !== materialIndex) {
          materialIndex = face.materialIndex;
          if (group !== void 0) {
            group.count = i * 3 - group.start;
            groups.push(group);
          }
          group = {
            start: i * 3,
            materialIndex
          };
        }
      }
      if (group !== void 0) {
        group.count = i * 3 - group.start;
        groups.push(group);
      }
      this.groups = groups;
    },
    fromGeometry: function(geometry2) {
      var faces = geometry2.faces;
      var vertices = geometry2.vertices;
      var faceVertexUvs = geometry2.faceVertexUvs;
      var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
      var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
      var morphTargets = geometry2.morphTargets;
      var morphTargetsLength = morphTargets.length;
      var morphTargetsPosition;
      if (morphTargetsLength > 0) {
        morphTargetsPosition = [];
        for (var i = 0; i < morphTargetsLength; i++) {
          morphTargetsPosition[i] = {
            name: morphTargets[i].name,
            data: []
          };
        }
        this.morphTargets.position = morphTargetsPosition;
      }
      var morphNormals = geometry2.morphNormals;
      var morphNormalsLength = morphNormals.length;
      var morphTargetsNormal;
      if (morphNormalsLength > 0) {
        morphTargetsNormal = [];
        for (var i = 0; i < morphNormalsLength; i++) {
          morphTargetsNormal[i] = {
            name: morphNormals[i].name,
            data: []
          };
        }
        this.morphTargets.normal = morphTargetsNormal;
      }
      var skinIndices = geometry2.skinIndices;
      var skinWeights = geometry2.skinWeights;
      var hasSkinIndices = skinIndices.length === vertices.length;
      var hasSkinWeights = skinWeights.length === vertices.length;
      if (vertices.length > 0 && faces.length === 0) {
        console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
      }
      for (var i = 0; i < faces.length; i++) {
        var face = faces[i];
        this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
        var vertexNormals = face.vertexNormals;
        if (vertexNormals.length === 3) {
          this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
        } else {
          var normal = face.normal;
          this.normals.push(normal, normal, normal);
        }
        var vertexColors = face.vertexColors;
        if (vertexColors.length === 3) {
          this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
        } else {
          var color = face.color;
          this.colors.push(color, color, color);
        }
        if (hasFaceVertexUv === true) {
          var vertexUvs = faceVertexUvs[0][i];
          if (vertexUvs !== void 0) {
            this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
            this.uvs.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        if (hasFaceVertexUv2 === true) {
          var vertexUvs = faceVertexUvs[1][i];
          if (vertexUvs !== void 0) {
            this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
          } else {
            console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
            this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
          }
        }
        for (var j = 0; j < morphTargetsLength; j++) {
          var morphTarget = morphTargets[j].vertices;
          morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
        }
        for (var j = 0; j < morphNormalsLength; j++) {
          var morphNormal = morphNormals[j].vertexNormals[i];
          morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
        }
        if (hasSkinIndices) {
          this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
        }
        if (hasSkinWeights) {
          this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
        }
      }
      this.computeGroups(geometry2);
      this.verticesNeedUpdate = geometry2.verticesNeedUpdate;
      this.normalsNeedUpdate = geometry2.normalsNeedUpdate;
      this.colorsNeedUpdate = geometry2.colorsNeedUpdate;
      this.uvsNeedUpdate = geometry2.uvsNeedUpdate;
      this.groupsNeedUpdate = geometry2.groupsNeedUpdate;
      return this;
    }
  });
  function arrayMax(array) {
    if (array.length === 0)
      return -Infinity;
    var max = array[0];
    for (var i = 1, l = array.length; i < l; ++i) {
      if (array[i] > max)
        max = array[i];
    }
    return max;
  }
  var bufferGeometryId = 1;
  function BufferGeometry() {
    Object.defineProperty(this, "id", { value: bufferGeometryId += 2 });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: BufferGeometry,
    isBufferGeometry: true,
    getIndex: function() {
      return this.index;
    },
    setIndex: function(index) {
      if (Array.isArray(index)) {
        this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
      } else {
        this.index = index;
      }
    },
    addAttribute: function(name, attribute) {
      if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
        console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
        return this.addAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
      }
      if (name === "index") {
        console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
        this.setIndex(attribute);
        return this;
      }
      this.attributes[name] = attribute;
      return this;
    },
    getAttribute: function(name) {
      return this.attributes[name];
    },
    removeAttribute: function(name) {
      delete this.attributes[name];
      return this;
    },
    addGroup: function(start2, count2, materialIndex) {
      this.groups.push({
        start: start2,
        count: count2,
        materialIndex: materialIndex !== void 0 ? materialIndex : 0
      });
    },
    clearGroups: function() {
      this.groups = [];
    },
    setDrawRange: function(start2, count2) {
      this.drawRange.start = start2;
      this.drawRange.count = count2;
    },
    applyMatrix: function(matrix) {
      var position = this.attributes.position;
      if (position !== void 0) {
        matrix.applyToBufferAttribute(position);
        position.needsUpdate = true;
      }
      var normal = this.attributes.normal;
      if (normal !== void 0) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normalMatrix.applyToBufferAttribute(normal);
        normal.needsUpdate = true;
      }
      var tangent = this.attributes.tangent;
      if (tangent !== void 0) {
        var normalMatrix = new Matrix3().getNormalMatrix(matrix);
        normalMatrix.applyToBufferAttribute(tangent);
        tangent.needsUpdate = true;
      }
      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }
      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }
      return this;
    },
    rotateX: function() {
      var m1 = new Matrix4();
      return function rotateX(angle) {
        m1.makeRotationX(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateY: function() {
      var m1 = new Matrix4();
      return function rotateY(angle) {
        m1.makeRotationY(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    rotateZ: function() {
      var m1 = new Matrix4();
      return function rotateZ(angle) {
        m1.makeRotationZ(angle);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    translate: function() {
      var m1 = new Matrix4();
      return function translate(x, y, z) {
        m1.makeTranslation(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    scale: function() {
      var m1 = new Matrix4();
      return function scale3(x, y, z) {
        m1.makeScale(x, y, z);
        this.applyMatrix(m1);
        return this;
      };
    }(),
    lookAt: function() {
      var obj = new Object3D();
      return function lookAt(vector) {
        obj.lookAt(vector);
        obj.updateMatrix();
        this.applyMatrix(obj.matrix);
      };
    }(),
    center: function() {
      var offset = new Vector3();
      return function center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(offset).negate();
        this.translate(offset.x, offset.y, offset.z);
        return this;
      };
    }(),
    setFromObject: function(object) {
      var geometry2 = object.geometry;
      if (object.isPoints || object.isLine) {
        var positions = new Float32BufferAttribute(geometry2.vertices.length * 3, 3);
        var colors = new Float32BufferAttribute(geometry2.colors.length * 3, 3);
        this.addAttribute("position", positions.copyVector3sArray(geometry2.vertices));
        this.addAttribute("color", colors.copyColorsArray(geometry2.colors));
        if (geometry2.lineDistances && geometry2.lineDistances.length === geometry2.vertices.length) {
          var lineDistances = new Float32BufferAttribute(geometry2.lineDistances.length, 1);
          this.addAttribute("lineDistance", lineDistances.copyArray(geometry2.lineDistances));
        }
        if (geometry2.boundingSphere !== null) {
          this.boundingSphere = geometry2.boundingSphere.clone();
        }
        if (geometry2.boundingBox !== null) {
          this.boundingBox = geometry2.boundingBox.clone();
        }
      } else if (object.isMesh) {
        if (geometry2 && geometry2.isGeometry) {
          this.fromGeometry(geometry2);
        }
      }
      return this;
    },
    setFromPoints: function(points) {
      var position = [];
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        position.push(point.x, point.y, point.z || 0);
      }
      this.addAttribute("position", new Float32BufferAttribute(position, 3));
      return this;
    },
    updateFromObject: function(object) {
      var geometry2 = object.geometry;
      if (object.isMesh) {
        var direct = geometry2.__directGeometry;
        if (geometry2.elementsNeedUpdate === true) {
          direct = void 0;
          geometry2.elementsNeedUpdate = false;
        }
        if (direct === void 0) {
          return this.fromGeometry(geometry2);
        }
        direct.verticesNeedUpdate = geometry2.verticesNeedUpdate;
        direct.normalsNeedUpdate = geometry2.normalsNeedUpdate;
        direct.colorsNeedUpdate = geometry2.colorsNeedUpdate;
        direct.uvsNeedUpdate = geometry2.uvsNeedUpdate;
        direct.groupsNeedUpdate = geometry2.groupsNeedUpdate;
        geometry2.verticesNeedUpdate = false;
        geometry2.normalsNeedUpdate = false;
        geometry2.colorsNeedUpdate = false;
        geometry2.uvsNeedUpdate = false;
        geometry2.groupsNeedUpdate = false;
        geometry2 = direct;
      }
      var attribute;
      if (geometry2.verticesNeedUpdate === true) {
        attribute = this.attributes.position;
        if (attribute !== void 0) {
          attribute.copyVector3sArray(geometry2.vertices);
          attribute.needsUpdate = true;
        }
        geometry2.verticesNeedUpdate = false;
      }
      if (geometry2.normalsNeedUpdate === true) {
        attribute = this.attributes.normal;
        if (attribute !== void 0) {
          attribute.copyVector3sArray(geometry2.normals);
          attribute.needsUpdate = true;
        }
        geometry2.normalsNeedUpdate = false;
      }
      if (geometry2.colorsNeedUpdate === true) {
        attribute = this.attributes.color;
        if (attribute !== void 0) {
          attribute.copyColorsArray(geometry2.colors);
          attribute.needsUpdate = true;
        }
        geometry2.colorsNeedUpdate = false;
      }
      if (geometry2.uvsNeedUpdate) {
        attribute = this.attributes.uv;
        if (attribute !== void 0) {
          attribute.copyVector2sArray(geometry2.uvs);
          attribute.needsUpdate = true;
        }
        geometry2.uvsNeedUpdate = false;
      }
      if (geometry2.lineDistancesNeedUpdate) {
        attribute = this.attributes.lineDistance;
        if (attribute !== void 0) {
          attribute.copyArray(geometry2.lineDistances);
          attribute.needsUpdate = true;
        }
        geometry2.lineDistancesNeedUpdate = false;
      }
      if (geometry2.groupsNeedUpdate) {
        geometry2.computeGroups(object.geometry);
        this.groups = geometry2.groups;
        geometry2.groupsNeedUpdate = false;
      }
      return this;
    },
    fromGeometry: function(geometry2) {
      geometry2.__directGeometry = new DirectGeometry().fromGeometry(geometry2);
      return this.fromDirectGeometry(geometry2.__directGeometry);
    },
    fromDirectGeometry: function(geometry2) {
      var positions = new Float32Array(geometry2.vertices.length * 3);
      this.addAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry2.vertices));
      if (geometry2.normals.length > 0) {
        var normals = new Float32Array(geometry2.normals.length * 3);
        this.addAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry2.normals));
      }
      if (geometry2.colors.length > 0) {
        var colors = new Float32Array(geometry2.colors.length * 3);
        this.addAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry2.colors));
      }
      if (geometry2.uvs.length > 0) {
        var uvs = new Float32Array(geometry2.uvs.length * 2);
        this.addAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry2.uvs));
      }
      if (geometry2.uvs2.length > 0) {
        var uvs2 = new Float32Array(geometry2.uvs2.length * 2);
        this.addAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry2.uvs2));
      }
      this.groups = geometry2.groups;
      for (var name in geometry2.morphTargets) {
        var array = [];
        var morphTargets = geometry2.morphTargets[name];
        for (var i = 0, l = morphTargets.length; i < l; i++) {
          var morphTarget = morphTargets[i];
          var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
          attribute.name = morphTarget.name;
          array.push(attribute.copyVector3sArray(morphTarget.data));
        }
        this.morphAttributes[name] = array;
      }
      if (geometry2.skinIndices.length > 0) {
        var skinIndices = new Float32BufferAttribute(geometry2.skinIndices.length * 4, 4);
        this.addAttribute("skinIndex", skinIndices.copyVector4sArray(geometry2.skinIndices));
      }
      if (geometry2.skinWeights.length > 0) {
        var skinWeights = new Float32BufferAttribute(geometry2.skinWeights.length * 4, 4);
        this.addAttribute("skinWeight", skinWeights.copyVector4sArray(geometry2.skinWeights));
      }
      if (geometry2.boundingSphere !== null) {
        this.boundingSphere = geometry2.boundingSphere.clone();
      }
      if (geometry2.boundingBox !== null) {
        this.boundingBox = geometry2.boundingBox.clone();
      }
      return this;
    },
    computeBoundingBox: function() {
      var box = new Box3();
      return function computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position !== void 0) {
          this.boundingBox.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
              var morphAttribute = morphAttributesPosition[i];
              box.setFromBufferAttribute(morphAttribute);
              this.boundingBox.expandByPoint(box.min);
              this.boundingBox.expandByPoint(box.max);
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      };
    }(),
    computeBoundingSphere: function() {
      var box = new Box3();
      var boxMorphTargets = new Box3();
      var vector = new Vector3();
      return function computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position) {
          var center = this.boundingSphere.center;
          box.setFromBufferAttribute(position);
          if (morphAttributesPosition) {
            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
              var morphAttribute = morphAttributesPosition[i];
              boxMorphTargets.setFromBufferAttribute(morphAttribute);
              box.expandByPoint(boxMorphTargets.min);
              box.expandByPoint(boxMorphTargets.max);
            }
          }
          box.getCenter(center);
          var maxRadiusSq = 0;
          for (var i = 0, il = position.count; i < il; i++) {
            vector.fromBufferAttribute(position, i);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          }
          if (morphAttributesPosition) {
            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
              var morphAttribute = morphAttributesPosition[i];
              for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
                vector.fromBufferAttribute(morphAttribute, i);
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      };
    }(),
    computeFaceNormals: function() {
    },
    computeVertexNormals: function() {
      var index = this.index;
      var attributes = this.attributes;
      if (attributes.position) {
        var positions = attributes.position.array;
        if (attributes.normal === void 0) {
          this.addAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
        } else {
          var array = attributes.normal.array;
          for (var i = 0, il = array.length; i < il; i++) {
            array[i] = 0;
          }
        }
        var normals = attributes.normal.array;
        var vA, vB, vC;
        var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
        var cb = new Vector3(), ab = new Vector3();
        if (index) {
          var indices = index.array;
          for (var i = 0, il = index.count; i < il; i += 3) {
            vA = indices[i + 0] * 3;
            vB = indices[i + 1] * 3;
            vC = indices[i + 2] * 3;
            pA.fromArray(positions, vA);
            pB.fromArray(positions, vB);
            pC.fromArray(positions, vC);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[vA] += cb.x;
            normals[vA + 1] += cb.y;
            normals[vA + 2] += cb.z;
            normals[vB] += cb.x;
            normals[vB + 1] += cb.y;
            normals[vB + 2] += cb.z;
            normals[vC] += cb.x;
            normals[vC + 1] += cb.y;
            normals[vC + 2] += cb.z;
          }
        } else {
          for (var i = 0, il = positions.length; i < il; i += 9) {
            pA.fromArray(positions, i);
            pB.fromArray(positions, i + 3);
            pC.fromArray(positions, i + 6);
            cb.subVectors(pC, pB);
            ab.subVectors(pA, pB);
            cb.cross(ab);
            normals[i] = cb.x;
            normals[i + 1] = cb.y;
            normals[i + 2] = cb.z;
            normals[i + 3] = cb.x;
            normals[i + 4] = cb.y;
            normals[i + 5] = cb.z;
            normals[i + 6] = cb.x;
            normals[i + 7] = cb.y;
            normals[i + 8] = cb.z;
          }
        }
        this.normalizeNormals();
        attributes.normal.needsUpdate = true;
      }
    },
    merge: function(geometry2, offset) {
      if (!(geometry2 && geometry2.isBufferGeometry)) {
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry2);
        return;
      }
      if (offset === void 0) {
        offset = 0;
        console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
      }
      var attributes = this.attributes;
      for (var key in attributes) {
        if (geometry2.attributes[key] === void 0)
          continue;
        var attribute1 = attributes[key];
        var attributeArray1 = attribute1.array;
        var attribute2 = geometry2.attributes[key];
        var attributeArray2 = attribute2.array;
        var attributeSize = attribute2.itemSize;
        for (var i = 0, j = attributeSize * offset; i < attributeArray2.length; i++, j++) {
          attributeArray1[j] = attributeArray2[i];
        }
      }
      return this;
    },
    normalizeNormals: function() {
      var vector = new Vector3();
      return function normalizeNormals() {
        var normals = this.attributes.normal;
        for (var i = 0, il = normals.count; i < il; i++) {
          vector.x = normals.getX(i);
          vector.y = normals.getY(i);
          vector.z = normals.getZ(i);
          vector.normalize();
          normals.setXYZ(i, vector.x, vector.y, vector.z);
        }
      };
    }(),
    toNonIndexed: function() {
      function convertBufferAttribute(attribute2, indices2) {
        var array = attribute2.array;
        var itemSize = attribute2.itemSize;
        var array2 = new array.constructor(indices2.length * itemSize);
        var index = 0, index2 = 0;
        for (var i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
          index = indices2[i2] * itemSize;
          for (var j = 0; j < itemSize; j++) {
            array2[index2++] = array[index++];
          }
        }
        return new BufferAttribute(array2, itemSize);
      }
      if (this.index === null) {
        console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
        return this;
      }
      var geometry2 = new BufferGeometry();
      var indices = this.index.array;
      var attributes = this.attributes;
      for (var name in attributes) {
        var attribute = attributes[name];
        var newAttribute = convertBufferAttribute(attribute, indices);
        geometry2.addAttribute(name, newAttribute);
      }
      var morphAttributes = this.morphAttributes;
      for (name in morphAttributes) {
        var morphArray = [];
        var morphAttribute = morphAttributes[name];
        for (var i = 0, il = morphAttribute.length; i < il; i++) {
          var attribute = morphAttribute[i];
          var newAttribute = convertBufferAttribute(attribute, indices);
          morphArray.push(newAttribute);
        }
        geometry2.morphAttributes[name] = morphArray;
      }
      var groups = this.groups;
      for (var i = 0, l = groups.length; i < l; i++) {
        var group = groups[i];
        geometry2.addGroup(group.start, group.count, group.materialIndex);
      }
      return geometry2;
    },
    toJSON: function() {
      var data = {
        metadata: {
          version: 4.5,
          type: "BufferGeometry",
          generator: "BufferGeometry.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (Object.keys(this.userData).length > 0)
        data.userData = this.userData;
      if (this.parameters !== void 0) {
        var parameters = this.parameters;
        for (var key in parameters) {
          if (parameters[key] !== void 0)
            data[key] = parameters[key];
        }
        return data;
      }
      data.data = { attributes: {} };
      var index = this.index;
      if (index !== null) {
        data.data.index = {
          type: index.array.constructor.name,
          array: Array.prototype.slice.call(index.array)
        };
      }
      var attributes = this.attributes;
      for (var key in attributes) {
        var attribute = attributes[key];
        var attributeData = {
          itemSize: attribute.itemSize,
          type: attribute.array.constructor.name,
          array: Array.prototype.slice.call(attribute.array),
          normalized: attribute.normalized
        };
        if (attribute.name !== "")
          attributeData.name = attribute.name;
        data.data.attributes[key] = attributeData;
      }
      var morphAttributes = {};
      var hasMorphAttributes = false;
      for (var key in this.morphAttributes) {
        var attributeArray = this.morphAttributes[key];
        var array = [];
        for (var i = 0, il = attributeArray.length; i < il; i++) {
          var attribute = attributeArray[i];
          var attributeData = {
            itemSize: attribute.itemSize,
            type: attribute.array.constructor.name,
            array: Array.prototype.slice.call(attribute.array),
            normalized: attribute.normalized
          };
          if (attribute.name !== "")
            attributeData.name = attribute.name;
          array.push(attributeData);
        }
        if (array.length > 0) {
          morphAttributes[key] = array;
          hasMorphAttributes = true;
        }
      }
      if (hasMorphAttributes)
        data.data.morphAttributes = morphAttributes;
      var groups = this.groups;
      if (groups.length > 0) {
        data.data.groups = JSON.parse(JSON.stringify(groups));
      }
      var boundingSphere = this.boundingSphere;
      if (boundingSphere !== null) {
        data.data.boundingSphere = {
          center: boundingSphere.center.toArray(),
          radius: boundingSphere.radius
        };
      }
      return data;
    },
    clone: function() {
      return new BufferGeometry().copy(this);
    },
    copy: function(source) {
      var name, i, l;
      this.index = null;
      this.attributes = {};
      this.morphAttributes = {};
      this.groups = [];
      this.boundingBox = null;
      this.boundingSphere = null;
      this.name = source.name;
      var index = source.index;
      if (index !== null) {
        this.setIndex(index.clone());
      }
      var attributes = source.attributes;
      for (name in attributes) {
        var attribute = attributes[name];
        this.addAttribute(name, attribute.clone());
      }
      var morphAttributes = source.morphAttributes;
      for (name in morphAttributes) {
        var array = [];
        var morphAttribute = morphAttributes[name];
        for (i = 0, l = morphAttribute.length; i < l; i++) {
          array.push(morphAttribute[i].clone());
        }
        this.morphAttributes[name] = array;
      }
      var groups = source.groups;
      for (i = 0, l = groups.length; i < l; i++) {
        var group = groups[i];
        this.addGroup(group.start, group.count, group.materialIndex);
      }
      var boundingBox = source.boundingBox;
      if (boundingBox !== null) {
        this.boundingBox = boundingBox.clone();
      }
      var boundingSphere = source.boundingSphere;
      if (boundingSphere !== null) {
        this.boundingSphere = boundingSphere.clone();
      }
      this.drawRange.start = source.drawRange.start;
      this.drawRange.count = source.drawRange.count;
      this.userData = source.userData;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  function BoxGeometry(width2, height2, depth, widthSegments, heightSegments, depthSegments) {
    Geometry.call(this);
    this.type = "BoxGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    this.fromBufferGeometry(new BoxBufferGeometry(width2, height2, depth, widthSegments, heightSegments, depthSegments));
    this.mergeVertices();
  }
  BoxGeometry.prototype = Object.create(Geometry.prototype);
  BoxGeometry.prototype.constructor = BoxGeometry;
  function BoxBufferGeometry(width2, height2, depth, widthSegments, heightSegments, depthSegments) {
    BufferGeometry.call(this);
    this.type = "BoxBufferGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    var scope = this;
    width2 = width2 || 1;
    height2 = height2 || 1;
    depth = depth || 1;
    widthSegments = Math.floor(widthSegments) || 1;
    heightSegments = Math.floor(heightSegments) || 1;
    depthSegments = Math.floor(depthSegments) || 1;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var numberOfVertices = 0;
    var groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height2, width2, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height2, -width2, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width2, depth, height2, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width2, depth, -height2, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width2, height2, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width2, height2, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width3, height3, depth2, gridX, gridY, materialIndex) {
      var segmentWidth = width3 / gridX;
      var segmentHeight = height3 / gridY;
      var widthHalf = width3 / 2;
      var heightHalf = height3 / 2;
      var depthHalf = depth2 / 2;
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var vertexCounter = 0;
      var groupCount = 0;
      var ix, iy;
      var vector = new Vector3();
      for (iy = 0; iy < gridY1; iy++) {
        var y = iy * segmentHeight - heightHalf;
        for (ix = 0; ix < gridX1; ix++) {
          var x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (iy = 0; iy < gridY; iy++) {
        for (ix = 0; ix < gridX; ix++) {
          var a = numberOfVertices + ix + gridX1 * iy;
          var b = numberOfVertices + ix + gridX1 * (iy + 1);
          var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          var d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  BoxBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
  function PlaneGeometry(width2, height2, widthSegments, heightSegments) {
    Geometry.call(this);
    this.type = "PlaneGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      widthSegments,
      heightSegments
    };
    this.fromBufferGeometry(new PlaneBufferGeometry(width2, height2, widthSegments, heightSegments));
    this.mergeVertices();
  }
  PlaneGeometry.prototype = Object.create(Geometry.prototype);
  PlaneGeometry.prototype.constructor = PlaneGeometry;
  function PlaneBufferGeometry(width2, height2, widthSegments, heightSegments) {
    BufferGeometry.call(this);
    this.type = "PlaneBufferGeometry";
    this.parameters = {
      width: width2,
      height: height2,
      widthSegments,
      heightSegments
    };
    width2 = width2 || 1;
    height2 = height2 || 1;
    var width_half = width2 / 2;
    var height_half = height2 / 2;
    var gridX = Math.floor(widthSegments) || 1;
    var gridY = Math.floor(heightSegments) || 1;
    var gridX1 = gridX + 1;
    var gridY1 = gridY + 1;
    var segment_width = width2 / gridX;
    var segment_height = height2 / gridY;
    var ix, iy;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    for (iy = 0; iy < gridY1; iy++) {
      var y = iy * segment_height - height_half;
      for (ix = 0; ix < gridX1; ix++) {
        var x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (iy = 0; iy < gridY; iy++) {
      for (ix = 0; ix < gridX; ix++) {
        var a = ix + gridX1 * iy;
        var b = ix + gridX1 * (iy + 1);
        var c = ix + 1 + gridX1 * (iy + 1);
        var d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
  var materialId = 0;
  function Material() {
    Object.defineProperty(this, "id", { value: materialId++ });
    this.uuid = _Math.generateUUID();
    this.name = "";
    this.type = "Material";
    this.fog = true;
    this.lights = true;
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.flatShading = false;
    this.vertexTangents = false;
    this.vertexColors = NoColors;
    this.opacity = 1;
    this.transparent = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaTest = 0;
    this.premultipliedAlpha = false;
    this.visible = true;
    this.userData = {};
    this.needsUpdate = true;
  }
  Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: Material,
    isMaterial: true,
    onBeforeCompile: function() {
    },
    setValues: function(values) {
      if (values === void 0)
        return;
      for (var key in values) {
        var newValue = values[key];
        if (newValue === void 0) {
          console.warn("THREE.Material: '" + key + "' parameter is undefined.");
          continue;
        }
        if (key === "shading") {
          console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
          this.flatShading = newValue === FlatShading ? true : false;
          continue;
        }
        var currentValue = this[key];
        if (currentValue === void 0) {
          console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
          continue;
        }
        if (currentValue && currentValue.isColor) {
          currentValue.set(newValue);
        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
          currentValue.copy(newValue);
        } else {
          this[key] = newValue;
        }
      }
    },
    toJSON: function(meta) {
      var isRoot = meta === void 0 || typeof meta === "string";
      if (isRoot) {
        meta = {
          textures: {},
          images: {}
        };
      }
      var data = {
        metadata: {
          version: 4.5,
          type: "Material",
          generator: "Material.toJSON"
        }
      };
      data.uuid = this.uuid;
      data.type = this.type;
      if (this.name !== "")
        data.name = this.name;
      if (this.color && this.color.isColor)
        data.color = this.color.getHex();
      if (this.roughness !== void 0)
        data.roughness = this.roughness;
      if (this.metalness !== void 0)
        data.metalness = this.metalness;
      if (this.emissive && this.emissive.isColor)
        data.emissive = this.emissive.getHex();
      if (this.emissiveIntensity !== 1)
        data.emissiveIntensity = this.emissiveIntensity;
      if (this.specular && this.specular.isColor)
        data.specular = this.specular.getHex();
      if (this.shininess !== void 0)
        data.shininess = this.shininess;
      if (this.clearCoat !== void 0)
        data.clearCoat = this.clearCoat;
      if (this.clearCoatRoughness !== void 0)
        data.clearCoatRoughness = this.clearCoatRoughness;
      if (this.map && this.map.isTexture)
        data.map = this.map.toJSON(meta).uuid;
      if (this.alphaMap && this.alphaMap.isTexture)
        data.alphaMap = this.alphaMap.toJSON(meta).uuid;
      if (this.lightMap && this.lightMap.isTexture)
        data.lightMap = this.lightMap.toJSON(meta).uuid;
      if (this.aoMap && this.aoMap.isTexture) {
        data.aoMap = this.aoMap.toJSON(meta).uuid;
        data.aoMapIntensity = this.aoMapIntensity;
      }
      if (this.bumpMap && this.bumpMap.isTexture) {
        data.bumpMap = this.bumpMap.toJSON(meta).uuid;
        data.bumpScale = this.bumpScale;
      }
      if (this.normalMap && this.normalMap.isTexture) {
        data.normalMap = this.normalMap.toJSON(meta).uuid;
        data.normalMapType = this.normalMapType;
        data.normalScale = this.normalScale.toArray();
      }
      if (this.displacementMap && this.displacementMap.isTexture) {
        data.displacementMap = this.displacementMap.toJSON(meta).uuid;
        data.displacementScale = this.displacementScale;
        data.displacementBias = this.displacementBias;
      }
      if (this.roughnessMap && this.roughnessMap.isTexture)
        data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
      if (this.metalnessMap && this.metalnessMap.isTexture)
        data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
      if (this.emissiveMap && this.emissiveMap.isTexture)
        data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
      if (this.specularMap && this.specularMap.isTexture)
        data.specularMap = this.specularMap.toJSON(meta).uuid;
      if (this.envMap && this.envMap.isTexture) {
        data.envMap = this.envMap.toJSON(meta).uuid;
        data.reflectivity = this.reflectivity;
        if (this.combine !== void 0)
          data.combine = this.combine;
        if (this.envMapIntensity !== void 0)
          data.envMapIntensity = this.envMapIntensity;
      }
      if (this.gradientMap && this.gradientMap.isTexture) {
        data.gradientMap = this.gradientMap.toJSON(meta).uuid;
      }
      if (this.size !== void 0)
        data.size = this.size;
      if (this.sizeAttenuation !== void 0)
        data.sizeAttenuation = this.sizeAttenuation;
      if (this.blending !== NormalBlending)
        data.blending = this.blending;
      if (this.flatShading === true)
        data.flatShading = this.flatShading;
      if (this.side !== FrontSide)
        data.side = this.side;
      if (this.vertexColors !== NoColors)
        data.vertexColors = this.vertexColors;
      if (this.opacity < 1)
        data.opacity = this.opacity;
      if (this.transparent === true)
        data.transparent = this.transparent;
      data.depthFunc = this.depthFunc;
      data.depthTest = this.depthTest;
      data.depthWrite = this.depthWrite;
      if (this.rotation !== 0)
        data.rotation = this.rotation;
      if (this.polygonOffset === true)
        data.polygonOffset = true;
      if (this.polygonOffsetFactor !== 0)
        data.polygonOffsetFactor = this.polygonOffsetFactor;
      if (this.polygonOffsetUnits !== 0)
        data.polygonOffsetUnits = this.polygonOffsetUnits;
      if (this.linewidth !== 1)
        data.linewidth = this.linewidth;
      if (this.dashSize !== void 0)
        data.dashSize = this.dashSize;
      if (this.gapSize !== void 0)
        data.gapSize = this.gapSize;
      if (this.scale !== void 0)
        data.scale = this.scale;
      if (this.dithering === true)
        data.dithering = true;
      if (this.alphaTest > 0)
        data.alphaTest = this.alphaTest;
      if (this.premultipliedAlpha === true)
        data.premultipliedAlpha = this.premultipliedAlpha;
      if (this.wireframe === true)
        data.wireframe = this.wireframe;
      if (this.wireframeLinewidth > 1)
        data.wireframeLinewidth = this.wireframeLinewidth;
      if (this.wireframeLinecap !== "round")
        data.wireframeLinecap = this.wireframeLinecap;
      if (this.wireframeLinejoin !== "round")
        data.wireframeLinejoin = this.wireframeLinejoin;
      if (this.morphTargets === true)
        data.morphTargets = true;
      if (this.skinning === true)
        data.skinning = true;
      if (this.visible === false)
        data.visible = false;
      if (JSON.stringify(this.userData) !== "{}")
        data.userData = this.userData;
      function extractFromCache(cache) {
        var values = [];
        for (var key in cache) {
          var data2 = cache[key];
          delete data2.metadata;
          values.push(data2);
        }
        return values;
      }
      if (isRoot) {
        var textures = extractFromCache(meta.textures);
        var images = extractFromCache(meta.images);
        if (textures.length > 0)
          data.textures = textures;
        if (images.length > 0)
          data.images = images;
      }
      return data;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.name = source.name;
      this.fog = source.fog;
      this.lights = source.lights;
      this.blending = source.blending;
      this.side = source.side;
      this.flatShading = source.flatShading;
      this.vertexColors = source.vertexColors;
      this.opacity = source.opacity;
      this.transparent = source.transparent;
      this.blendSrc = source.blendSrc;
      this.blendDst = source.blendDst;
      this.blendEquation = source.blendEquation;
      this.blendSrcAlpha = source.blendSrcAlpha;
      this.blendDstAlpha = source.blendDstAlpha;
      this.blendEquationAlpha = source.blendEquationAlpha;
      this.depthFunc = source.depthFunc;
      this.depthTest = source.depthTest;
      this.depthWrite = source.depthWrite;
      this.colorWrite = source.colorWrite;
      this.precision = source.precision;
      this.polygonOffset = source.polygonOffset;
      this.polygonOffsetFactor = source.polygonOffsetFactor;
      this.polygonOffsetUnits = source.polygonOffsetUnits;
      this.dithering = source.dithering;
      this.alphaTest = source.alphaTest;
      this.premultipliedAlpha = source.premultipliedAlpha;
      this.visible = source.visible;
      this.userData = JSON.parse(JSON.stringify(source.userData));
      this.clipShadows = source.clipShadows;
      this.clipIntersection = source.clipIntersection;
      var srcPlanes = source.clippingPlanes, dstPlanes = null;
      if (srcPlanes !== null) {
        var n = srcPlanes.length;
        dstPlanes = new Array(n);
        for (var i = 0; i !== n; ++i)
          dstPlanes[i] = srcPlanes[i].clone();
      }
      this.clippingPlanes = dstPlanes;
      this.shadowSide = source.shadowSide;
      return this;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  function ShaderMaterial(parameters) {
    Material.call(this);
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv2": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
      }
      this.setValues(parameters);
    }
  }
  ShaderMaterial.prototype = Object.create(Material.prototype);
  ShaderMaterial.prototype.constructor = ShaderMaterial;
  ShaderMaterial.prototype.isShaderMaterial = true;
  ShaderMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    this.extensions = source.extensions;
    return this;
  };
  ShaderMaterial.prototype.toJSON = function(meta) {
    var data = Material.prototype.toJSON.call(this, meta);
    data.uniforms = {};
    for (var name in this.uniforms) {
      var uniform = this.uniforms[name];
      var value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    var extensions = {};
    for (var key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  };
  function Ray(origin, direction) {
    this.origin = origin !== void 0 ? origin : new Vector3();
    this.direction = direction !== void 0 ? direction : new Vector3();
  }
  Object.assign(Ray.prototype, {
    set: function(origin, direction) {
      this.origin.copy(origin);
      this.direction.copy(direction);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(ray) {
      this.origin.copy(ray.origin);
      this.direction.copy(ray.direction);
      return this;
    },
    at: function(t, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .at() target is now required");
        target = new Vector3();
      }
      return target.copy(this.direction).multiplyScalar(t).add(this.origin);
    },
    lookAt: function(v) {
      this.direction.copy(v).sub(this.origin).normalize();
      return this;
    },
    recast: function() {
      var v1 = new Vector3();
      return function recast(t) {
        this.origin.copy(this.at(t, v1));
        return this;
      };
    }(),
    closestPointToPoint: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Ray: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      target.subVectors(point, this.origin);
      var directionDistance = target.dot(this.direction);
      if (directionDistance < 0) {
        return target.copy(this.origin);
      }
      return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
    },
    distanceToPoint: function(point) {
      return Math.sqrt(this.distanceSqToPoint(point));
    },
    distanceSqToPoint: function() {
      var v1 = new Vector3();
      return function distanceSqToPoint(point) {
        var directionDistance = v1.subVectors(point, this.origin).dot(this.direction);
        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        v1.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
        return v1.distanceToSquared(point);
      };
    }(),
    distanceSqToSegment: function() {
      var segCenter = new Vector3();
      var segDir = new Vector3();
      var diff = new Vector3();
      return function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        segDir.copy(v1).sub(v0).normalize();
        diff.copy(this.origin).sub(segCenter);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(segDir);
        var b0 = diff.dot(this.direction);
        var b1 = -diff.dot(segDir);
        var c = diff.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0, s1, sqrDist, extDet;
        if (det > 0) {
          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(segDir).multiplyScalar(s1).add(segCenter);
        }
        return sqrDist;
      };
    }(),
    intersectSphere: function() {
      var v1 = new Vector3();
      return function intersectSphere(sphere, target) {
        v1.subVectors(sphere.center, this.origin);
        var tca = v1.dot(this.direction);
        var d2 = v1.dot(v1) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2)
          return null;
        var thc = Math.sqrt(radius2 - d2);
        var t0 = tca - thc;
        var t1 = tca + thc;
        if (t0 < 0 && t1 < 0)
          return null;
        if (t0 < 0)
          return this.at(t1, target);
        return this.at(t0, target);
      };
    }(),
    intersectsSphere: function(sphere) {
      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
    },
    distanceToPlane: function(plane) {
      var denominator = plane.normal.dot(this.direction);
      if (denominator === 0) {
        if (plane.distanceToPoint(this.origin) === 0) {
          return 0;
        }
        return null;
      }
      var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
      return t >= 0 ? t : null;
    },
    intersectPlane: function(plane, target) {
      var t = this.distanceToPlane(plane);
      if (t === null) {
        return null;
      }
      return this.at(t, target);
    },
    intersectsPlane: function(plane) {
      var distToPoint = plane.distanceToPoint(this.origin);
      if (distToPoint === 0) {
        return true;
      }
      var denominator = plane.normal.dot(this.direction);
      if (denominator * distToPoint < 0) {
        return true;
      }
      return false;
    },
    intersectBox: function(box, target) {
      var tmin, tmax, tymin, tymax, tzmin, tzmax;
      var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
      var origin = this.origin;
      if (invdirx >= 0) {
        tmin = (box.min.x - origin.x) * invdirx;
        tmax = (box.max.x - origin.x) * invdirx;
      } else {
        tmin = (box.max.x - origin.x) * invdirx;
        tmax = (box.min.x - origin.x) * invdirx;
      }
      if (invdiry >= 0) {
        tymin = (box.min.y - origin.y) * invdiry;
        tymax = (box.max.y - origin.y) * invdiry;
      } else {
        tymin = (box.max.y - origin.y) * invdiry;
        tymax = (box.min.y - origin.y) * invdiry;
      }
      if (tmin > tymax || tymin > tmax)
        return null;
      if (tymin > tmin || tmin !== tmin)
        tmin = tymin;
      if (tymax < tmax || tmax !== tmax)
        tmax = tymax;
      if (invdirz >= 0) {
        tzmin = (box.min.z - origin.z) * invdirz;
        tzmax = (box.max.z - origin.z) * invdirz;
      } else {
        tzmin = (box.max.z - origin.z) * invdirz;
        tzmax = (box.min.z - origin.z) * invdirz;
      }
      if (tmin > tzmax || tzmin > tmax)
        return null;
      if (tzmin > tmin || tmin !== tmin)
        tmin = tzmin;
      if (tzmax < tmax || tmax !== tmax)
        tmax = tzmax;
      if (tmax < 0)
        return null;
      return this.at(tmin >= 0 ? tmin : tmax, target);
    },
    intersectsBox: function() {
      var v = new Vector3();
      return function intersectsBox(box) {
        return this.intersectBox(box, v) !== null;
      };
    }(),
    intersectTriangle: function() {
      var diff = new Vector3();
      var edge1 = new Vector3();
      var edge2 = new Vector3();
      var normal = new Vector3();
      return function intersectTriangle(a, b, c, backfaceCulling, target) {
        edge1.subVectors(b, a);
        edge2.subVectors(c, a);
        normal.crossVectors(edge1, edge2);
        var DdN = this.direction.dot(normal);
        var sign;
        if (DdN > 0) {
          if (backfaceCulling)
            return null;
          sign = 1;
        } else if (DdN < 0) {
          sign = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(edge2.crossVectors(diff, edge2));
        if (DdQxE2 < 0) {
          return null;
        }
        var DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
        if (DdE1xQ < 0) {
          return null;
        }
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }
        var QdN = -sign * diff.dot(normal);
        if (QdN < 0) {
          return null;
        }
        return this.at(QdN / DdN, target);
      };
    }(),
    applyMatrix4: function(matrix4) {
      this.origin.applyMatrix4(matrix4);
      this.direction.transformDirection(matrix4);
      return this;
    },
    equals: function(ray) {
      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
    }
  });
  function Triangle(a, b, c) {
    this.a = a !== void 0 ? a : new Vector3();
    this.b = b !== void 0 ? b : new Vector3();
    this.c = c !== void 0 ? c : new Vector3();
  }
  Object.assign(Triangle, {
    getNormal: function() {
      var v0 = new Vector3();
      return function getNormal(a, b, c, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .getNormal() target is now required");
          target = new Vector3();
        }
        target.subVectors(c, b);
        v0.subVectors(a, b);
        target.cross(v0);
        var targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      };
    }(),
    getBarycoord: function() {
      var v0 = new Vector3();
      var v1 = new Vector3();
      var v2 = new Vector3();
      return function getBarycoord(point, a, b, c, target) {
        v0.subVectors(c, a);
        v1.subVectors(b, a);
        v2.subVectors(point, a);
        var dot00 = v0.dot(v0);
        var dot01 = v0.dot(v1);
        var dot02 = v0.dot(v2);
        var dot11 = v1.dot(v1);
        var dot12 = v1.dot(v2);
        var denom = dot00 * dot11 - dot01 * dot01;
        if (target === void 0) {
          console.warn("THREE.Triangle: .getBarycoord() target is now required");
          target = new Vector3();
        }
        if (denom === 0) {
          return target.set(-2, -1, -1);
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
        return target.set(1 - u - v, v, u);
      };
    }(),
    containsPoint: function() {
      var v1 = new Vector3();
      return function containsPoint(point, a, b, c) {
        Triangle.getBarycoord(point, a, b, c, v1);
        return v1.x >= 0 && v1.y >= 0 && v1.x + v1.y <= 1;
      };
    }(),
    getUV: function() {
      var barycoord = new Vector3();
      return function getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
        this.getBarycoord(point, p1, p2, p3, barycoord);
        target.set(0, 0);
        target.addScaledVector(uv1, barycoord.x);
        target.addScaledVector(uv2, barycoord.y);
        target.addScaledVector(uv3, barycoord.z);
        return target;
      };
    }()
  });
  Object.assign(Triangle.prototype, {
    set: function(a, b, c) {
      this.a.copy(a);
      this.b.copy(b);
      this.c.copy(c);
      return this;
    },
    setFromPointsAndIndices: function(points, i0, i1, i2) {
      this.a.copy(points[i0]);
      this.b.copy(points[i1]);
      this.c.copy(points[i2]);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(triangle) {
      this.a.copy(triangle.a);
      this.b.copy(triangle.b);
      this.c.copy(triangle.c);
      return this;
    },
    getArea: function() {
      var v0 = new Vector3();
      var v1 = new Vector3();
      return function getArea() {
        v0.subVectors(this.c, this.b);
        v1.subVectors(this.a, this.b);
        return v0.cross(v1).length() * 0.5;
      };
    }(),
    getMidpoint: function(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getMidpoint() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
    },
    getNormal: function(target) {
      return Triangle.getNormal(this.a, this.b, this.c, target);
    },
    getPlane: function(target) {
      if (target === void 0) {
        console.warn("THREE.Triangle: .getPlane() target is now required");
        target = new Vector3();
      }
      return target.setFromCoplanarPoints(this.a, this.b, this.c);
    },
    getBarycoord: function(point, target) {
      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
    },
    containsPoint: function(point) {
      return Triangle.containsPoint(point, this.a, this.b, this.c);
    },
    getUV: function(point, uv1, uv2, uv3, result) {
      return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, result);
    },
    intersectsBox: function(box) {
      return box.intersectsTriangle(this);
    },
    closestPointToPoint: function() {
      var vab = new Vector3();
      var vac = new Vector3();
      var vbc = new Vector3();
      var vap = new Vector3();
      var vbp = new Vector3();
      var vcp = new Vector3();
      return function closestPointToPoint(p2, target) {
        if (target === void 0) {
          console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
          target = new Vector3();
        }
        var a = this.a, b = this.b, c = this.c;
        var v, w;
        vab.subVectors(b, a);
        vac.subVectors(c, a);
        vap.subVectors(p2, a);
        var d1 = vab.dot(vap);
        var d2 = vac.dot(vap);
        if (d1 <= 0 && d2 <= 0) {
          return target.copy(a);
        }
        vbp.subVectors(p2, b);
        var d3 = vab.dot(vbp);
        var d4 = vac.dot(vbp);
        if (d3 >= 0 && d4 <= d3) {
          return target.copy(b);
        }
        var vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          return target.copy(a).addScaledVector(vab, v);
        }
        vcp.subVectors(p2, c);
        var d5 = vab.dot(vcp);
        var d6 = vac.dot(vcp);
        if (d6 >= 0 && d5 <= d6) {
          return target.copy(c);
        }
        var vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          return target.copy(a).addScaledVector(vac, w);
        }
        var va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          vbc.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          return target.copy(b).addScaledVector(vbc, w);
        }
        var denom = 1 / (va + vb + vc);
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(vab, v).addScaledVector(vac, w);
      };
    }(),
    equals: function(triangle) {
      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
    }
  });
  function MeshBasicMaterial(parameters) {
    Material.call(this);
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.lights = false;
    this.setValues(parameters);
  }
  MeshBasicMaterial.prototype = Object.create(Material.prototype);
  MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
  MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
  MeshBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    return this;
  };
  function Mesh(geometry2, material) {
    Object3D.call(this);
    this.type = "Mesh";
    this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
    this.material = material !== void 0 ? material : new MeshBasicMaterial({ color: Math.random() * 16777215 });
    this.drawMode = TrianglesDrawMode;
    this.updateMorphTargets();
  }
  Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Mesh,
    isMesh: true,
    setDrawMode: function(value) {
      this.drawMode = value;
    },
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.drawMode = source.drawMode;
      if (source.morphTargetInfluences !== void 0) {
        this.morphTargetInfluences = source.morphTargetInfluences.slice();
      }
      if (source.morphTargetDictionary !== void 0) {
        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
      }
      return this;
    },
    updateMorphTargets: function() {
      var geometry2 = this.geometry;
      var m, ml, name;
      if (geometry2.isBufferGeometry) {
        var morphAttributes = geometry2.morphAttributes;
        var keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== void 0) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (m = 0, ml = morphAttribute.length; m < ml; m++) {
              name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      } else {
        var morphTargets = geometry2.morphTargets;
        if (morphTargets !== void 0 && morphTargets.length > 0) {
          console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
        }
      }
    },
    raycast: function() {
      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();
      var vA = new Vector3();
      var vB = new Vector3();
      var vC = new Vector3();
      var tempA = new Vector3();
      var tempB = new Vector3();
      var tempC = new Vector3();
      var morphA = new Vector3();
      var morphB = new Vector3();
      var morphC = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();
      var intersectionPoint = new Vector3();
      var intersectionPointWorld = new Vector3();
      function checkIntersection(object, material, raycaster, ray2, pA, pB, pC, point) {
        var intersect;
        if (material.side === BackSide) {
          intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
        } else {
          intersect = ray2.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
        }
        if (intersect === null)
          return null;
        intersectionPointWorld.copy(point);
        intersectionPointWorld.applyMatrix4(object.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(intersectionPointWorld);
        if (distance < raycaster.near || distance > raycaster.far)
          return null;
        return {
          distance,
          point: intersectionPointWorld.clone(),
          object
        };
      }
      function checkBufferGeometryIntersection(object, material, raycaster, ray2, position, morphPosition, uv, a, b, c) {
        vA.fromBufferAttribute(position, a);
        vB.fromBufferAttribute(position, b);
        vC.fromBufferAttribute(position, c);
        var morphInfluences = object.morphTargetInfluences;
        if (material.morphTargets && morphPosition && morphInfluences) {
          morphA.set(0, 0, 0);
          morphB.set(0, 0, 0);
          morphC.set(0, 0, 0);
          for (var i = 0, il = morphPosition.length; i < il; i++) {
            var influence = morphInfluences[i];
            var morphAttribute = morphPosition[i];
            if (influence === 0)
              continue;
            tempA.fromBufferAttribute(morphAttribute, a);
            tempB.fromBufferAttribute(morphAttribute, b);
            tempC.fromBufferAttribute(morphAttribute, c);
            morphA.addScaledVector(tempA.sub(vA), influence);
            morphB.addScaledVector(tempB.sub(vB), influence);
            morphC.addScaledVector(tempC.sub(vC), influence);
          }
          vA.add(morphA);
          vB.add(morphB);
          vC.add(morphC);
        }
        var intersection = checkIntersection(object, material, raycaster, ray2, vA, vB, vC, intersectionPoint);
        if (intersection) {
          if (uv) {
            uvA.fromBufferAttribute(uv, a);
            uvB.fromBufferAttribute(uv, b);
            uvC.fromBufferAttribute(uv, c);
            intersection.uv = Triangle.getUV(intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2());
          }
          var face = new Face3(a, b, c);
          Triangle.getNormal(vA, vB, vC, face.normal);
          intersection.face = face;
        }
        return intersection;
      }
      return function raycast(raycaster, intersects2) {
        var geometry2 = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;
        if (material === void 0)
          return;
        if (geometry2.boundingSphere === null)
          geometry2.computeBoundingSphere();
        sphere.copy(geometry2.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(sphere) === false)
          return;
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        if (geometry2.boundingBox !== null) {
          if (ray.intersectsBox(geometry2.boundingBox) === false)
            return;
        }
        var intersection;
        if (geometry2.isBufferGeometry) {
          var a, b, c;
          var index = geometry2.index;
          var position = geometry2.attributes.position;
          var morphPosition = geometry2.morphAttributes.position;
          var uv = geometry2.attributes.uv;
          var groups = geometry2.groups;
          var drawRange = geometry2.drawRange;
          var i, j, il, jl;
          var group, groupMaterial;
          var start2, end2;
          if (index !== null) {
            if (Array.isArray(material)) {
              for (i = 0, il = groups.length; i < il; i++) {
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start2 = Math.max(group.start, drawRange.start);
                end2 = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (j = start2, jl = end2; j < jl; j += 3) {
                  a = index.getX(j);
                  b = index.getX(j + 1);
                  c = index.getX(j + 2);
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              start2 = Math.max(0, drawRange.start);
              end2 = Math.min(index.count, drawRange.start + drawRange.count);
              for (i = start2, il = end2; i < il; i += 3) {
                a = index.getX(i);
                b = index.getX(i + 1);
                c = index.getX(i + 2);
                intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i / 3);
                  intersects2.push(intersection);
                }
              }
            }
          } else if (position !== void 0) {
            if (Array.isArray(material)) {
              for (i = 0, il = groups.length; i < il; i++) {
                group = groups[i];
                groupMaterial = material[group.materialIndex];
                start2 = Math.max(group.start, drawRange.start);
                end2 = Math.min(group.start + group.count, drawRange.start + drawRange.count);
                for (j = start2, jl = end2; j < jl; j += 3) {
                  a = j;
                  b = j + 1;
                  c = j + 2;
                  intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, ray, position, morphPosition, uv, a, b, c);
                  if (intersection) {
                    intersection.faceIndex = Math.floor(j / 3);
                    intersection.face.materialIndex = group.materialIndex;
                    intersects2.push(intersection);
                  }
                }
              }
            } else {
              start2 = Math.max(0, drawRange.start);
              end2 = Math.min(position.count, drawRange.start + drawRange.count);
              for (i = start2, il = end2; i < il; i += 3) {
                a = i;
                b = i + 1;
                c = i + 2;
                intersection = checkBufferGeometryIntersection(this, material, raycaster, ray, position, morphPosition, uv, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(i / 3);
                  intersects2.push(intersection);
                }
              }
            }
          }
        } else if (geometry2.isGeometry) {
          var fvA, fvB, fvC;
          var isMultiMaterial = Array.isArray(material);
          var vertices = geometry2.vertices;
          var faces = geometry2.faces;
          var uvs;
          var faceVertexUvs = geometry2.faceVertexUvs[0];
          if (faceVertexUvs.length > 0)
            uvs = faceVertexUvs;
          for (var f = 0, fl = faces.length; f < fl; f++) {
            var face = faces[f];
            var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
            if (faceMaterial === void 0)
              continue;
            fvA = vertices[face.a];
            fvB = vertices[face.b];
            fvC = vertices[face.c];
            intersection = checkIntersection(this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint);
            if (intersection) {
              if (uvs && uvs[f]) {
                var uvs_f = uvs[f];
                uvA.copy(uvs_f[0]);
                uvB.copy(uvs_f[1]);
                uvC.copy(uvs_f[2]);
                intersection.uv = Triangle.getUV(intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2());
              }
              intersection.face = face;
              intersection.faceIndex = f;
              intersects2.push(intersection);
            }
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  function WebGLBackground(renderer, state2, objects, premultipliedAlpha) {
    var clearColor = new Color(0);
    var clearAlpha = 0;
    var planeMesh;
    var boxMesh;
    var currentBackground = null;
    var currentBackgroundVersion = 0;
    function render(renderList, scene2, camera2, forceClear) {
      var background = scene2.background;
      var vr = renderer.vr;
      var session = vr.getSession && vr.getSession();
      if (session && session.environmentBlendMode === "additive") {
        background = null;
      }
      if (background === null) {
        setClear(clearColor, clearAlpha);
        currentBackground = null;
        currentBackgroundVersion = 0;
      } else if (background && background.isColor) {
        setClear(background, 1);
        forceClear = true;
        currentBackground = null;
        currentBackgroundVersion = 0;
      }
      if (renderer.autoClear || forceClear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }
      if (background && (background.isCubeTexture || background.isWebGLRenderTargetCube)) {
        if (boxMesh === void 0) {
          boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
            type: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          boxMesh.geometry.removeAttribute("normal");
          boxMesh.geometry.removeAttribute("uv");
          boxMesh.onBeforeRender = function(renderer2, scene3, camera3) {
            this.matrixWorld.copyPosition(camera3.matrixWorld);
          };
          Object.defineProperty(boxMesh.material, "map", {
            get: function() {
              return this.uniforms.tCube.value;
            }
          });
          objects.update(boxMesh);
        }
        var texture = background.isWebGLRenderTargetCube ? background.texture : background;
        boxMesh.material.uniforms.tCube.value = texture;
        boxMesh.material.uniforms.tFlip.value = background.isWebGLRenderTargetCube ? 1 : -1;
        if (currentBackground !== background || currentBackgroundVersion !== texture.version) {
          boxMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = texture.version;
        }
        renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
      } else if (background && background.isTexture) {
        if (planeMesh === void 0) {
          planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
            type: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          }));
          planeMesh.geometry.removeAttribute("normal");
          Object.defineProperty(planeMesh.material, "map", {
            get: function() {
              return this.uniforms.t2D.value;
            }
          });
          objects.update(planeMesh);
        }
        planeMesh.material.uniforms.t2D.value = background;
        if (background.matrixAutoUpdate === true) {
          background.updateMatrix();
        }
        planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
        if (currentBackground !== background || currentBackgroundVersion !== background.version) {
          planeMesh.material.needsUpdate = true;
          currentBackground = background;
          currentBackgroundVersion = background.version;
        }
        renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
      }
    }
    function setClear(color, alpha) {
      state2.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
    }
    return {
      getClearColor: function() {
        return clearColor;
      },
      setClearColor: function(color, alpha) {
        clearColor.set(color);
        clearAlpha = alpha !== void 0 ? alpha : 1;
        setClear(clearColor, clearAlpha);
      },
      getClearAlpha: function() {
        return clearAlpha;
      },
      setClearAlpha: function(alpha) {
        clearAlpha = alpha;
        setClear(clearColor, clearAlpha);
      },
      render
    };
  }
  function WebGLBufferRenderer(gl, extensions, info, capabilities) {
    var mode;
    function setMode(value) {
      mode = value;
    }
    function render(start2, count2) {
      gl.drawArrays(mode, start2, count2);
      info.update(count2, mode);
    }
    function renderInstances(geometry2, start2, count2) {
      var extension;
      if (capabilities.isWebGL2) {
        extension = gl;
      } else {
        extension = extensions.get("ANGLE_instanced_arrays");
        if (extension === null) {
          console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[capabilities.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](mode, start2, count2, geometry2.maxInstancedCount);
      info.update(count2, mode, geometry2.maxInstancedCount);
    }
    this.setMode = setMode;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLCapabilities(gl, extensions, parameters) {
    var maxAnisotropy;
    function getMaxAnisotropy() {
      if (maxAnisotropy !== void 0)
        return maxAnisotropy;
      var extension = extensions.get("EXT_texture_filter_anisotropic");
      if (extension !== null) {
        maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else {
        maxAnisotropy = 0;
      }
      return maxAnisotropy;
    }
    function getMaxPrecision(precision2) {
      if (precision2 === "highp") {
        if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
          return "highp";
        }
        precision2 = "mediump";
      }
      if (precision2 === "mediump") {
        if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
          return "mediump";
        }
      }
      return "lowp";
    }
    var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext;
    var precision = parameters.precision !== void 0 ? parameters.precision : "highp";
    var maxPrecision = getMaxPrecision(precision);
    if (maxPrecision !== precision) {
      console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
      precision = maxPrecision;
    }
    var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
    var maxTextures = gl.getParameter(34930);
    var maxVertexTextures = gl.getParameter(35660);
    var maxTextureSize = gl.getParameter(3379);
    var maxCubemapSize = gl.getParameter(34076);
    var maxAttributes = gl.getParameter(34921);
    var maxVertexUniforms = gl.getParameter(36347);
    var maxVaryings = gl.getParameter(36348);
    var maxFragmentUniforms = gl.getParameter(36349);
    var vertexTextures = maxVertexTextures > 0;
    var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
    var floatVertexTextures = vertexTextures && floatFragmentTextures;
    var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
    return {
      isWebGL2,
      getMaxAnisotropy,
      getMaxPrecision,
      precision,
      logarithmicDepthBuffer,
      maxTextures,
      maxVertexTextures,
      maxTextureSize,
      maxCubemapSize,
      maxAttributes,
      maxVertexUniforms,
      maxVaryings,
      maxFragmentUniforms,
      vertexTextures,
      floatFragmentTextures,
      floatVertexTextures,
      maxSamples
    };
  }
  function WebGLClipping() {
    var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
    this.uniform = uniform;
    this.numPlanes = 0;
    this.numIntersection = 0;
    this.init = function(planes, enableLocalClipping, camera2) {
      var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
      localClippingEnabled = enableLocalClipping;
      globalState = projectPlanes(planes, camera2, 0);
      numGlobalPlanes = planes.length;
      return enabled;
    };
    this.beginShadows = function() {
      renderingShadows = true;
      projectPlanes(null);
    };
    this.endShadows = function() {
      renderingShadows = false;
      resetGlobalState();
    };
    this.setState = function(planes, clipIntersection, clipShadows, camera2, cache, fromCache) {
      if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
        if (renderingShadows) {
          projectPlanes(null);
        } else {
          resetGlobalState();
        }
      } else {
        var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
        uniform.value = dstArray;
        dstArray = projectPlanes(planes, camera2, lGlobal, fromCache);
        for (var i = 0; i !== lGlobal; ++i) {
          dstArray[i] = globalState[i];
        }
        cache.clippingState = dstArray;
        this.numIntersection = clipIntersection ? this.numPlanes : 0;
        this.numPlanes += nGlobal;
      }
    };
    function resetGlobalState() {
      if (uniform.value !== globalState) {
        uniform.value = globalState;
        uniform.needsUpdate = numGlobalPlanes > 0;
      }
      scope.numPlanes = numGlobalPlanes;
      scope.numIntersection = 0;
    }
    function projectPlanes(planes, camera2, dstOffset, skipTransform) {
      var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
      if (nPlanes !== 0) {
        dstArray = uniform.value;
        if (skipTransform !== true || dstArray === null) {
          var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera2.matrixWorldInverse;
          viewNormalMatrix.getNormalMatrix(viewMatrix);
          if (dstArray === null || dstArray.length < flatSize) {
            dstArray = new Float32Array(flatSize);
          }
          for (var i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
            plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
            plane.normal.toArray(dstArray, i4);
            dstArray[i4 + 3] = plane.constant;
          }
        }
        uniform.value = dstArray;
        uniform.needsUpdate = true;
      }
      scope.numPlanes = nPlanes;
      return dstArray;
    }
  }
  function WebGLExtensions(gl) {
    var extensions = {};
    return {
      get: function(name) {
        if (extensions[name] !== void 0) {
          return extensions[name];
        }
        var extension;
        switch (name) {
          case "WEBGL_depth_texture":
            extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
          case "EXT_texture_filter_anisotropic":
            extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
          case "WEBGL_compressed_texture_s3tc":
            extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
          case "WEBGL_compressed_texture_pvrtc":
            extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
          default:
            extension = gl.getExtension(name);
        }
        if (extension === null) {
          console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
        }
        extensions[name] = extension;
        return extension;
      }
    };
  }
  function WebGLGeometries(gl, attributes, info) {
    var geometries = {};
    var wireframeAttributes = {};
    function onGeometryDispose(event) {
      var geometry2 = event.target;
      var buffergeometry = geometries[geometry2.id];
      if (buffergeometry.index !== null) {
        attributes.remove(buffergeometry.index);
      }
      for (var name in buffergeometry.attributes) {
        attributes.remove(buffergeometry.attributes[name]);
      }
      geometry2.removeEventListener("dispose", onGeometryDispose);
      delete geometries[geometry2.id];
      var attribute = wireframeAttributes[buffergeometry.id];
      if (attribute) {
        attributes.remove(attribute);
        delete wireframeAttributes[buffergeometry.id];
      }
      info.memory.geometries--;
    }
    function get(object, geometry2) {
      var buffergeometry = geometries[geometry2.id];
      if (buffergeometry)
        return buffergeometry;
      geometry2.addEventListener("dispose", onGeometryDispose);
      if (geometry2.isBufferGeometry) {
        buffergeometry = geometry2;
      } else if (geometry2.isGeometry) {
        if (geometry2._bufferGeometry === void 0) {
          geometry2._bufferGeometry = new BufferGeometry().setFromObject(object);
        }
        buffergeometry = geometry2._bufferGeometry;
      }
      geometries[geometry2.id] = buffergeometry;
      info.memory.geometries++;
      return buffergeometry;
    }
    function update3(geometry2) {
      var index = geometry2.index;
      var geometryAttributes = geometry2.attributes;
      if (index !== null) {
        attributes.update(index, 34963);
      }
      for (var name in geometryAttributes) {
        attributes.update(geometryAttributes[name], 34962);
      }
      var morphAttributes = geometry2.morphAttributes;
      for (var name in morphAttributes) {
        var array = morphAttributes[name];
        for (var i = 0, l = array.length; i < l; i++) {
          attributes.update(array[i], 34962);
        }
      }
    }
    function getWireframeAttribute(geometry2) {
      var attribute = wireframeAttributes[geometry2.id];
      if (attribute)
        return attribute;
      var indices = [];
      var geometryIndex = geometry2.index;
      var geometryAttributes = geometry2.attributes;
      if (geometryIndex !== null) {
        var array = geometryIndex.array;
        for (var i = 0, l = array.length; i < l; i += 3) {
          var a = array[i + 0];
          var b = array[i + 1];
          var c = array[i + 2];
          indices.push(a, b, b, c, c, a);
        }
      } else {
        var array = geometryAttributes.position.array;
        for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
          var a = i + 0;
          var b = i + 1;
          var c = i + 2;
          indices.push(a, b, b, c, c, a);
        }
      }
      attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
      attributes.update(attribute, 34963);
      wireframeAttributes[geometry2.id] = attribute;
      return attribute;
    }
    return {
      get,
      update: update3,
      getWireframeAttribute
    };
  }
  function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
    var mode;
    function setMode(value) {
      mode = value;
    }
    var type, bytesPerElement;
    function setIndex(value) {
      type = value.type;
      bytesPerElement = value.bytesPerElement;
    }
    function render(start2, count2) {
      gl.drawElements(mode, count2, type, start2 * bytesPerElement);
      info.update(count2, mode);
    }
    function renderInstances(geometry2, start2, count2) {
      var extension;
      if (capabilities.isWebGL2) {
        extension = gl;
      } else {
        var extension = extensions.get("ANGLE_instanced_arrays");
        if (extension === null) {
          console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      extension[capabilities.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](mode, count2, type, start2 * bytesPerElement, geometry2.maxInstancedCount);
      info.update(count2, mode, geometry2.maxInstancedCount);
    }
    this.setMode = setMode;
    this.setIndex = setIndex;
    this.render = render;
    this.renderInstances = renderInstances;
  }
  function WebGLInfo(gl) {
    var memory = {
      geometries: 0,
      textures: 0
    };
    var render = {
      frame: 0,
      calls: 0,
      triangles: 0,
      points: 0,
      lines: 0
    };
    function update3(count2, mode, instanceCount) {
      instanceCount = instanceCount || 1;
      render.calls++;
      switch (mode) {
        case 4:
          render.triangles += instanceCount * (count2 / 3);
          break;
        case 5:
        case 6:
          render.triangles += instanceCount * (count2 - 2);
          break;
        case 1:
          render.lines += instanceCount * (count2 / 2);
          break;
        case 3:
          render.lines += instanceCount * (count2 - 1);
          break;
        case 2:
          render.lines += instanceCount * count2;
          break;
        case 0:
          render.points += instanceCount * count2;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
          break;
      }
    }
    function reset() {
      render.frame++;
      render.calls = 0;
      render.triangles = 0;
      render.points = 0;
      render.lines = 0;
    }
    return {
      memory,
      render,
      programs: null,
      autoReset: true,
      reset,
      update: update3
    };
  }
  function absNumericalSort(a, b) {
    return Math.abs(b[1]) - Math.abs(a[1]);
  }
  function WebGLMorphtargets(gl) {
    var influencesList = {};
    var morphInfluences = new Float32Array(8);
    function update3(object, geometry2, material, program) {
      var objectInfluences = object.morphTargetInfluences;
      var length = objectInfluences.length;
      var influences = influencesList[geometry2.id];
      if (influences === void 0) {
        influences = [];
        for (var i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry2.id] = influences;
      }
      var morphTargets = material.morphTargets && geometry2.morphAttributes.position;
      var morphNormals = material.morphNormals && geometry2.morphAttributes.normal;
      for (var i = 0; i < length; i++) {
        var influence = influences[i];
        if (influence[1] !== 0) {
          if (morphTargets)
            geometry2.removeAttribute("morphTarget" + i);
          if (morphNormals)
            geometry2.removeAttribute("morphNormal" + i);
        }
      }
      for (var i = 0; i < length; i++) {
        var influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (var i = 0; i < 8; i++) {
        var influence = influences[i];
        if (influence) {
          var index = influence[0];
          var value = influence[1];
          if (value) {
            if (morphTargets)
              geometry2.addAttribute("morphTarget" + i, morphTargets[index]);
            if (morphNormals)
              geometry2.addAttribute("morphNormal" + i, morphNormals[index]);
            morphInfluences[i] = value;
            continue;
          }
        }
        morphInfluences[i] = 0;
      }
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
    return {
      update: update3
    };
  }
  function WebGLObjects(geometries, info) {
    var updateList = {};
    function update3(object) {
      var frame = info.render.frame;
      var geometry2 = object.geometry;
      var buffergeometry = geometries.get(object, geometry2);
      if (updateList[buffergeometry.id] !== frame) {
        if (geometry2.isGeometry) {
          buffergeometry.updateFromObject(object);
        }
        geometries.update(buffergeometry);
        updateList[buffergeometry.id] = frame;
      }
      return buffergeometry;
    }
    function dispose() {
      updateList = {};
    }
    return {
      update: update3,
      dispose
    };
  }
  function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    format = format !== void 0 ? format : RGBFormat;
    Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.flipY = false;
  }
  CubeTexture.prototype = Object.create(Texture.prototype);
  CubeTexture.prototype.constructor = CubeTexture;
  CubeTexture.prototype.isCubeTexture = true;
  Object.defineProperty(CubeTexture.prototype, "images", {
    get: function() {
      return this.image;
    },
    set: function(value) {
      this.image = value;
    }
  });
  function DataTexture2DArray(data, width2, height2, depth) {
    Texture.call(this, null);
    this.image = { data, width: width2, height: height2, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
  }
  DataTexture2DArray.prototype = Object.create(Texture.prototype);
  DataTexture2DArray.prototype.constructor = DataTexture2DArray;
  DataTexture2DArray.prototype.isDataTexture2DArray = true;
  function DataTexture3D(data, width2, height2, depth) {
    Texture.call(this, null);
    this.image = { data, width: width2, height: height2, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
  }
  DataTexture3D.prototype = Object.create(Texture.prototype);
  DataTexture3D.prototype.constructor = DataTexture3D;
  DataTexture3D.prototype.isDataTexture3D = true;
  var emptyTexture = new Texture();
  var emptyTexture2dArray = new DataTexture2DArray();
  var emptyTexture3d = new DataTexture3D();
  var emptyCubeTexture = new CubeTexture();
  var arrayCacheF32 = [];
  var arrayCacheI32 = [];
  var mat4array = new Float32Array(16);
  var mat3array = new Float32Array(9);
  var mat2array = new Float32Array(4);
  function flatten(array, nBlocks, blockSize) {
    var firstElem = array[0];
    if (firstElem <= 0 || firstElem > 0)
      return array;
    var n = nBlocks * blockSize, r = arrayCacheF32[n];
    if (r === void 0) {
      r = new Float32Array(n);
      arrayCacheF32[n] = r;
    }
    if (nBlocks !== 0) {
      firstElem.toArray(r, 0);
      for (var i = 1, offset = 0; i !== nBlocks; ++i) {
        offset += blockSize;
        array[i].toArray(r, offset);
      }
    }
    return r;
  }
  function arraysEqual(a, b) {
    if (a.length !== b.length)
      return false;
    for (var i = 0, l = a.length; i < l; i++) {
      if (a[i] !== b[i])
        return false;
    }
    return true;
  }
  function copyArray(a, b) {
    for (var i = 0, l = b.length; i < l; i++) {
      a[i] = b[i];
    }
  }
  function allocTexUnits(textures, n) {
    var r = arrayCacheI32[n];
    if (r === void 0) {
      r = new Int32Array(n);
      arrayCacheI32[n] = r;
    }
    for (var i = 0; i !== n; ++i)
      r[i] = textures.allocateTextureUnit();
    return r;
  }
  function setValue1f(gl, v) {
    var cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1f(this.addr, v);
    cache[0] = v;
  }
  function setValue1i(gl, v) {
    var cache = this.cache;
    if (cache[0] === v)
      return;
    gl.uniform1i(this.addr, v);
    cache[0] = v;
  }
  function setValue2fv(gl, v) {
    var cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y) {
        gl.uniform2f(this.addr, v.x, v.y);
        cache[0] = v.x;
        cache[1] = v.y;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform2fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValue3fv(gl, v) {
    var cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
        gl.uniform3f(this.addr, v.x, v.y, v.z);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
      }
    } else if (v.r !== void 0) {
      if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
        gl.uniform3f(this.addr, v.r, v.g, v.b);
        cache[0] = v.r;
        cache[1] = v.g;
        cache[2] = v.b;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform3fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValue4fv(gl, v) {
    var cache = this.cache;
    if (v.x !== void 0) {
      if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
        gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
        cache[0] = v.x;
        cache[1] = v.y;
        cache[2] = v.z;
        cache[3] = v.w;
      }
    } else {
      if (arraysEqual(cache, v))
        return;
      gl.uniform4fv(this.addr, v);
      copyArray(cache, v);
    }
  }
  function setValue2fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix2fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat2array.set(elements);
      gl.uniformMatrix2fv(this.addr, false, mat2array);
      copyArray(cache, elements);
    }
  }
  function setValue3fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix3fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat3array.set(elements);
      gl.uniformMatrix3fv(this.addr, false, mat3array);
      copyArray(cache, elements);
    }
  }
  function setValue4fm(gl, v) {
    var cache = this.cache;
    var elements = v.elements;
    if (elements === void 0) {
      if (arraysEqual(cache, v))
        return;
      gl.uniformMatrix4fv(this.addr, false, v);
      copyArray(cache, v);
    } else {
      if (arraysEqual(cache, elements))
        return;
      mat4array.set(elements);
      gl.uniformMatrix4fv(this.addr, false, mat4array);
      copyArray(cache, elements);
    }
  }
  function setValueT1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTexture2D(v || emptyTexture, unit);
  }
  function setValueT2DArray1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture2DArray(v || emptyTexture2dArray, unit);
  }
  function setValueT3D1(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.setTexture3D(v || emptyTexture3d, unit);
  }
  function setValueT6(gl, v, textures) {
    var cache = this.cache;
    var unit = textures.allocateTextureUnit();
    if (cache[0] !== unit) {
      gl.uniform1i(this.addr, unit);
      cache[0] = unit;
    }
    textures.safeSetTextureCube(v || emptyCubeTexture, unit);
  }
  function setValue2iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValue3iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValue4iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
  function getSingularSetter(type) {
    switch (type) {
      case 5126:
        return setValue1f;
      case 35664:
        return setValue2fv;
      case 35665:
        return setValue3fv;
      case 35666:
        return setValue4fv;
      case 35674:
        return setValue2fm;
      case 35675:
        return setValue3fm;
      case 35676:
        return setValue4fm;
      case 35678:
      case 36198:
        return setValueT1;
      case 35679:
        return setValueT3D1;
      case 35680:
        return setValueT6;
      case 36289:
        return setValueT2DArray1;
      case 5124:
      case 35670:
        return setValue1i;
      case 35667:
      case 35671:
        return setValue2iv;
      case 35668:
      case 35672:
        return setValue3iv;
      case 35669:
      case 35673:
        return setValue4iv;
    }
  }
  function setValue1fv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform1fv(this.addr, v);
    copyArray(cache, v);
  }
  function setValue1iv(gl, v) {
    var cache = this.cache;
    if (arraysEqual(cache, v))
      return;
    gl.uniform1iv(this.addr, v);
    copyArray(cache, v);
  }
  function setValueV2a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 2);
    if (arraysEqual(cache, data))
      return;
    gl.uniform2fv(this.addr, data);
    this.updateCache(data);
  }
  function setValueV3a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 3);
    if (arraysEqual(cache, data))
      return;
    gl.uniform3fv(this.addr, data);
    this.updateCache(data);
  }
  function setValueV4a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 4);
    if (arraysEqual(cache, data))
      return;
    gl.uniform4fv(this.addr, data);
    this.updateCache(data);
  }
  function setValueM2a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 4);
    if (arraysEqual(cache, data))
      return;
    gl.uniformMatrix2fv(this.addr, false, data);
    this.updateCache(data);
  }
  function setValueM3a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 9);
    if (arraysEqual(cache, data))
      return;
    gl.uniformMatrix3fv(this.addr, false, data);
    this.updateCache(data);
  }
  function setValueM4a(gl, v) {
    var cache = this.cache;
    var data = flatten(v, this.size, 16);
    if (arraysEqual(cache, data))
      return;
    gl.uniformMatrix4fv(this.addr, false, data);
    this.updateCache(data);
  }
  function setValueT1a(gl, v, textures) {
    var cache = this.cache;
    var n = v.length;
    var units = allocTexUnits(textures, n);
    if (arraysEqual(cache, units) === false) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (var i = 0; i !== n; ++i) {
      textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
    }
  }
  function setValueT6a(gl, v, textures) {
    var cache = this.cache;
    var n = v.length;
    var units = allocTexUnits(textures, n);
    if (arraysEqual(cache, units) === false) {
      gl.uniform1iv(this.addr, units);
      copyArray(cache, units);
    }
    for (var i = 0; i !== n; ++i) {
      textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
    }
  }
  function getPureArraySetter(type) {
    switch (type) {
      case 5126:
        return setValue1fv;
      case 35664:
        return setValueV2a;
      case 35665:
        return setValueV3a;
      case 35666:
        return setValueV4a;
      case 35674:
        return setValueM2a;
      case 35675:
        return setValueM3a;
      case 35676:
        return setValueM4a;
      case 35678:
        return setValueT1a;
      case 35680:
        return setValueT6a;
      case 5124:
      case 35670:
        return setValue1iv;
      case 35667:
      case 35671:
        return setValue2iv;
      case 35668:
      case 35672:
        return setValue3iv;
      case 35669:
      case 35673:
        return setValue4iv;
    }
  }
  function SingleUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
  function PureArrayUniform(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
  PureArrayUniform.prototype.updateCache = function(data) {
    var cache = this.cache;
    if (data instanceof Float32Array && cache.length !== data.length) {
      this.cache = new Float32Array(data.length);
    }
    copyArray(cache, data);
  };
  function StructuredUniform(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  StructuredUniform.prototype.setValue = function(gl, value, textures) {
    var seq = this.seq;
    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  };
  var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
  function addUniform(container, uniformObject) {
    container.seq.push(uniformObject);
    container.map[uniformObject.id] = uniformObject;
  }
  function parseUniform(activeInfo, addr, container) {
    var path = activeInfo.name, pathLength = path.length;
    RePathPart.lastIndex = 0;
    while (true) {
      var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
      if (idIsIndex)
        id = id | 0;
      if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
        addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
        break;
      } else {
        var map = container.map, next = map[id];
        if (next === void 0) {
          next = new StructuredUniform(id);
          addUniform(container, next);
        }
        container = next;
      }
    }
  }
  function WebGLUniforms(gl, program) {
    this.seq = [];
    this.map = {};
    var n = gl.getProgramParameter(program, 35718);
    for (var i = 0; i < n; ++i) {
      var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  WebGLUniforms.prototype.setValue = function(gl, name, value, textures) {
    var u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  };
  WebGLUniforms.prototype.setOptional = function(gl, object, name) {
    var v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  };
  WebGLUniforms.upload = function(gl, seq, values, textures) {
    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  };
  WebGLUniforms.seqWithValue = function(seq, values) {
    var r = [];
    for (var i = 0, n = seq.length; i !== n; ++i) {
      var u = seq[i];
      if (u.id in values)
        r.push(u);
    }
    return r;
  };
  function addLineNumbers(string) {
    var lines = string.split("\n");
    for (var i = 0; i < lines.length; i++) {
      lines[i] = i + 1 + ": " + lines[i];
    }
    return lines.join("\n");
  }
  function WebGLShader(gl, type, string) {
    var shader = gl.createShader(type);
    gl.shaderSource(shader, string);
    gl.compileShader(shader);
    if (gl.getShaderParameter(shader, 35713) === false) {
      console.error("THREE.WebGLShader: Shader couldn't compile.");
    }
    if (gl.getShaderInfoLog(shader) !== "") {
      console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", type === 35633 ? "vertex" : "fragment", gl.getShaderInfoLog(shader), addLineNumbers(string));
    }
    return shader;
  }
  var programIdCount = 0;
  function getEncodingComponents(encoding) {
    switch (encoding) {
      case LinearEncoding:
        return ["Linear", "( value )"];
      case sRGBEncoding:
        return ["sRGB", "( value )"];
      case RGBEEncoding:
        return ["RGBE", "( value )"];
      case RGBM7Encoding:
        return ["RGBM", "( value, 7.0 )"];
      case RGBM16Encoding:
        return ["RGBM", "( value, 16.0 )"];
      case RGBDEncoding:
        return ["RGBD", "( value, 256.0 )"];
      case GammaEncoding:
        return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
      default:
        throw new Error("unsupported encoding: " + encoding);
    }
  }
  function getTexelDecodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
  }
  function getTexelEncodingFunction(functionName, encoding) {
    var components = getEncodingComponents(encoding);
    return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
  }
  function getToneMappingFunction(functionName, toneMapping) {
    var toneMappingName;
    switch (toneMapping) {
      case LinearToneMapping:
        toneMappingName = "Linear";
        break;
      case ReinhardToneMapping:
        toneMappingName = "Reinhard";
        break;
      case Uncharted2ToneMapping:
        toneMappingName = "Uncharted2";
        break;
      case CineonToneMapping:
        toneMappingName = "OptimizedCineon";
        break;
      case ACESFilmicToneMapping:
        toneMappingName = "ACESFilmic";
        break;
      default:
        throw new Error("unsupported toneMapping: " + toneMapping);
    }
    return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
  }
  function generateExtensions(extensions, parameters, rendererExtensions) {
    extensions = extensions || {};
    var chunks = [
      extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap && !parameters.objectSpaceNormalMap || parameters.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "",
      (extensions.fragDepth || parameters.logarithmicDepthBuffer) && rendererExtensions.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "",
      extensions.drawBuffers && rendererExtensions.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "",
      (extensions.shaderTextureLOD || parameters.envMap) && rendererExtensions.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""
    ];
    return chunks.filter(filterEmptyLine).join("\n");
  }
  function generateDefines(defines) {
    var chunks = [];
    for (var name in defines) {
      var value = defines[name];
      if (value === false)
        continue;
      chunks.push("#define " + name + " " + value);
    }
    return chunks.join("\n");
  }
  function fetchAttributeLocations(gl, program) {
    var attributes = {};
    var n = gl.getProgramParameter(program, 35721);
    for (var i = 0; i < n; i++) {
      var info = gl.getActiveAttrib(program, i);
      var name = info.name;
      attributes[name] = gl.getAttribLocation(program, name);
    }
    return attributes;
  }
  function filterEmptyLine(string) {
    return string !== "";
  }
  function replaceLightNums(string, parameters) {
    return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights);
  }
  function replaceClippingPlaneNums(string, parameters) {
    return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
  }
  function parseIncludes(string) {
    var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
    function replace(match, include) {
      var replace2 = ShaderChunk[include];
      if (replace2 === void 0) {
        throw new Error("Can not resolve #include <" + include + ">");
      }
      return parseIncludes(replace2);
    }
    return string.replace(pattern, replace);
  }
  function unrollLoops(string) {
    var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
    function replace(match, start2, end2, snippet) {
      var unroll = "";
      for (var i = parseInt(start2); i < parseInt(end2); i++) {
        unroll += snippet.replace(/\[ i \]/g, "[ " + i + " ]");
      }
      return unroll;
    }
    return string.replace(pattern, replace);
  }
  function WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities, textures) {
    var gl = renderer.context;
    var defines = material.defines;
    var vertexShader = shader.vertexShader;
    var fragmentShader = shader.fragmentShader;
    var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
    if (parameters.shadowMapType === PCFShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
    } else if (parameters.shadowMapType === PCFSoftShadowMap) {
      shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
    }
    var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
    var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
    var envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
    if (parameters.envMap) {
      switch (material.envMap.mapping) {
        case CubeReflectionMapping:
        case CubeRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE";
          break;
        case CubeUVReflectionMapping:
        case CubeUVRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
          break;
        case EquirectangularReflectionMapping:
        case EquirectangularRefractionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
          break;
        case SphericalReflectionMapping:
          envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
          break;
      }
      switch (material.envMap.mapping) {
        case CubeRefractionMapping:
        case EquirectangularRefractionMapping:
          envMapModeDefine = "ENVMAP_MODE_REFRACTION";
          break;
      }
      switch (material.combine) {
        case MultiplyOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
          break;
        case MixOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
          break;
        case AddOperation:
          envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
          break;
      }
    }
    var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
    var customExtensions = capabilities.isWebGL2 ? "" : generateExtensions(material.extensions, parameters, extensions);
    var customDefines = generateDefines(defines);
    var program = gl.createProgram();
    var prefixVertex, prefixFragment;
    if (material.isRawShaderMaterial) {
      prefixVertex = [
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixVertex.length > 0) {
        prefixVertex += "\n";
      }
      prefixFragment = [
        customExtensions,
        customDefines
      ].filter(filterEmptyLine).join("\n");
      if (prefixFragment.length > 0) {
        prefixFragment += "\n";
      }
    } else {
      prefixVertex = [
        "precision " + parameters.precision + " float;",
        "precision " + parameters.precision + " int;",
        "#define SHADER_NAME " + shader.name,
        customDefines,
        parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        "#define MAX_BONES " + parameters.maxBones,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.skinning ? "#define USE_SKINNING" : "",
        parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",
        parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
        parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#ifdef USE_COLOR",
        "	attribute vec3 color;",
        "#endif",
        "#ifdef USE_MORPHTARGETS",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        "\n"
      ].filter(filterEmptyLine).join("\n");
      prefixFragment = [
        customExtensions,
        "precision " + parameters.precision + " float;",
        "precision " + parameters.precision + " int;",
        "#define SHADER_NAME " + shader.name,
        customDefines,
        parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "",
        "#define GAMMA_FACTOR " + gammaFactorDefine,
        parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
        parameters.useFog && parameters.fogExp ? "#define FOG_EXP2" : "",
        parameters.map ? "#define USE_MAP" : "",
        parameters.matcap ? "#define USE_MATCAP" : "",
        parameters.envMap ? "#define USE_ENVMAP" : "",
        parameters.envMap ? "#define " + envMapTypeDefine : "",
        parameters.envMap ? "#define " + envMapModeDefine : "",
        parameters.envMap ? "#define " + envMapBlendingDefine : "",
        parameters.lightMap ? "#define USE_LIGHTMAP" : "",
        parameters.aoMap ? "#define USE_AOMAP" : "",
        parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        parameters.bumpMap ? "#define USE_BUMPMAP" : "",
        parameters.normalMap ? "#define USE_NORMALMAP" : "",
        parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "",
        parameters.specularMap ? "#define USE_SPECULARMAP" : "",
        parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
        parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
        parameters.vertexTangents ? "#define USE_TANGENT" : "",
        parameters.vertexColors ? "#define USE_COLOR" : "",
        parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
        parameters.flatShading ? "#define FLAT_SHADED" : "",
        parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
        parameters.flipSided ? "#define FLIP_SIDED" : "",
        parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
        parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "",
        parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        parameters.logarithmicDepthBuffer && (capabilities.isWebGL2 || extensions.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "",
        parameters.envMap && (capabilities.isWebGL2 || extensions.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
        parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
        parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
        parameters.dithering ? "#define DITHERING" : "",
        parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "",
        parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "",
        parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "",
        parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "",
        parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "",
        parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "",
        parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : "",
        "\n"
      ].filter(filterEmptyLine).join("\n");
    }
    vertexShader = parseIncludes(vertexShader);
    vertexShader = replaceLightNums(vertexShader, parameters);
    vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
    fragmentShader = parseIncludes(fragmentShader);
    fragmentShader = replaceLightNums(fragmentShader, parameters);
    fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
    vertexShader = unrollLoops(vertexShader);
    fragmentShader = unrollLoops(fragmentShader);
    if (capabilities.isWebGL2 && !material.isRawShaderMaterial) {
      var isGLSL3ShaderMaterial = false;
      var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
      if (material.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
        isGLSL3ShaderMaterial = true;
        vertexShader = vertexShader.replace(versionRegex, "");
        fragmentShader = fragmentShader.replace(versionRegex, "");
      }
      prefixVertex = [
        "#version 300 es\n",
        "#define attribute in",
        "#define varying out",
        "#define texture2D texture"
      ].join("\n") + "\n" + prefixVertex;
      prefixFragment = [
        "#version 300 es\n",
        "#define varying in",
        isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;",
        isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor",
        "#define gl_FragDepthEXT gl_FragDepth",
        "#define texture2D texture",
        "#define textureCube texture",
        "#define texture2DProj textureProj",
        "#define texture2DLodEXT textureLod",
        "#define texture2DProjLodEXT textureProjLod",
        "#define textureCubeLodEXT textureLod",
        "#define texture2DGradEXT textureGrad",
        "#define texture2DProjGradEXT textureProjGrad",
        "#define textureCubeGradEXT textureGrad"
      ].join("\n") + "\n" + prefixFragment;
    }
    var vertexGlsl = prefixVertex + vertexShader;
    var fragmentGlsl = prefixFragment + fragmentShader;
    var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
    var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
    gl.attachShader(program, glVertexShader);
    gl.attachShader(program, glFragmentShader);
    if (material.index0AttributeName !== void 0) {
      gl.bindAttribLocation(program, 0, material.index0AttributeName);
    } else if (parameters.morphTargets === true) {
      gl.bindAttribLocation(program, 0, "position");
    }
    gl.linkProgram(program);
    var programLog = gl.getProgramInfoLog(program).trim();
    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
    var runnable = true;
    var haveDiagnostics = true;
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false;
      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexLog, fragmentLog);
    } else if (programLog !== "") {
      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
    } else if (vertexLog === "" || fragmentLog === "") {
      haveDiagnostics = false;
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        material,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment
        }
      };
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    var cachedUniforms;
    this.getUniforms = function() {
      if (cachedUniforms === void 0) {
        cachedUniforms = new WebGLUniforms(gl, program, textures);
      }
      return cachedUniforms;
    };
    var cachedAttributes;
    this.getAttributes = function() {
      if (cachedAttributes === void 0) {
        cachedAttributes = fetchAttributeLocations(gl, program);
      }
      return cachedAttributes;
    };
    this.destroy = function() {
      gl.deleteProgram(program);
      this.program = void 0;
    };
    Object.defineProperties(this, {
      uniforms: {
        get: function() {
          console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms().");
          return this.getUniforms();
        }
      },
      attributes: {
        get: function() {
          console.warn("THREE.WebGLProgram: .attributes is now .getAttributes().");
          return this.getAttributes();
        }
      }
    });
    this.name = shader.name;
    this.id = programIdCount++;
    this.code = code;
    this.usedTimes = 1;
    this.program = program;
    this.vertexShader = glVertexShader;
    this.fragmentShader = glFragmentShader;
    return this;
  }
  function WebGLPrograms(renderer, extensions, capabilities, textures) {
    var programs = [];
    var shaderIDs = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "phong",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
    };
    var parameterNames = [
      "precision",
      "supportsVertexTextures",
      "map",
      "mapEncoding",
      "matcap",
      "matcapEncoding",
      "envMap",
      "envMapMode",
      "envMapEncoding",
      "lightMap",
      "aoMap",
      "emissiveMap",
      "emissiveMapEncoding",
      "bumpMap",
      "normalMap",
      "objectSpaceNormalMap",
      "displacementMap",
      "specularMap",
      "roughnessMap",
      "metalnessMap",
      "gradientMap",
      "alphaMap",
      "combine",
      "vertexColors",
      "vertexTangents",
      "fog",
      "useFog",
      "fogExp",
      "flatShading",
      "sizeAttenuation",
      "logarithmicDepthBuffer",
      "skinning",
      "maxBones",
      "useVertexTexture",
      "morphTargets",
      "morphNormals",
      "maxMorphTargets",
      "maxMorphNormals",
      "premultipliedAlpha",
      "numDirLights",
      "numPointLights",
      "numSpotLights",
      "numHemiLights",
      "numRectAreaLights",
      "shadowMapEnabled",
      "shadowMapType",
      "toneMapping",
      "physicallyCorrectLights",
      "alphaTest",
      "doubleSided",
      "flipSided",
      "numClippingPlanes",
      "numClipIntersection",
      "depthPacking",
      "dithering"
    ];
    function allocateBones(object) {
      var skeleton = object.skeleton;
      var bones2 = skeleton.bones;
      if (capabilities.floatVertexTextures) {
        return 1024;
      } else {
        var nVertexUniforms = capabilities.maxVertexUniforms;
        var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
        var maxBones = Math.min(nVertexMatrices, bones2.length);
        if (maxBones < bones2.length) {
          console.warn("THREE.WebGLRenderer: Skeleton has " + bones2.length + " bones. This GPU supports " + maxBones + ".");
          return 0;
        }
        return maxBones;
      }
    }
    function getTextureEncodingFromMap(map, gammaOverrideLinear) {
      var encoding;
      if (!map) {
        encoding = LinearEncoding;
      } else if (map.isTexture) {
        encoding = map.encoding;
      } else if (map.isWebGLRenderTarget) {
        console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
        encoding = map.texture.encoding;
      }
      if (encoding === LinearEncoding && gammaOverrideLinear) {
        encoding = GammaEncoding;
      }
      return encoding;
    }
    this.getParameters = function(material, lights, shadows, fog, nClipPlanes, nClipIntersection, object) {
      var shaderID = shaderIDs[material.type];
      var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
      var precision = capabilities.precision;
      if (material.precision !== null) {
        precision = capabilities.getMaxPrecision(material.precision);
        if (precision !== material.precision) {
          console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
        }
      }
      var currentRenderTarget = renderer.getRenderTarget();
      var parameters = {
        shaderID,
        precision,
        supportsVertexTextures: capabilities.vertexTextures,
        outputEncoding: getTextureEncodingFromMap(!currentRenderTarget ? null : currentRenderTarget.texture, renderer.gammaOutput),
        map: !!material.map,
        mapEncoding: getTextureEncodingFromMap(material.map, renderer.gammaInput),
        matcap: !!material.matcap,
        matcapEncoding: getTextureEncodingFromMap(material.matcap, renderer.gammaInput),
        envMap: !!material.envMap,
        envMapMode: material.envMap && material.envMap.mapping,
        envMapEncoding: getTextureEncodingFromMap(material.envMap, renderer.gammaInput),
        envMapCubeUV: !!material.envMap && (material.envMap.mapping === CubeUVReflectionMapping || material.envMap.mapping === CubeUVRefractionMapping),
        lightMap: !!material.lightMap,
        aoMap: !!material.aoMap,
        emissiveMap: !!material.emissiveMap,
        emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap, renderer.gammaInput),
        bumpMap: !!material.bumpMap,
        normalMap: !!material.normalMap,
        objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
        displacementMap: !!material.displacementMap,
        roughnessMap: !!material.roughnessMap,
        metalnessMap: !!material.metalnessMap,
        specularMap: !!material.specularMap,
        alphaMap: !!material.alphaMap,
        gradientMap: !!material.gradientMap,
        combine: material.combine,
        vertexTangents: material.normalMap && material.vertexTangents,
        vertexColors: material.vertexColors,
        fog: !!fog,
        useFog: material.fog,
        fogExp: fog && fog.isFogExp2,
        flatShading: material.flatShading,
        sizeAttenuation: material.sizeAttenuation,
        logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
        skinning: material.skinning && maxBones > 0,
        maxBones,
        useVertexTexture: capabilities.floatVertexTextures,
        morphTargets: material.morphTargets,
        morphNormals: material.morphNormals,
        maxMorphTargets: renderer.maxMorphTargets,
        maxMorphNormals: renderer.maxMorphNormals,
        numDirLights: lights.directional.length,
        numPointLights: lights.point.length,
        numSpotLights: lights.spot.length,
        numRectAreaLights: lights.rectArea.length,
        numHemiLights: lights.hemi.length,
        numClippingPlanes: nClipPlanes,
        numClipIntersection: nClipIntersection,
        dithering: material.dithering,
        shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
        shadowMapType: renderer.shadowMap.type,
        toneMapping: renderer.toneMapping,
        physicallyCorrectLights: renderer.physicallyCorrectLights,
        premultipliedAlpha: material.premultipliedAlpha,
        alphaTest: material.alphaTest,
        doubleSided: material.side === DoubleSide,
        flipSided: material.side === BackSide,
        depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false
      };
      return parameters;
    };
    this.getProgramCode = function(material, parameters) {
      var array = [];
      if (parameters.shaderID) {
        array.push(parameters.shaderID);
      } else {
        array.push(material.fragmentShader);
        array.push(material.vertexShader);
      }
      if (material.defines !== void 0) {
        for (var name in material.defines) {
          array.push(name);
          array.push(material.defines[name]);
        }
      }
      for (var i = 0; i < parameterNames.length; i++) {
        array.push(parameters[parameterNames[i]]);
      }
      array.push(material.onBeforeCompile.toString());
      array.push(renderer.gammaOutput);
      array.push(renderer.gammaFactor);
      return array.join();
    };
    this.acquireProgram = function(material, shader, parameters, code) {
      var program;
      for (var p2 = 0, pl = programs.length; p2 < pl; p2++) {
        var programInfo = programs[p2];
        if (programInfo.code === code) {
          program = programInfo;
          ++program.usedTimes;
          break;
        }
      }
      if (program === void 0) {
        program = new WebGLProgram(renderer, extensions, code, material, shader, parameters, capabilities, textures);
        programs.push(program);
      }
      return program;
    };
    this.releaseProgram = function(program) {
      if (--program.usedTimes === 0) {
        var i = programs.indexOf(program);
        programs[i] = programs[programs.length - 1];
        programs.pop();
        program.destroy();
      }
    };
    this.programs = programs;
  }
  function WebGLProperties() {
    var properties = /* @__PURE__ */ new WeakMap();
    function get(object) {
      var map = properties.get(object);
      if (map === void 0) {
        map = {};
        properties.set(object, map);
      }
      return map;
    }
    function remove(object) {
      properties.delete(object);
    }
    function update3(object, key, value) {
      properties.get(object)[key] = value;
    }
    function dispose() {
      properties = /* @__PURE__ */ new WeakMap();
    }
    return {
      get,
      remove,
      update: update3,
      dispose
    };
  }
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.program !== b.program) {
      return a.program.id - b.program.id;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }
  function WebGLRenderList() {
    var renderItems = [];
    var renderItemsIndex = 0;
    var opaque = [];
    var transparent = [];
    var defaultProgram = { id: -1 };
    function init3() {
      renderItemsIndex = 0;
      opaque.length = 0;
      transparent.length = 0;
    }
    function getNextRenderItem(object, geometry2, material, groupOrder, z, group) {
      var renderItem = renderItems[renderItemsIndex];
      if (renderItem === void 0) {
        renderItem = {
          id: object.id,
          object,
          geometry: geometry2,
          material,
          program: material.program || defaultProgram,
          groupOrder,
          renderOrder: object.renderOrder,
          z,
          group
        };
        renderItems[renderItemsIndex] = renderItem;
      } else {
        renderItem.id = object.id;
        renderItem.object = object;
        renderItem.geometry = geometry2;
        renderItem.material = material;
        renderItem.program = material.program || defaultProgram;
        renderItem.groupOrder = groupOrder;
        renderItem.renderOrder = object.renderOrder;
        renderItem.z = z;
        renderItem.group = group;
      }
      renderItemsIndex++;
      return renderItem;
    }
    function push(object, geometry2, material, groupOrder, z, group) {
      var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).push(renderItem);
    }
    function unshift(object, geometry2, material, groupOrder, z, group) {
      var renderItem = getNextRenderItem(object, geometry2, material, groupOrder, z, group);
      (material.transparent === true ? transparent : opaque).unshift(renderItem);
    }
    function sort() {
      if (opaque.length > 1)
        opaque.sort(painterSortStable);
      if (transparent.length > 1)
        transparent.sort(reversePainterSortStable);
    }
    return {
      opaque,
      transparent,
      init: init3,
      push,
      unshift,
      sort
    };
  }
  function WebGLRenderLists() {
    var lists = {};
    function onSceneDispose(event) {
      var scene2 = event.target;
      scene2.removeEventListener("dispose", onSceneDispose);
      delete lists[scene2.id];
    }
    function get(scene2, camera2) {
      var cameras = lists[scene2.id];
      var list;
      if (cameras === void 0) {
        list = new WebGLRenderList();
        lists[scene2.id] = {};
        lists[scene2.id][camera2.id] = list;
        scene2.addEventListener("dispose", onSceneDispose);
      } else {
        list = cameras[camera2.id];
        if (list === void 0) {
          list = new WebGLRenderList();
          cameras[camera2.id] = list;
        }
      }
      return list;
    }
    function dispose() {
      lists = {};
    }
    return {
      get,
      dispose
    };
  }
  function UniformsCache() {
    var lights = {};
    return {
      get: function(light2) {
        if (lights[light2.id] !== void 0) {
          return lights[light2.id];
        }
        var uniforms;
        switch (light2.type) {
          case "DirectionalLight":
            uniforms = {
              direction: new Vector3(),
              color: new Color(),
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "SpotLight":
            uniforms = {
              position: new Vector3(),
              direction: new Vector3(),
              color: new Color(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2()
            };
            break;
          case "PointLight":
            uniforms = {
              position: new Vector3(),
              color: new Color(),
              distance: 0,
              decay: 0,
              shadow: false,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new Vector2(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case "HemisphereLight":
            uniforms = {
              direction: new Vector3(),
              skyColor: new Color(),
              groundColor: new Color()
            };
            break;
          case "RectAreaLight":
            uniforms = {
              color: new Color(),
              position: new Vector3(),
              halfWidth: new Vector3(),
              halfHeight: new Vector3()
            };
            break;
        }
        lights[light2.id] = uniforms;
        return uniforms;
      }
    };
  }
  var count = 0;
  function WebGLLights() {
    var cache = new UniformsCache();
    var state2 = {
      id: count++,
      hash: {
        stateID: -1,
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        shadowsLength: -1
      },
      ambient: [0, 0, 0],
      directional: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotShadowMap: [],
      spotShadowMatrix: [],
      rectArea: [],
      point: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: []
    };
    var vector3 = new Vector3();
    var matrix4 = new Matrix4();
    var matrix42 = new Matrix4();
    function setup(lights, shadows, camera2) {
      var r = 0, g = 0, b = 0;
      var directionalLength = 0;
      var pointLength = 0;
      var spotLength = 0;
      var rectAreaLength = 0;
      var hemiLength = 0;
      var viewMatrix = camera2.matrixWorldInverse;
      for (var i = 0, l = lights.length; i < l; i++) {
        var light2 = lights[i];
        var color = light2.color;
        var intensity = light2.intensity;
        var distance = light2.distance;
        var shadowMap = light2.shadow && light2.shadow.map ? light2.shadow.map.texture : null;
        if (light2.isAmbientLight) {
          r += color.r * intensity;
          g += color.g * intensity;
          b += color.b * intensity;
        } else if (light2.isDirectionalLight) {
          var uniforms = cache.get(light2);
          uniforms.color.copy(light2.color).multiplyScalar(light2.intensity);
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          vector3.setFromMatrixPosition(light2.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.shadow = light2.castShadow;
          if (light2.castShadow) {
            var shadow = light2.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
          }
          state2.directionalShadowMap[directionalLength] = shadowMap;
          state2.directionalShadowMatrix[directionalLength] = light2.shadow.matrix;
          state2.directional[directionalLength] = uniforms;
          directionalLength++;
        } else if (light2.isSpotLight) {
          var uniforms = cache.get(light2);
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.distance = distance;
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          vector3.setFromMatrixPosition(light2.target.matrixWorld);
          uniforms.direction.sub(vector3);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.coneCos = Math.cos(light2.angle);
          uniforms.penumbraCos = Math.cos(light2.angle * (1 - light2.penumbra));
          uniforms.decay = light2.decay;
          uniforms.shadow = light2.castShadow;
          if (light2.castShadow) {
            var shadow = light2.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
          }
          state2.spotShadowMap[spotLength] = shadowMap;
          state2.spotShadowMatrix[spotLength] = light2.shadow.matrix;
          state2.spot[spotLength] = uniforms;
          spotLength++;
        } else if (light2.isRectAreaLight) {
          var uniforms = cache.get(light2);
          uniforms.color.copy(color).multiplyScalar(intensity);
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          matrix42.identity();
          matrix4.copy(light2.matrixWorld);
          matrix4.premultiply(viewMatrix);
          matrix42.extractRotation(matrix4);
          uniforms.halfWidth.set(light2.width * 0.5, 0, 0);
          uniforms.halfHeight.set(0, light2.height * 0.5, 0);
          uniforms.halfWidth.applyMatrix4(matrix42);
          uniforms.halfHeight.applyMatrix4(matrix42);
          state2.rectArea[rectAreaLength] = uniforms;
          rectAreaLength++;
        } else if (light2.isPointLight) {
          var uniforms = cache.get(light2);
          uniforms.position.setFromMatrixPosition(light2.matrixWorld);
          uniforms.position.applyMatrix4(viewMatrix);
          uniforms.color.copy(light2.color).multiplyScalar(light2.intensity);
          uniforms.distance = light2.distance;
          uniforms.decay = light2.decay;
          uniforms.shadow = light2.castShadow;
          if (light2.castShadow) {
            var shadow = light2.shadow;
            uniforms.shadowBias = shadow.bias;
            uniforms.shadowRadius = shadow.radius;
            uniforms.shadowMapSize = shadow.mapSize;
            uniforms.shadowCameraNear = shadow.camera.near;
            uniforms.shadowCameraFar = shadow.camera.far;
          }
          state2.pointShadowMap[pointLength] = shadowMap;
          state2.pointShadowMatrix[pointLength] = light2.shadow.matrix;
          state2.point[pointLength] = uniforms;
          pointLength++;
        } else if (light2.isHemisphereLight) {
          var uniforms = cache.get(light2);
          uniforms.direction.setFromMatrixPosition(light2.matrixWorld);
          uniforms.direction.transformDirection(viewMatrix);
          uniforms.direction.normalize();
          uniforms.skyColor.copy(light2.color).multiplyScalar(intensity);
          uniforms.groundColor.copy(light2.groundColor).multiplyScalar(intensity);
          state2.hemi[hemiLength] = uniforms;
          hemiLength++;
        }
      }
      state2.ambient[0] = r;
      state2.ambient[1] = g;
      state2.ambient[2] = b;
      state2.directional.length = directionalLength;
      state2.spot.length = spotLength;
      state2.rectArea.length = rectAreaLength;
      state2.point.length = pointLength;
      state2.hemi.length = hemiLength;
      state2.hash.stateID = state2.id;
      state2.hash.directionalLength = directionalLength;
      state2.hash.pointLength = pointLength;
      state2.hash.spotLength = spotLength;
      state2.hash.rectAreaLength = rectAreaLength;
      state2.hash.hemiLength = hemiLength;
      state2.hash.shadowsLength = shadows.length;
    }
    return {
      setup,
      state: state2
    };
  }
  function WebGLRenderState() {
    var lights = new WebGLLights();
    var lightsArray = [];
    var shadowsArray = [];
    function init3() {
      lightsArray.length = 0;
      shadowsArray.length = 0;
    }
    function pushLight(light2) {
      lightsArray.push(light2);
    }
    function pushShadow(shadowLight) {
      shadowsArray.push(shadowLight);
    }
    function setupLights(camera2) {
      lights.setup(lightsArray, shadowsArray, camera2);
    }
    var state2 = {
      lightsArray,
      shadowsArray,
      lights
    };
    return {
      init: init3,
      state: state2,
      setupLights,
      pushLight,
      pushShadow
    };
  }
  function WebGLRenderStates() {
    var renderStates = {};
    function onSceneDispose(event) {
      var scene2 = event.target;
      scene2.removeEventListener("dispose", onSceneDispose);
      delete renderStates[scene2.id];
    }
    function get(scene2, camera2) {
      var renderState;
      if (renderStates[scene2.id] === void 0) {
        renderState = new WebGLRenderState();
        renderStates[scene2.id] = {};
        renderStates[scene2.id][camera2.id] = renderState;
        scene2.addEventListener("dispose", onSceneDispose);
      } else {
        if (renderStates[scene2.id][camera2.id] === void 0) {
          renderState = new WebGLRenderState();
          renderStates[scene2.id][camera2.id] = renderState;
        } else {
          renderState = renderStates[scene2.id][camera2.id];
        }
      }
      return renderState;
    }
    function dispose() {
      renderStates = {};
    }
    return {
      get,
      dispose
    };
  }
  function MeshDepthMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
  }
  MeshDepthMaterial.prototype = Object.create(Material.prototype);
  MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
  MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
  MeshDepthMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.depthPacking = source.depthPacking;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  };
  function MeshDistanceMaterial(parameters) {
    Material.call(this);
    this.type = "MeshDistanceMaterial";
    this.referencePosition = new Vector3();
    this.nearDistance = 1;
    this.farDistance = 1e3;
    this.skinning = false;
    this.morphTargets = false;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.fog = false;
    this.lights = false;
    this.setValues(parameters);
  }
  MeshDistanceMaterial.prototype = Object.create(Material.prototype);
  MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
  MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
  MeshDistanceMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.referencePosition.copy(source.referencePosition);
    this.nearDistance = source.nearDistance;
    this.farDistance = source.farDistance;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  };
  function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
    var _frustum = new Frustum(), _projScreenMatrix = new Matrix4(), _shadowMapSize = new Vector2(), _maxShadowMapSize = new Vector2(maxTextureSize, maxTextureSize), _lookTarget = new Vector3(), _lightPositionWorld = new Vector3(), _MorphingFlag = 1, _SkinningFlag = 2, _NumberOfMaterialVariants = (_MorphingFlag | _SkinningFlag) + 1, _depthMaterials = new Array(_NumberOfMaterialVariants), _distanceMaterials = new Array(_NumberOfMaterialVariants), _materialCache = {};
    var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
    var cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0)
    ];
    var cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1)
    ];
    var cube2DViewPorts = [
      new Vector4(),
      new Vector4(),
      new Vector4(),
      new Vector4(),
      new Vector4(),
      new Vector4()
    ];
    for (var i = 0; i !== _NumberOfMaterialVariants; ++i) {
      var useMorphing = (i & _MorphingFlag) !== 0;
      var useSkinning = (i & _SkinningFlag) !== 0;
      var depthMaterial = new MeshDepthMaterial({
        depthPacking: RGBADepthPacking,
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _depthMaterials[i] = depthMaterial;
      var distanceMaterial = new MeshDistanceMaterial({
        morphTargets: useMorphing,
        skinning: useSkinning
      });
      _distanceMaterials[i] = distanceMaterial;
    }
    var scope = this;
    this.enabled = false;
    this.autoUpdate = true;
    this.needsUpdate = false;
    this.type = PCFShadowMap;
    this.render = function(lights, scene2, camera2) {
      if (scope.enabled === false)
        return;
      if (scope.autoUpdate === false && scope.needsUpdate === false)
        return;
      if (lights.length === 0)
        return;
      var currentRenderTarget = _renderer.getRenderTarget();
      var _state = _renderer.state;
      _state.setBlending(NoBlending);
      _state.buffers.color.setClear(1, 1, 1, 1);
      _state.buffers.depth.setTest(true);
      _state.setScissorTest(false);
      var faceCount;
      for (var i2 = 0, il = lights.length; i2 < il; i2++) {
        var light2 = lights[i2];
        var shadow = light2.shadow;
        var isPointLight = light2 && light2.isPointLight;
        if (shadow === void 0) {
          console.warn("THREE.WebGLShadowMap:", light2, "has no shadow.");
          continue;
        }
        var shadowCamera = shadow.camera;
        _shadowMapSize.copy(shadow.mapSize);
        _shadowMapSize.min(_maxShadowMapSize);
        if (isPointLight) {
          var vpWidth = _shadowMapSize.x;
          var vpHeight = _shadowMapSize.y;
          cube2DViewPorts[0].set(vpWidth * 2, vpHeight, vpWidth, vpHeight);
          cube2DViewPorts[1].set(0, vpHeight, vpWidth, vpHeight);
          cube2DViewPorts[2].set(vpWidth * 3, vpHeight, vpWidth, vpHeight);
          cube2DViewPorts[3].set(vpWidth, vpHeight, vpWidth, vpHeight);
          cube2DViewPorts[4].set(vpWidth * 3, 0, vpWidth, vpHeight);
          cube2DViewPorts[5].set(vpWidth, 0, vpWidth, vpHeight);
          _shadowMapSize.x *= 4;
          _shadowMapSize.y *= 2;
        }
        if (shadow.map === null) {
          var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
          shadow.map.texture.name = light2.name + ".shadowMap";
          shadowCamera.updateProjectionMatrix();
        }
        if (shadow.isSpotLightShadow) {
          shadow.update(light2);
        }
        var shadowMap = shadow.map;
        var shadowMatrix = shadow.matrix;
        _lightPositionWorld.setFromMatrixPosition(light2.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld);
        if (isPointLight) {
          faceCount = 6;
          shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        } else {
          faceCount = 1;
          _lookTarget.setFromMatrixPosition(light2.target.matrixWorld);
          shadowCamera.lookAt(_lookTarget);
          shadowCamera.updateMatrixWorld();
          shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
          shadowMatrix.multiply(shadowCamera.projectionMatrix);
          shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
        }
        _renderer.setRenderTarget(shadowMap);
        _renderer.clear();
        for (var face = 0; face < faceCount; face++) {
          if (isPointLight) {
            _lookTarget.copy(shadowCamera.position);
            _lookTarget.add(cubeDirections[face]);
            shadowCamera.up.copy(cubeUps[face]);
            shadowCamera.lookAt(_lookTarget);
            shadowCamera.updateMatrixWorld();
            var vpDimensions = cube2DViewPorts[face];
            _state.viewport(vpDimensions);
          }
          _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
          _frustum.setFromMatrix(_projScreenMatrix);
          renderObject(scene2, camera2, shadowCamera, isPointLight);
        }
      }
      scope.needsUpdate = false;
      _renderer.setRenderTarget(currentRenderTarget);
    };
    function getDepthMaterial(object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar) {
      var geometry2 = object.geometry;
      var result = null;
      var materialVariants = _depthMaterials;
      var customMaterial = object.customDepthMaterial;
      if (isPointLight) {
        materialVariants = _distanceMaterials;
        customMaterial = object.customDistanceMaterial;
      }
      if (!customMaterial) {
        var useMorphing2 = false;
        if (material.morphTargets) {
          if (geometry2 && geometry2.isBufferGeometry) {
            useMorphing2 = geometry2.morphAttributes && geometry2.morphAttributes.position && geometry2.morphAttributes.position.length > 0;
          } else if (geometry2 && geometry2.isGeometry) {
            useMorphing2 = geometry2.morphTargets && geometry2.morphTargets.length > 0;
          }
        }
        if (object.isSkinnedMesh && material.skinning === false) {
          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
        }
        var useSkinning2 = object.isSkinnedMesh && material.skinning;
        var variantIndex = 0;
        if (useMorphing2)
          variantIndex |= _MorphingFlag;
        if (useSkinning2)
          variantIndex |= _SkinningFlag;
        result = materialVariants[variantIndex];
      } else {
        result = customMaterial;
      }
      if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
        var keyA = result.uuid, keyB = material.uuid;
        var materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        var cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
      result.visible = material.visible;
      result.wireframe = material.wireframe;
      result.side = material.shadowSide != null ? material.shadowSide : shadowSide[material.side];
      result.clipShadows = material.clipShadows;
      result.clippingPlanes = material.clippingPlanes;
      result.clipIntersection = material.clipIntersection;
      result.wireframeLinewidth = material.wireframeLinewidth;
      result.linewidth = material.linewidth;
      if (isPointLight && result.isMeshDistanceMaterial) {
        result.referencePosition.copy(lightPositionWorld);
        result.nearDistance = shadowCameraNear;
        result.farDistance = shadowCameraFar;
      }
      return result;
    }
    function renderObject(object, camera2, shadowCamera, isPointLight) {
      if (object.visible === false)
        return;
      var visible = object.layers.test(camera2.layers);
      if (visible && (object.isMesh || object.isLine || object.isPoints)) {
        if (object.castShadow && (!object.frustumCulled || _frustum.intersectsObject(object))) {
          object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
          var geometry2 = _objects.update(object);
          var material = object.material;
          if (Array.isArray(material)) {
            var groups = geometry2.groups;
            for (var k = 0, kl = groups.length; k < kl; k++) {
              var group = groups[k];
              var groupMaterial = material[group.materialIndex];
              if (groupMaterial && groupMaterial.visible) {
                var depthMaterial2 = getDepthMaterial(object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
                _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, group);
              }
            }
          } else if (material.visible) {
            var depthMaterial2 = getDepthMaterial(object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far);
            _renderer.renderBufferDirect(shadowCamera, null, geometry2, depthMaterial2, object, null);
          }
        }
      }
      var children2 = object.children;
      for (var i2 = 0, l = children2.length; i2 < l; i2++) {
        renderObject(children2[i2], camera2, shadowCamera, isPointLight);
      }
    }
  }
  function WebGLState(gl, extensions, utils2, capabilities) {
    function ColorBuffer() {
      var locked = false;
      var color = new Vector4();
      var currentColorMask = null;
      var currentColorClear = new Vector4(0, 0, 0, 0);
      return {
        setMask: function(colorMask) {
          if (currentColorMask !== colorMask && !locked) {
            gl.colorMask(colorMask, colorMask, colorMask, colorMask);
            currentColorMask = colorMask;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(r, g, b, a, premultipliedAlpha) {
          if (premultipliedAlpha === true) {
            r *= a;
            g *= a;
            b *= a;
          }
          color.set(r, g, b, a);
          if (currentColorClear.equals(color) === false) {
            gl.clearColor(r, g, b, a);
            currentColorClear.copy(color);
          }
        },
        reset: function() {
          locked = false;
          currentColorMask = null;
          currentColorClear.set(-1, 0, 0, 0);
        }
      };
    }
    function DepthBuffer() {
      var locked = false;
      var currentDepthMask = null;
      var currentDepthFunc = null;
      var currentDepthClear = null;
      return {
        setTest: function(depthTest) {
          if (depthTest) {
            enable(2929);
          } else {
            disable(2929);
          }
        },
        setMask: function(depthMask) {
          if (currentDepthMask !== depthMask && !locked) {
            gl.depthMask(depthMask);
            currentDepthMask = depthMask;
          }
        },
        setFunc: function(depthFunc) {
          if (currentDepthFunc !== depthFunc) {
            if (depthFunc) {
              switch (depthFunc) {
                case NeverDepth:
                  gl.depthFunc(512);
                  break;
                case AlwaysDepth:
                  gl.depthFunc(519);
                  break;
                case LessDepth:
                  gl.depthFunc(513);
                  break;
                case LessEqualDepth:
                  gl.depthFunc(515);
                  break;
                case EqualDepth:
                  gl.depthFunc(514);
                  break;
                case GreaterEqualDepth:
                  gl.depthFunc(518);
                  break;
                case GreaterDepth:
                  gl.depthFunc(516);
                  break;
                case NotEqualDepth:
                  gl.depthFunc(517);
                  break;
                default:
                  gl.depthFunc(515);
              }
            } else {
              gl.depthFunc(515);
            }
            currentDepthFunc = depthFunc;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(depth) {
          if (currentDepthClear !== depth) {
            gl.clearDepth(depth);
            currentDepthClear = depth;
          }
        },
        reset: function() {
          locked = false;
          currentDepthMask = null;
          currentDepthFunc = null;
          currentDepthClear = null;
        }
      };
    }
    function StencilBuffer() {
      var locked = false;
      var currentStencilMask = null;
      var currentStencilFunc = null;
      var currentStencilRef = null;
      var currentStencilFuncMask = null;
      var currentStencilFail = null;
      var currentStencilZFail = null;
      var currentStencilZPass = null;
      var currentStencilClear = null;
      return {
        setTest: function(stencilTest) {
          if (stencilTest) {
            enable(2960);
          } else {
            disable(2960);
          }
        },
        setMask: function(stencilMask) {
          if (currentStencilMask !== stencilMask && !locked) {
            gl.stencilMask(stencilMask);
            currentStencilMask = stencilMask;
          }
        },
        setFunc: function(stencilFunc, stencilRef, stencilMask) {
          if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
            gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
            currentStencilFunc = stencilFunc;
            currentStencilRef = stencilRef;
            currentStencilFuncMask = stencilMask;
          }
        },
        setOp: function(stencilFail, stencilZFail, stencilZPass) {
          if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
            gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
            currentStencilFail = stencilFail;
            currentStencilZFail = stencilZFail;
            currentStencilZPass = stencilZPass;
          }
        },
        setLocked: function(lock) {
          locked = lock;
        },
        setClear: function(stencil) {
          if (currentStencilClear !== stencil) {
            gl.clearStencil(stencil);
            currentStencilClear = stencil;
          }
        },
        reset: function() {
          locked = false;
          currentStencilMask = null;
          currentStencilFunc = null;
          currentStencilRef = null;
          currentStencilFuncMask = null;
          currentStencilFail = null;
          currentStencilZFail = null;
          currentStencilZPass = null;
          currentStencilClear = null;
        }
      };
    }
    var colorBuffer = new ColorBuffer();
    var depthBuffer = new DepthBuffer();
    var stencilBuffer = new StencilBuffer();
    var maxVertexAttributes = gl.getParameter(34921);
    var newAttributes = new Uint8Array(maxVertexAttributes);
    var enabledAttributes = new Uint8Array(maxVertexAttributes);
    var attributeDivisors = new Uint8Array(maxVertexAttributes);
    var enabledCapabilities = {};
    var compressedTextureFormats = null;
    var currentProgram = null;
    var currentBlendingEnabled = null;
    var currentBlending = null;
    var currentBlendEquation = null;
    var currentBlendSrc = null;
    var currentBlendDst = null;
    var currentBlendEquationAlpha = null;
    var currentBlendSrcAlpha = null;
    var currentBlendDstAlpha = null;
    var currentPremultipledAlpha = false;
    var currentFlipSided = null;
    var currentCullFace = null;
    var currentLineWidth = null;
    var currentPolygonOffsetFactor = null;
    var currentPolygonOffsetUnits = null;
    var maxTextures = gl.getParameter(35661);
    var lineWidthAvailable = false;
    var version = 0;
    var glVersion = gl.getParameter(7938);
    if (glVersion.indexOf("WebGL") !== -1) {
      version = parseFloat(/^WebGL\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 1;
    } else if (glVersion.indexOf("OpenGL ES") !== -1) {
      version = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);
      lineWidthAvailable = version >= 2;
    }
    var currentTextureSlot = null;
    var currentBoundTextures = {};
    var currentScissor = new Vector4();
    var currentViewport = new Vector4();
    function createTexture(type, target, count2) {
      var data = new Uint8Array(4);
      var texture = gl.createTexture();
      gl.bindTexture(type, texture);
      gl.texParameteri(type, 10241, 9728);
      gl.texParameteri(type, 10240, 9728);
      for (var i = 0; i < count2; i++) {
        gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
      }
      return texture;
    }
    var emptyTextures = {};
    emptyTextures[3553] = createTexture(3553, 3553, 1);
    emptyTextures[34067] = createTexture(34067, 34069, 6);
    colorBuffer.setClear(0, 0, 0, 1);
    depthBuffer.setClear(1);
    stencilBuffer.setClear(0);
    enable(2929);
    depthBuffer.setFunc(LessEqualDepth);
    setFlipSided(false);
    setCullFace(CullFaceBack);
    enable(2884);
    setBlending(NoBlending);
    function initAttributes() {
      for (var i = 0, l = newAttributes.length; i < l; i++) {
        newAttributes[i] = 0;
      }
    }
    function enableAttribute(attribute) {
      enableAttributeAndDivisor(attribute, 0);
    }
    function enableAttributeAndDivisor(attribute, meshPerAttribute) {
      newAttributes[attribute] = 1;
      if (enabledAttributes[attribute] === 0) {
        gl.enableVertexAttribArray(attribute);
        enabledAttributes[attribute] = 1;
      }
      if (attributeDivisors[attribute] !== meshPerAttribute) {
        var extension = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
        extension[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
        attributeDivisors[attribute] = meshPerAttribute;
      }
    }
    function disableUnusedAttributes() {
      for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
        if (enabledAttributes[i] !== newAttributes[i]) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
    }
    function enable(id) {
      if (enabledCapabilities[id] !== true) {
        gl.enable(id);
        enabledCapabilities[id] = true;
      }
    }
    function disable(id) {
      if (enabledCapabilities[id] !== false) {
        gl.disable(id);
        enabledCapabilities[id] = false;
      }
    }
    function getCompressedTextureFormats() {
      if (compressedTextureFormats === null) {
        compressedTextureFormats = [];
        if (extensions.get("WEBGL_compressed_texture_pvrtc") || extensions.get("WEBGL_compressed_texture_s3tc") || extensions.get("WEBGL_compressed_texture_etc1") || extensions.get("WEBGL_compressed_texture_astc")) {
          var formats = gl.getParameter(34467);
          for (var i = 0; i < formats.length; i++) {
            compressedTextureFormats.push(formats[i]);
          }
        }
      }
      return compressedTextureFormats;
    }
    function useProgram(program) {
      if (currentProgram !== program) {
        gl.useProgram(program);
        currentProgram = program;
        return true;
      }
      return false;
    }
    function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
      if (blending === NoBlending) {
        if (currentBlendingEnabled) {
          disable(3042);
          currentBlendingEnabled = false;
        }
        return;
      }
      if (!currentBlendingEnabled) {
        enable(3042);
        currentBlendingEnabled = true;
      }
      if (blending !== CustomBlending) {
        if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
          if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
            gl.blendEquation(32774);
            currentBlendEquation = AddEquation;
            currentBlendEquationAlpha = AddEquation;
          }
          if (premultipliedAlpha) {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(1, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(1, 1);
                break;
              case SubtractiveBlending:
                gl.blendFuncSeparate(0, 0, 769, 771);
                break;
              case MultiplyBlending:
                gl.blendFuncSeparate(0, 768, 0, 770);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          } else {
            switch (blending) {
              case NormalBlending:
                gl.blendFuncSeparate(770, 771, 1, 771);
                break;
              case AdditiveBlending:
                gl.blendFunc(770, 1);
                break;
              case SubtractiveBlending:
                gl.blendFunc(0, 769);
                break;
              case MultiplyBlending:
                gl.blendFunc(0, 768);
                break;
              default:
                console.error("THREE.WebGLState: Invalid blending: ", blending);
                break;
            }
          }
          currentBlendSrc = null;
          currentBlendDst = null;
          currentBlendSrcAlpha = null;
          currentBlendDstAlpha = null;
          currentBlending = blending;
          currentPremultipledAlpha = premultipliedAlpha;
        }
        return;
      }
      blendEquationAlpha = blendEquationAlpha || blendEquation;
      blendSrcAlpha = blendSrcAlpha || blendSrc;
      blendDstAlpha = blendDstAlpha || blendDst;
      if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
        gl.blendEquationSeparate(utils2.convert(blendEquation), utils2.convert(blendEquationAlpha));
        currentBlendEquation = blendEquation;
        currentBlendEquationAlpha = blendEquationAlpha;
      }
      if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
        gl.blendFuncSeparate(utils2.convert(blendSrc), utils2.convert(blendDst), utils2.convert(blendSrcAlpha), utils2.convert(blendDstAlpha));
        currentBlendSrc = blendSrc;
        currentBlendDst = blendDst;
        currentBlendSrcAlpha = blendSrcAlpha;
        currentBlendDstAlpha = blendDstAlpha;
      }
      currentBlending = blending;
      currentPremultipledAlpha = null;
    }
    function setMaterial(material, frontFaceCW) {
      material.side === DoubleSide ? disable(2884) : enable(2884);
      var flipSided = material.side === BackSide;
      if (frontFaceCW)
        flipSided = !flipSided;
      setFlipSided(flipSided);
      material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
      depthBuffer.setFunc(material.depthFunc);
      depthBuffer.setTest(material.depthTest);
      depthBuffer.setMask(material.depthWrite);
      colorBuffer.setMask(material.colorWrite);
      setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    }
    function setFlipSided(flipSided) {
      if (currentFlipSided !== flipSided) {
        if (flipSided) {
          gl.frontFace(2304);
        } else {
          gl.frontFace(2305);
        }
        currentFlipSided = flipSided;
      }
    }
    function setCullFace(cullFace) {
      if (cullFace !== CullFaceNone) {
        enable(2884);
        if (cullFace !== currentCullFace) {
          if (cullFace === CullFaceBack) {
            gl.cullFace(1029);
          } else if (cullFace === CullFaceFront) {
            gl.cullFace(1028);
          } else {
            gl.cullFace(1032);
          }
        }
      } else {
        disable(2884);
      }
      currentCullFace = cullFace;
    }
    function setLineWidth(width2) {
      if (width2 !== currentLineWidth) {
        if (lineWidthAvailable)
          gl.lineWidth(width2);
        currentLineWidth = width2;
      }
    }
    function setPolygonOffset(polygonOffset, factor, units) {
      if (polygonOffset) {
        enable(32823);
        if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
          gl.polygonOffset(factor, units);
          currentPolygonOffsetFactor = factor;
          currentPolygonOffsetUnits = units;
        }
      } else {
        disable(32823);
      }
    }
    function setScissorTest(scissorTest) {
      if (scissorTest) {
        enable(3089);
      } else {
        disable(3089);
      }
    }
    function activeTexture(webglSlot) {
      if (webglSlot === void 0)
        webglSlot = 33984 + maxTextures - 1;
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
    }
    function bindTexture(webglType, webglTexture) {
      if (currentTextureSlot === null) {
        activeTexture();
      }
      var boundTexture = currentBoundTextures[currentTextureSlot];
      if (boundTexture === void 0) {
        boundTexture = { type: void 0, texture: void 0 };
        currentBoundTextures[currentTextureSlot] = boundTexture;
      }
      if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
        gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
        boundTexture.type = webglType;
        boundTexture.texture = webglTexture;
      }
    }
    function compressedTexImage2D() {
      try {
        gl.compressedTexImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage2D() {
      try {
        gl.texImage2D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function texImage3D() {
      try {
        gl.texImage3D.apply(gl, arguments);
      } catch (error) {
        console.error("THREE.WebGLState:", error);
      }
    }
    function scissor(scissor2) {
      if (currentScissor.equals(scissor2) === false) {
        gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
        currentScissor.copy(scissor2);
      }
    }
    function viewport(viewport2) {
      if (currentViewport.equals(viewport2) === false) {
        gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
        currentViewport.copy(viewport2);
      }
    }
    function reset() {
      for (var i = 0; i < enabledAttributes.length; i++) {
        if (enabledAttributes[i] === 1) {
          gl.disableVertexAttribArray(i);
          enabledAttributes[i] = 0;
        }
      }
      enabledCapabilities = {};
      compressedTextureFormats = null;
      currentTextureSlot = null;
      currentBoundTextures = {};
      currentProgram = null;
      currentBlending = null;
      currentFlipSided = null;
      currentCullFace = null;
      colorBuffer.reset();
      depthBuffer.reset();
      stencilBuffer.reset();
    }
    return {
      buffers: {
        color: colorBuffer,
        depth: depthBuffer,
        stencil: stencilBuffer
      },
      initAttributes,
      enableAttribute,
      enableAttributeAndDivisor,
      disableUnusedAttributes,
      enable,
      disable,
      getCompressedTextureFormats,
      useProgram,
      setBlending,
      setMaterial,
      setFlipSided,
      setCullFace,
      setLineWidth,
      setPolygonOffset,
      setScissorTest,
      activeTexture,
      bindTexture,
      compressedTexImage2D,
      texImage2D,
      texImage3D,
      scissor,
      viewport,
      reset
    };
  }
  function WebGLTextures(_gl, extensions, state2, properties, capabilities, utils2, info) {
    var _videoTextures = {};
    var _canvas2;
    var useOffscreenCanvas = typeof OffscreenCanvas !== "undefined";
    function createCanvas(width2, height2) {
      return useOffscreenCanvas ? new OffscreenCanvas(width2, height2) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
    }
    function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
      var scale3 = 1;
      if (image.width > maxSize || image.height > maxSize) {
        scale3 = maxSize / Math.max(image.width, image.height);
      }
      if (scale3 < 1 || needsPowerOfTwo === true) {
        if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
          var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
          var width2 = floor(scale3 * image.width);
          var height2 = floor(scale3 * image.height);
          if (_canvas2 === void 0)
            _canvas2 = createCanvas(width2, height2);
          var canvas = needsNewCanvas ? createCanvas(width2, height2) : _canvas2;
          canvas.width = width2;
          canvas.height = height2;
          var context2 = canvas.getContext("2d");
          context2.drawImage(image, 0, 0, width2, height2);
          console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width2 + "x" + height2 + ").");
          return canvas;
        } else {
          if ("data" in image) {
            console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
          }
          return image;
        }
      }
      return image;
    }
    function isPowerOfTwo(image) {
      return _Math.isPowerOfTwo(image.width) && _Math.isPowerOfTwo(image.height);
    }
    function textureNeedsPowerOfTwo(texture) {
      if (capabilities.isWebGL2)
        return false;
      return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function textureNeedsGenerateMipmaps(texture, supportsMips) {
      return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
    }
    function generateMipmap(target, texture, width2, height2) {
      _gl.generateMipmap(target);
      var textureProperties = properties.get(texture);
      textureProperties.__maxMipLevel = Math.log(Math.max(width2, height2)) * Math.LOG2E;
    }
    function getInternalFormat(glFormat, glType) {
      if (!capabilities.isWebGL2)
        return glFormat;
      var internalFormat = glFormat;
      if (glFormat === 6403) {
        if (glType === 5126)
          internalFormat = 33326;
        if (glType === 5131)
          internalFormat = 33325;
        if (glType === 5121)
          internalFormat = 33321;
      }
      if (glFormat === 6407) {
        if (glType === 5126)
          internalFormat = 34837;
        if (glType === 5131)
          internalFormat = 34843;
        if (glType === 5121)
          internalFormat = 32849;
      }
      if (glFormat === 6408) {
        if (glType === 5126)
          internalFormat = 34836;
        if (glType === 5131)
          internalFormat = 34842;
        if (glType === 5121)
          internalFormat = 32856;
      }
      if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
        extensions.get("EXT_color_buffer_float");
      } else if (internalFormat === 34843 || internalFormat === 34837) {
        console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
      }
      return internalFormat;
    }
    function filterFallback(f) {
      if (f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter) {
        return 9728;
      }
      return 9729;
    }
    function onTextureDispose(event) {
      var texture = event.target;
      texture.removeEventListener("dispose", onTextureDispose);
      deallocateTexture(texture);
      if (texture.isVideoTexture) {
        delete _videoTextures[texture.id];
      }
      info.memory.textures--;
    }
    function onRenderTargetDispose(event) {
      var renderTarget = event.target;
      renderTarget.removeEventListener("dispose", onRenderTargetDispose);
      deallocateRenderTarget(renderTarget);
      info.memory.textures--;
    }
    function deallocateTexture(texture) {
      var textureProperties = properties.get(texture);
      if (textureProperties.__webglInit === void 0)
        return;
      _gl.deleteTexture(textureProperties.__webglTexture);
      properties.remove(texture);
    }
    function deallocateRenderTarget(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var textureProperties = properties.get(renderTarget.texture);
      if (!renderTarget)
        return;
      if (textureProperties.__webglTexture !== void 0) {
        _gl.deleteTexture(textureProperties.__webglTexture);
      }
      if (renderTarget.depthTexture) {
        renderTarget.depthTexture.dispose();
      }
      if (renderTarget.isWebGLRenderTargetCube) {
        for (var i = 0; i < 6; i++) {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
          if (renderTargetProperties.__webglDepthbuffer)
            _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
        }
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      }
      properties.remove(renderTarget.texture);
      properties.remove(renderTarget);
    }
    var textureUnits = 0;
    function resetTextureUnits() {
      textureUnits = 0;
    }
    function allocateTextureUnit() {
      var textureUnit = textureUnits;
      if (textureUnit >= capabilities.maxTextures) {
        console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
      }
      textureUnits += 1;
      return textureUnit;
    }
    function setTexture2D(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.isVideoTexture)
        updateVideoTexture(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        var image = texture.image;
        if (image === void 0) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
        } else if (image.complete === false) {
          console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
        } else {
          uploadTexture(textureProperties, texture, slot);
          return;
        }
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(3553, textureProperties.__webglTexture);
    }
    function setTexture2DArray(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(35866, textureProperties.__webglTexture);
    }
    function setTexture3D(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.version > 0 && textureProperties.__version !== texture.version) {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
      state2.activeTexture(33984 + slot);
      state2.bindTexture(32879, textureProperties.__webglTexture);
    }
    function setTextureCube(texture, slot) {
      var textureProperties = properties.get(texture);
      if (texture.image.length === 6) {
        if (texture.version > 0 && textureProperties.__version !== texture.version) {
          initTexture(textureProperties, texture);
          state2.activeTexture(33984 + slot);
          state2.bindTexture(34067, textureProperties.__webglTexture);
          _gl.pixelStorei(37440, texture.flipY);
          var isCompressed = texture && texture.isCompressedTexture;
          var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
          var cubeImage = [];
          for (var i = 0; i < 6; i++) {
            if (!isCompressed && !isDataTexture) {
              cubeImage[i] = resizeImage(texture.image[i], false, true, capabilities.maxCubemapSize);
            } else {
              cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
            }
          }
          var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils2.convert(texture.format), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
          setTextureParameters(34067, texture, supportsMips);
          for (var i = 0; i < 6; i++) {
            if (!isCompressed) {
              if (isDataTexture) {
                state2.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
              } else {
                state2.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
              }
            } else {
              var mipmap, mipmaps = cubeImage[i].mipmaps;
              for (var j = 0, jl = mipmaps.length; j < jl; j++) {
                mipmap = mipmaps[j];
                if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
                  if (state2.getCompressedTextureFormats().indexOf(glFormat) > -1) {
                    state2.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                  } else {
                    console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
                  }
                } else {
                  state2.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
                }
              }
            }
          }
          if (!isCompressed) {
            textureProperties.__maxMipLevel = 0;
          } else {
            textureProperties.__maxMipLevel = mipmaps.length - 1;
          }
          if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
            generateMipmap(34067, texture, image.width, image.height);
          }
          textureProperties.__version = texture.version;
          if (texture.onUpdate)
            texture.onUpdate(texture);
        } else {
          state2.activeTexture(33984 + slot);
          state2.bindTexture(34067, textureProperties.__webglTexture);
        }
      }
    }
    function setTextureCubeDynamic(texture, slot) {
      state2.activeTexture(33984 + slot);
      state2.bindTexture(34067, properties.get(texture).__webglTexture);
    }
    function setTextureParameters(textureType, texture, supportsMips) {
      var extension;
      if (supportsMips) {
        _gl.texParameteri(textureType, 10242, utils2.convert(texture.wrapS));
        _gl.texParameteri(textureType, 10243, utils2.convert(texture.wrapT));
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, utils2.convert(texture.wrapR));
        }
        _gl.texParameteri(textureType, 10240, utils2.convert(texture.magFilter));
        _gl.texParameteri(textureType, 10241, utils2.convert(texture.minFilter));
      } else {
        _gl.texParameteri(textureType, 10242, 33071);
        _gl.texParameteri(textureType, 10243, 33071);
        if (textureType === 32879 || textureType === 35866) {
          _gl.texParameteri(textureType, 32882, 33071);
        }
        if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
        }
        _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
        _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
        if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
          console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
        }
      }
      extension = extensions.get("EXT_texture_filter_anisotropic");
      if (extension) {
        if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null)
          return;
        if (texture.type === HalfFloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null)
          return;
        if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
          _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
          properties.get(texture).__currentAnisotropy = texture.anisotropy;
        }
      }
    }
    function initTexture(textureProperties, texture) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        texture.addEventListener("dispose", onTextureDispose);
        textureProperties.__webglTexture = _gl.createTexture();
        info.memory.textures++;
      }
    }
    function uploadTexture(textureProperties, texture, slot) {
      var textureType = 3553;
      if (texture.isDataTexture2DArray)
        textureType = 35866;
      if (texture.isDataTexture3D)
        textureType = 32879;
      initTexture(textureProperties, texture);
      state2.activeTexture(33984 + slot);
      state2.bindTexture(textureType, textureProperties.__webglTexture);
      _gl.pixelStorei(37440, texture.flipY);
      _gl.pixelStorei(37441, texture.premultiplyAlpha);
      _gl.pixelStorei(3317, texture.unpackAlignment);
      var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
      var image = resizeImage(texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize);
      var supportsMips = isPowerOfTwo(image) || capabilities.isWebGL2, glFormat = utils2.convert(texture.format), glType = utils2.convert(texture.type), glInternalFormat = getInternalFormat(glFormat, glType);
      setTextureParameters(textureType, texture, supportsMips);
      var mipmap, mipmaps = texture.mipmaps;
      if (texture.isDepthTexture) {
        glInternalFormat = 6402;
        if (texture.type === FloatType) {
          if (!capabilities.isWebGL2)
            throw new Error("Float Depth Texture only supported in WebGL2.0");
          glInternalFormat = 36012;
        } else if (capabilities.isWebGL2) {
          glInternalFormat = 33189;
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedShortType;
            glType = utils2.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat) {
          glInternalFormat = 34041;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils2.convert(texture.type);
          }
        }
        state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state2.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state2.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          textureProperties.__maxMipLevel = 0;
        }
      } else if (texture.isCompressedTexture) {
        for (var i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i];
          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
            if (state2.getCompressedTextureFormats().indexOf(glFormat) > -1) {
              state2.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
            } else {
              console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
            }
          } else {
            state2.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
          }
        }
        textureProperties.__maxMipLevel = mipmaps.length - 1;
      } else if (texture.isDataTexture2DArray) {
        state2.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else if (texture.isDataTexture3D) {
        state2.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        textureProperties.__maxMipLevel = 0;
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          for (var i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            state2.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
          }
          texture.generateMipmaps = false;
          textureProperties.__maxMipLevel = mipmaps.length - 1;
        } else {
          state2.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
          textureProperties.__maxMipLevel = 0;
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(3553, texture, image.width, image.height);
      }
      textureProperties.__version = texture.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
      var glFormat = utils2.convert(renderTarget.texture.format);
      var glType = utils2.convert(renderTarget.texture.type);
      var glInternalFormat = getInternalFormat(glFormat, glType);
      state2.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
      _gl.bindFramebuffer(36160, framebuffer);
      _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
      _gl.bindFramebuffer(36160, null);
    }
    function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
      _gl.bindRenderbuffer(36161, renderbuffer);
      if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
      } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, 34041, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
        }
        _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
      } else {
        var glFormat = utils2.convert(renderTarget.texture.format);
        var glType = utils2.convert(renderTarget.texture.type);
        var glInternalFormat = getInternalFormat(glFormat, glType);
        if (isMultisample) {
          var samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
      _gl.bindRenderbuffer(36161, null);
    }
    function setupDepthTexture(framebuffer, renderTarget) {
      var isCube = renderTarget && renderTarget.isWebGLRenderTargetCube;
      if (isCube)
        throw new Error("Depth Texture with cube render targets is not supported");
      _gl.bindFramebuffer(36160, framebuffer);
      if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
        throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      }
      if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
        renderTarget.depthTexture.image.width = renderTarget.width;
        renderTarget.depthTexture.image.height = renderTarget.height;
        renderTarget.depthTexture.needsUpdate = true;
      }
      setTexture2D(renderTarget.depthTexture, 0);
      var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
      if (renderTarget.depthTexture.format === DepthFormat) {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
      } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
      } else {
        throw new Error("Unknown depthTexture format");
      }
    }
    function setupDepthRenderbuffer(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var isCube = renderTarget.isWebGLRenderTargetCube === true;
      if (renderTarget.depthTexture) {
        if (isCube)
          throw new Error("target.depthTexture not supported in Cube render targets");
        setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
      } else {
        if (isCube) {
          renderTargetProperties.__webglDepthbuffer = [];
          for (var i = 0; i < 6; i++) {
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
            renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
          }
        } else {
          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
        }
      }
      _gl.bindFramebuffer(36160, null);
    }
    function setupRenderTarget(renderTarget) {
      var renderTargetProperties = properties.get(renderTarget);
      var textureProperties = properties.get(renderTarget.texture);
      renderTarget.addEventListener("dispose", onRenderTargetDispose);
      textureProperties.__webglTexture = _gl.createTexture();
      info.memory.textures++;
      var isCube = renderTarget.isWebGLRenderTargetCube === true;
      var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
      var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;
      if (isCube) {
        renderTargetProperties.__webglFramebuffer = [];
        for (var i = 0; i < 6; i++) {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
        if (isMultisample) {
          if (capabilities.isWebGL2) {
            renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
            renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
            _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
            var glFormat = utils2.convert(renderTarget.texture.format);
            var glType = utils2.convert(renderTarget.texture.type);
            var glInternalFormat = getInternalFormat(glFormat, glType);
            var samples = getRenderTargetSamples(renderTarget);
            _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
            _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
            _gl.bindRenderbuffer(36161, null);
            if (renderTarget.depthBuffer) {
              renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
              setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
            }
            _gl.bindFramebuffer(36160, null);
          } else {
            console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
          }
        }
      }
      if (isCube) {
        state2.bindTexture(34067, textureProperties.__webglTexture);
        setTextureParameters(34067, renderTarget.texture, supportsMips);
        for (var i = 0; i < 6; i++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
        }
        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
        }
        state2.bindTexture(34067, null);
      } else {
        state2.bindTexture(3553, textureProperties.__webglTexture);
        setTextureParameters(3553, renderTarget.texture, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
        if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
          generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
        }
        state2.bindTexture(3553, null);
      }
      if (renderTarget.depthBuffer) {
        setupDepthRenderbuffer(renderTarget);
      }
    }
    function updateRenderTargetMipmap(renderTarget) {
      var texture = renderTarget.texture;
      var supportsMips = isPowerOfTwo(renderTarget) || capabilities.isWebGL2;
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
        var webglTexture = properties.get(texture).__webglTexture;
        state2.bindTexture(target, webglTexture);
        generateMipmap(target, texture, renderTarget.width, renderTarget.height);
        state2.bindTexture(target, null);
      }
    }
    function updateMultisampleRenderTarget(renderTarget) {
      if (renderTarget.isWebGLMultisampleRenderTarget) {
        if (capabilities.isWebGL2) {
          var renderTargetProperties = properties.get(renderTarget);
          _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
          var width2 = renderTarget.width;
          var height2 = renderTarget.height;
          var mask = 16384;
          if (renderTarget.depthBuffer)
            mask |= 256;
          if (renderTarget.stencilBuffer)
            mask |= 1024;
          _gl.blitFramebuffer(0, 0, width2, height2, 0, 0, width2, height2, mask, 9728);
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
        }
      }
    }
    function getRenderTargetSamples(renderTarget) {
      return capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(capabilities.maxSamples, renderTarget.samples) : 0;
    }
    function updateVideoTexture(texture) {
      var id = texture.id;
      var frame = info.render.frame;
      if (_videoTextures[id] !== frame) {
        _videoTextures[id] = frame;
        texture.update();
      }
    }
    var warnedTexture2D = false;
    var warnedTextureCube = false;
    function safeSetTexture2D(texture, slot) {
      if (texture && texture.isWebGLRenderTarget) {
        if (warnedTexture2D === false) {
          console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
          warnedTexture2D = true;
        }
        texture = texture.texture;
      }
      setTexture2D(texture, slot);
    }
    function safeSetTextureCube(texture, slot) {
      if (texture && texture.isWebGLRenderTargetCube) {
        if (warnedTextureCube === false) {
          console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
          warnedTextureCube = true;
        }
        texture = texture.texture;
      }
      if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
        setTextureCube(texture, slot);
      } else {
        setTextureCubeDynamic(texture, slot);
      }
    }
    this.allocateTextureUnit = allocateTextureUnit;
    this.resetTextureUnits = resetTextureUnits;
    this.setTexture2D = setTexture2D;
    this.setTexture2DArray = setTexture2DArray;
    this.setTexture3D = setTexture3D;
    this.setTextureCube = setTextureCube;
    this.setTextureCubeDynamic = setTextureCubeDynamic;
    this.setupRenderTarget = setupRenderTarget;
    this.updateRenderTargetMipmap = updateRenderTargetMipmap;
    this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
    this.safeSetTexture2D = safeSetTexture2D;
    this.safeSetTextureCube = safeSetTextureCube;
  }
  function WebGLUtils(gl, extensions, capabilities) {
    function convert(p2) {
      var extension;
      if (p2 === RepeatWrapping)
        return 10497;
      if (p2 === ClampToEdgeWrapping)
        return 33071;
      if (p2 === MirroredRepeatWrapping)
        return 33648;
      if (p2 === NearestFilter)
        return 9728;
      if (p2 === NearestMipMapNearestFilter)
        return 9984;
      if (p2 === NearestMipMapLinearFilter)
        return 9986;
      if (p2 === LinearFilter)
        return 9729;
      if (p2 === LinearMipMapNearestFilter)
        return 9985;
      if (p2 === LinearMipMapLinearFilter)
        return 9987;
      if (p2 === UnsignedByteType)
        return 5121;
      if (p2 === UnsignedShort4444Type)
        return 32819;
      if (p2 === UnsignedShort5551Type)
        return 32820;
      if (p2 === UnsignedShort565Type)
        return 33635;
      if (p2 === ByteType)
        return 5120;
      if (p2 === ShortType)
        return 5122;
      if (p2 === UnsignedShortType)
        return 5123;
      if (p2 === IntType)
        return 5124;
      if (p2 === UnsignedIntType)
        return 5125;
      if (p2 === FloatType)
        return 5126;
      if (p2 === HalfFloatType) {
        if (capabilities.isWebGL2)
          return 5131;
        extension = extensions.get("OES_texture_half_float");
        if (extension !== null)
          return extension.HALF_FLOAT_OES;
      }
      if (p2 === AlphaFormat)
        return 6406;
      if (p2 === RGBFormat)
        return 6407;
      if (p2 === RGBAFormat)
        return 6408;
      if (p2 === LuminanceFormat)
        return 6409;
      if (p2 === LuminanceAlphaFormat)
        return 6410;
      if (p2 === DepthFormat)
        return 6402;
      if (p2 === DepthStencilFormat)
        return 34041;
      if (p2 === RedFormat)
        return 6403;
      if (p2 === AddEquation)
        return 32774;
      if (p2 === SubtractEquation)
        return 32778;
      if (p2 === ReverseSubtractEquation)
        return 32779;
      if (p2 === ZeroFactor)
        return 0;
      if (p2 === OneFactor)
        return 1;
      if (p2 === SrcColorFactor)
        return 768;
      if (p2 === OneMinusSrcColorFactor)
        return 769;
      if (p2 === SrcAlphaFactor)
        return 770;
      if (p2 === OneMinusSrcAlphaFactor)
        return 771;
      if (p2 === DstAlphaFactor)
        return 772;
      if (p2 === OneMinusDstAlphaFactor)
        return 773;
      if (p2 === DstColorFactor)
        return 774;
      if (p2 === OneMinusDstColorFactor)
        return 775;
      if (p2 === SrcAlphaSaturateFactor)
        return 776;
      if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      }
      if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_pvrtc");
        if (extension !== null) {
          if (p2 === RGB_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (p2 === RGB_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (p2 === RGBA_PVRTC_4BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (p2 === RGBA_PVRTC_2BPPV1_Format)
            return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
      }
      if (p2 === RGB_ETC1_Format) {
        extension = extensions.get("WEBGL_compressed_texture_etc1");
        if (extension !== null)
          return extension.COMPRESSED_RGB_ETC1_WEBGL;
      }
      if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
        extension = extensions.get("WEBGL_compressed_texture_astc");
        if (extension !== null) {
          return p2;
        }
      }
      if (p2 === MinEquation || p2 === MaxEquation) {
        if (capabilities.isWebGL2) {
          if (p2 === MinEquation)
            return 32775;
          if (p2 === MaxEquation)
            return 32776;
        }
        extension = extensions.get("EXT_blend_minmax");
        if (extension !== null) {
          if (p2 === MinEquation)
            return extension.MIN_EXT;
          if (p2 === MaxEquation)
            return extension.MAX_EXT;
        }
      }
      if (p2 === UnsignedInt248Type) {
        if (capabilities.isWebGL2)
          return 34042;
        extension = extensions.get("WEBGL_depth_texture");
        if (extension !== null)
          return extension.UNSIGNED_INT_24_8_WEBGL;
      }
      return 0;
    }
    return { convert };
  }
  function Group() {
    Object3D.call(this);
    this.type = "Group";
  }
  Group.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Group,
    isGroup: true
  });
  function Camera2() {
    Object3D.call(this);
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
  }
  Camera2.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Camera2,
    isCamera: true,
    copy: function(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      this.matrixWorldInverse.copy(source.matrixWorldInverse);
      this.projectionMatrix.copy(source.projectionMatrix);
      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
      return this;
    },
    getWorldDirection: function(target) {
      if (target === void 0) {
        console.warn("THREE.Camera: .getWorldDirection() target is now required");
        target = new Vector3();
      }
      this.updateMatrixWorld(true);
      var e = this.matrixWorld.elements;
      return target.set(-e[8], -e[9], -e[10]).normalize();
    },
    updateMatrixWorld: function(force) {
      Object3D.prototype.updateMatrixWorld.call(this, force);
      this.matrixWorldInverse.getInverse(this.matrixWorld);
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  function PerspectiveCamera(fov, aspect, near, far) {
    Camera2.call(this);
    this.type = "PerspectiveCamera";
    this.fov = fov !== void 0 ? fov : 50;
    this.zoom = 1;
    this.near = near !== void 0 ? near : 0.1;
    this.far = far !== void 0 ? far : 2e3;
    this.focus = 10;
    this.aspect = aspect !== void 0 ? aspect : 1;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  PerspectiveCamera.prototype = Object.assign(Object.create(Camera2.prototype), {
    constructor: PerspectiveCamera,
    isPerspectiveCamera: true,
    copy: function(source, recursive) {
      Camera2.prototype.copy.call(this, source, recursive);
      this.fov = source.fov;
      this.zoom = source.zoom;
      this.near = source.near;
      this.far = source.far;
      this.focus = source.focus;
      this.aspect = source.aspect;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      this.filmGauge = source.filmGauge;
      this.filmOffset = source.filmOffset;
      return this;
    },
    setFocalLength: function(focalLength) {
      var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
      this.fov = _Math.RAD2DEG * 2 * Math.atan(vExtentSlope);
      this.updateProjectionMatrix();
    },
    getFocalLength: function() {
      var vExtentSlope = Math.tan(_Math.DEG2RAD * 0.5 * this.fov);
      return 0.5 * this.getFilmHeight() / vExtentSlope;
    },
    getEffectiveFOV: function() {
      return _Math.RAD2DEG * 2 * Math.atan(Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom);
    },
    getFilmWidth: function() {
      return this.filmGauge * Math.min(this.aspect, 1);
    },
    getFilmHeight: function() {
      return this.filmGauge / Math.max(this.aspect, 1);
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width2, height2) {
      this.aspect = fullWidth / fullHeight;
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width2;
      this.view.height = height2;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var near = this.near, top = near * Math.tan(_Math.DEG2RAD * 0.5 * this.fov) / this.zoom, height2 = 2 * top, width2 = this.aspect * height2, left = -0.5 * width2, view = this.view;
      if (this.view !== null && this.view.enabled) {
        var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
        left += view.offsetX * width2 / fullWidth;
        top -= view.offsetY * height2 / fullHeight;
        width2 *= view.width / fullWidth;
        height2 *= view.height / fullHeight;
      }
      var skew = this.filmOffset;
      if (skew !== 0)
        left += near * skew / this.getFilmWidth();
      this.projectionMatrix.makePerspective(left, left + width2, top, top - height2, near, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.fov = this.fov;
      data.object.zoom = this.zoom;
      data.object.near = this.near;
      data.object.far = this.far;
      data.object.focus = this.focus;
      data.object.aspect = this.aspect;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      data.object.filmGauge = this.filmGauge;
      data.object.filmOffset = this.filmOffset;
      return data;
    }
  });
  function ArrayCamera(array) {
    PerspectiveCamera.call(this);
    this.cameras = array || [];
  }
  ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
    constructor: ArrayCamera,
    isArrayCamera: true
  });
  var cameraLPos = new Vector3();
  var cameraRPos = new Vector3();
  function setProjectionFromUnion(camera2, cameraL, cameraR) {
    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
    var ipd = cameraLPos.distanceTo(cameraRPos);
    var projL = cameraL.projectionMatrix.elements;
    var projR = cameraR.projectionMatrix.elements;
    var near = projL[14] / (projL[10] - 1);
    var far = projL[14] / (projL[10] + 1);
    var topFov = (projL[9] + 1) / projL[5];
    var bottomFov = (projL[9] - 1) / projL[5];
    var leftFov = (projL[8] - 1) / projL[0];
    var rightFov = (projR[8] + 1) / projR[0];
    var left = near * leftFov;
    var right = near * rightFov;
    var zOffset = ipd / (-leftFov + rightFov);
    var xOffset = zOffset * -leftFov;
    cameraL.matrixWorld.decompose(camera2.position, camera2.quaternion, camera2.scale);
    camera2.translateX(xOffset);
    camera2.translateZ(zOffset);
    camera2.matrixWorld.compose(camera2.position, camera2.quaternion, camera2.scale);
    camera2.matrixWorldInverse.getInverse(camera2.matrixWorld);
    var near2 = near + zOffset;
    var far2 = far + zOffset;
    var left2 = left - xOffset;
    var right2 = right + (ipd - xOffset);
    var top2 = topFov * far / far2 * near2;
    var bottom2 = bottomFov * far / far2 * near2;
    camera2.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
  }
  function WebVRManager(renderer) {
    var scope = this;
    var device = null;
    var frameData = null;
    var poseTarget = null;
    var controllers = [];
    var standingMatrix = new Matrix4();
    var standingMatrixInverse = new Matrix4();
    var framebufferScaleFactor = 1;
    var frameOfReferenceType = "stage";
    if (typeof window !== "undefined" && "VRFrameData" in window) {
      frameData = new window.VRFrameData();
      window.addEventListener("vrdisplaypresentchange", onVRDisplayPresentChange, false);
    }
    var matrixWorldInverse = new Matrix4();
    var tempQuaternion = new Quaternion();
    var tempPosition = new Vector3();
    var cameraL = new PerspectiveCamera();
    cameraL.bounds = new Vector4(0, 0, 0.5, 1);
    cameraL.layers.enable(1);
    var cameraR = new PerspectiveCamera();
    cameraR.bounds = new Vector4(0.5, 0, 0.5, 1);
    cameraR.layers.enable(2);
    var cameraVR = new ArrayCamera([cameraL, cameraR]);
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    function isPresenting() {
      return device !== null && device.isPresenting === true;
    }
    var currentSize = new Vector2(), currentPixelRatio;
    function onVRDisplayPresentChange() {
      if (isPresenting()) {
        var eyeParameters = device.getEyeParameters("left");
        var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
        var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        renderer.setDrawingBufferSize(renderWidth * 2, renderHeight, 1);
        animation.start();
      } else {
        if (scope.enabled) {
          renderer.setDrawingBufferSize(currentSize.width, currentSize.height, currentPixelRatio);
        }
        animation.stop();
      }
    }
    var triggers = [];
    function findGamepad(id) {
      var gamepads = navigator.getGamepads && navigator.getGamepads();
      for (var i = 0, j = 0, l = gamepads.length; i < l; i++) {
        var gamepad = gamepads[i];
        if (gamepad && (gamepad.id === "Daydream Controller" || gamepad.id === "Gear VR Controller" || gamepad.id === "Oculus Go Controller" || gamepad.id === "OpenVR Gamepad" || gamepad.id.startsWith("Oculus Touch") || gamepad.id.startsWith("Spatial Controller"))) {
          if (j === id)
            return gamepad;
          j++;
        }
      }
    }
    function updateControllers() {
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        var gamepad = findGamepad(i);
        if (gamepad !== void 0 && gamepad.pose !== void 0) {
          if (gamepad.pose === null)
            return;
          var pose = gamepad.pose;
          if (pose.hasPosition === false)
            controller.position.set(0.2, -0.6, -0.05);
          if (pose.position !== null)
            controller.position.fromArray(pose.position);
          if (pose.orientation !== null)
            controller.quaternion.fromArray(pose.orientation);
          controller.matrix.compose(controller.position, controller.quaternion, controller.scale);
          controller.matrix.premultiply(standingMatrix);
          controller.matrix.decompose(controller.position, controller.quaternion, controller.scale);
          controller.matrixWorldNeedsUpdate = true;
          controller.visible = true;
          var buttonId = gamepad.id === "Daydream Controller" ? 0 : 1;
          if (triggers[i] !== gamepad.buttons[buttonId].pressed) {
            triggers[i] = gamepad.buttons[buttonId].pressed;
            if (triggers[i] === true) {
              controller.dispatchEvent({ type: "selectstart" });
            } else {
              controller.dispatchEvent({ type: "selectend" });
              controller.dispatchEvent({ type: "select" });
            }
          }
        } else {
          controller.visible = false;
        }
      }
    }
    this.enabled = false;
    this.getController = function(id) {
      var controller = controllers[id];
      if (controller === void 0) {
        controller = new Group();
        controller.matrixAutoUpdate = false;
        controller.visible = false;
        controllers[id] = controller;
      }
      return controller;
    };
    this.getDevice = function() {
      return device;
    };
    this.setDevice = function(value) {
      if (value !== void 0)
        device = value;
      animation.setContext(value);
    };
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
    };
    this.setFrameOfReferenceType = function(value) {
      frameOfReferenceType = value;
    };
    this.setPoseTarget = function(object) {
      if (object !== void 0)
        poseTarget = object;
    };
    this.getCamera = function(camera2) {
      var userHeight = frameOfReferenceType === "stage" ? 1.6 : 0;
      if (isPresenting() === false) {
        camera2.position.set(0, userHeight, 0);
        camera2.rotation.set(0, 0, 0);
        return camera2;
      }
      device.depthNear = camera2.near;
      device.depthFar = camera2.far;
      device.getFrameData(frameData);
      if (frameOfReferenceType === "stage") {
        var stageParameters = device.stageParameters;
        if (stageParameters) {
          standingMatrix.fromArray(stageParameters.sittingToStandingTransform);
        } else {
          standingMatrix.makeTranslation(0, userHeight, 0);
        }
      }
      var pose = frameData.pose;
      var poseObject = poseTarget !== null ? poseTarget : camera2;
      poseObject.matrix.copy(standingMatrix);
      poseObject.matrix.decompose(poseObject.position, poseObject.quaternion, poseObject.scale);
      if (pose.orientation !== null) {
        tempQuaternion.fromArray(pose.orientation);
        poseObject.quaternion.multiply(tempQuaternion);
      }
      if (pose.position !== null) {
        tempQuaternion.setFromRotationMatrix(standingMatrix);
        tempPosition.fromArray(pose.position);
        tempPosition.applyQuaternion(tempQuaternion);
        poseObject.position.add(tempPosition);
      }
      poseObject.updateMatrixWorld();
      cameraL.near = camera2.near;
      cameraR.near = camera2.near;
      cameraL.far = camera2.far;
      cameraR.far = camera2.far;
      cameraL.matrixWorldInverse.fromArray(frameData.leftViewMatrix);
      cameraR.matrixWorldInverse.fromArray(frameData.rightViewMatrix);
      standingMatrixInverse.getInverse(standingMatrix);
      if (frameOfReferenceType === "stage") {
        cameraL.matrixWorldInverse.multiply(standingMatrixInverse);
        cameraR.matrixWorldInverse.multiply(standingMatrixInverse);
      }
      var parent = poseObject.parent;
      if (parent !== null) {
        matrixWorldInverse.getInverse(parent.matrixWorld);
        cameraL.matrixWorldInverse.multiply(matrixWorldInverse);
        cameraR.matrixWorldInverse.multiply(matrixWorldInverse);
      }
      cameraL.matrixWorld.getInverse(cameraL.matrixWorldInverse);
      cameraR.matrixWorld.getInverse(cameraR.matrixWorldInverse);
      cameraL.projectionMatrix.fromArray(frameData.leftProjectionMatrix);
      cameraR.projectionMatrix.fromArray(frameData.rightProjectionMatrix);
      setProjectionFromUnion(cameraVR, cameraL, cameraR);
      var layers = device.getLayers();
      if (layers.length) {
        var layer = layers[0];
        if (layer.leftBounds !== null && layer.leftBounds.length === 4) {
          cameraL.bounds.fromArray(layer.leftBounds);
        }
        if (layer.rightBounds !== null && layer.rightBounds.length === 4) {
          cameraR.bounds.fromArray(layer.rightBounds);
        }
      }
      updateControllers();
      return cameraVR;
    };
    this.getStandingMatrix = function() {
      return standingMatrix;
    };
    this.isPresenting = isPresenting;
    var animation = new WebGLAnimation();
    this.setAnimationLoop = function(callback) {
      animation.setAnimationLoop(callback);
      if (isPresenting())
        animation.start();
    };
    this.submitFrame = function() {
      if (isPresenting())
        device.submitFrame();
    };
    this.dispose = function() {
      if (typeof window !== "undefined") {
        window.removeEventListener("vrdisplaypresentchange", onVRDisplayPresentChange);
      }
    };
  }
  function WebXRManager(renderer) {
    var gl = renderer.context;
    var device = null;
    var session = null;
    var framebufferScaleFactor = 1;
    var frameOfReference = null;
    var frameOfReferenceType = "stage";
    var pose = null;
    var controllers = [];
    var inputSources = [];
    function isPresenting() {
      return session !== null && frameOfReference !== null;
    }
    var cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector4();
    var cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector4();
    var cameraVR = new ArrayCamera([cameraL, cameraR]);
    cameraVR.layers.enable(1);
    cameraVR.layers.enable(2);
    this.enabled = false;
    this.getController = function(id) {
      var controller = controllers[id];
      if (controller === void 0) {
        controller = new Group();
        controller.matrixAutoUpdate = false;
        controller.visible = false;
        controllers[id] = controller;
      }
      return controller;
    };
    this.getDevice = function() {
      return device;
    };
    this.setDevice = function(value) {
      if (value !== void 0)
        device = value;
      if (value instanceof XRDevice)
        gl.setCompatibleXRDevice(value);
    };
    function onSessionEvent(event) {
      var controller = controllers[inputSources.indexOf(event.inputSource)];
      if (controller)
        controller.dispatchEvent({ type: event.type });
    }
    function onSessionEnd() {
      renderer.setFramebuffer(null);
      renderer.setRenderTarget(renderer.getRenderTarget());
      animation.stop();
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
    };
    this.setFrameOfReferenceType = function(value) {
      frameOfReferenceType = value;
    };
    this.setSession = function(value) {
      session = value;
      if (session !== null) {
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.baseLayer = new XRWebGLLayer(session, gl, { framebufferScaleFactor });
        session.requestFrameOfReference(frameOfReferenceType).then(function(value2) {
          frameOfReference = value2;
          renderer.setFramebuffer(session.baseLayer.framebuffer);
          animation.setContext(session);
          animation.start();
        });
        inputSources = session.getInputSources();
        session.addEventListener("inputsourceschange", function() {
          inputSources = session.getInputSources();
          console.log(inputSources);
          for (var i = 0; i < controllers.length; i++) {
            var controller = controllers[i];
            controller.userData.inputSource = inputSources[i];
          }
        });
      }
    };
    function updateCamera(camera2, parent) {
      if (parent === null) {
        camera2.matrixWorld.copy(camera2.matrix);
      } else {
        camera2.matrixWorld.multiplyMatrices(parent.matrixWorld, camera2.matrix);
      }
      camera2.matrixWorldInverse.getInverse(camera2.matrixWorld);
    }
    this.getCamera = function(camera2) {
      if (isPresenting()) {
        var parent = camera2.parent;
        var cameras = cameraVR.cameras;
        updateCamera(cameraVR, parent);
        for (var i = 0; i < cameras.length; i++) {
          updateCamera(cameras[i], parent);
        }
        camera2.matrixWorld.copy(cameraVR.matrixWorld);
        var children2 = camera2.children;
        for (var i = 0, l = children2.length; i < l; i++) {
          children2[i].updateMatrixWorld(true);
        }
        setProjectionFromUnion(cameraVR, cameraL, cameraR);
        return cameraVR;
      }
      return camera2;
    };
    this.isPresenting = isPresenting;
    var onAnimationFrameCallback = null;
    function onAnimationFrame(time2, frame) {
      pose = frame.getDevicePose(frameOfReference);
      if (pose !== null) {
        var layer = session.baseLayer;
        var views = frame.views;
        for (var i = 0; i < views.length; i++) {
          var view = views[i];
          var viewport = layer.getViewport(view);
          var viewMatrix = pose.getViewMatrix(view);
          var camera2 = cameraVR.cameras[i];
          camera2.matrix.fromArray(viewMatrix).getInverse(camera2.matrix);
          camera2.projectionMatrix.fromArray(view.projectionMatrix);
          camera2.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraVR.matrix.copy(camera2.matrix);
          }
        }
      }
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        var inputSource = inputSources[i];
        if (inputSource) {
          var inputPose = frame.getInputPose(inputSource, frameOfReference);
          if (inputPose !== null) {
            if ("targetRay" in inputPose) {
              controller.matrix.elements = inputPose.targetRay.transformMatrix;
            } else if ("pointerMatrix" in inputPose) {
              controller.matrix.elements = inputPose.pointerMatrix;
            }
            controller.matrix.decompose(controller.position, controller.rotation, controller.scale);
            controller.visible = true;
            continue;
          }
        }
        controller.visible = false;
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time2);
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
    this.getStandingMatrix = function() {
      console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
      return new Matrix4();
    };
    this.submitFrame = function() {
    };
  }
  function WebGLRenderer(parameters) {
    console.log("THREE.WebGLRenderer", REVISION);
    parameters = parameters || {};
    var _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : "default";
    var currentRenderList = null;
    var currentRenderState = null;
    this.domElement = _canvas2;
    this.context = null;
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.gammaFactor = 2;
    this.gammaInput = false;
    this.gammaOutput = false;
    this.physicallyCorrectLights = false;
    this.toneMapping = LinearToneMapping;
    this.toneMappingExposure = 1;
    this.toneMappingWhitePoint = 1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    var _this = this, _isContextLost = false, _framebuffer = null, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = {
      geometry: null,
      program: null,
      wireframe: false
    }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _width = _canvas2.width, _height = _canvas2.height, _pixelRatio = 1, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    var _gl;
    try {
      var contextAttributes = {
        alpha: _alpha,
        depth: _depth,
        stencil: _stencil,
        antialias: _antialias,
        premultipliedAlpha: _premultipliedAlpha,
        preserveDrawingBuffer: _preserveDrawingBuffer,
        powerPreference: _powerPreference
      };
      _canvas2.addEventListener("webglcontextlost", onContextLost, false);
      _canvas2.addEventListener("webglcontextrestored", onContextRestore, false);
      _gl = _context || _canvas2.getContext("webgl", contextAttributes) || _canvas2.getContext("experimental-webgl", contextAttributes);
      if (_gl === null) {
        if (_canvas2.getContext("webgl") !== null) {
          throw new Error("Error creating WebGL context with your selected attributes.");
        } else {
          throw new Error("Error creating WebGL context.");
        }
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    var extensions, capabilities, state2, info;
    var properties, textures, attributes, geometries, objects;
    var programCache, renderLists, renderStates;
    var background, morphtargets, bufferRenderer, indexedBufferRenderer;
    var utils2;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      if (!capabilities.isWebGL2) {
        extensions.get("WEBGL_depth_texture");
        extensions.get("OES_texture_float");
        extensions.get("OES_texture_half_float");
        extensions.get("OES_texture_half_float_linear");
        extensions.get("OES_standard_derivatives");
        extensions.get("OES_element_index_uint");
        extensions.get("ANGLE_instanced_arrays");
      }
      extensions.get("OES_texture_float_linear");
      utils2 = new WebGLUtils(_gl, extensions, capabilities);
      state2 = new WebGLState(_gl, extensions, utils2, capabilities);
      state2.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
      state2.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state2, properties, capabilities, utils2, info);
      attributes = new WebGLAttributes(_gl);
      geometries = new WebGLGeometries(_gl, attributes, info);
      objects = new WebGLObjects(geometries, info);
      morphtargets = new WebGLMorphtargets(_gl);
      programCache = new WebGLPrograms(_this, extensions, capabilities, textures);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates();
      background = new WebGLBackground(_this, state2, objects, _premultipliedAlpha);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.context = _gl;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.state = state2;
      _this.info = info;
    }
    initGLContext();
    var vr = null;
    if (typeof navigator !== "undefined") {
      vr = "xr" in navigator ? new WebXRManager(_this) : new WebVRManager(_this);
    }
    this.vr = vr;
    var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
    this.shadowMap = shadowMap;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      var extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      var extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width, _height);
    };
    this.setSize = function(width2, height2, updateStyle) {
      if (vr.isPresenting()) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width2;
      _height = height2;
      _canvas2.width = width2 * _pixelRatio;
      _canvas2.height = height2 * _pixelRatio;
      if (updateStyle !== false) {
        _canvas2.style.width = width2 + "px";
        _canvas2.style.height = height2 + "px";
      }
      this.setViewport(0, 0, width2, height2);
    };
    this.getDrawingBufferSize = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
        target = new Vector2();
      }
      return target.set(_width * _pixelRatio, _height * _pixelRatio);
    };
    this.setDrawingBufferSize = function(width2, height2, pixelRatio) {
      _width = width2;
      _height = height2;
      _pixelRatio = pixelRatio;
      _canvas2.width = width2 * pixelRatio;
      _canvas2.height = height2 * pixelRatio;
      this.setViewport(0, 0, width2, height2);
    };
    this.getCurrentViewport = function(target) {
      if (target === void 0) {
        console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
        target = new Vector4();
      }
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x, y, width2, height2) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width2, height2);
      }
      state2.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio));
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x, y, width2, height2) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width2, height2);
      }
      state2.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio));
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state2.setScissorTest(_scissorTest = boolean);
    };
    this.getClearColor = function() {
      return background.getClearColor();
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color, depth, stencil) {
      var bits = 0;
      if (color === void 0 || color)
        bits |= 16384;
      if (depth === void 0 || depth)
        bits |= 256;
      if (stencil === void 0 || stencil)
        bits |= 1024;
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      _canvas2.removeEventListener("webglcontextlost", onContextLost, false);
      _canvas2.removeEventListener("webglcontextrestored", onContextRestore, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      objects.dispose();
      vr.dispose();
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      initGLContext();
    }
    function onMaterialDispose(event) {
      var material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReference(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReference(material) {
      var programInfo = properties.get(material).program;
      material.program = void 0;
      if (programInfo !== void 0) {
        programCache.releaseProgram(programInfo);
      }
    }
    function renderObjectImmediate(object, program) {
      object.render(function(object2) {
        _this.renderBufferImmediate(object2, program);
      });
    }
    this.renderBufferImmediate = function(object, program) {
      state2.initAttributes();
      var buffers = properties.get(object);
      if (object.hasPositions && !buffers.position)
        buffers.position = _gl.createBuffer();
      if (object.hasNormals && !buffers.normal)
        buffers.normal = _gl.createBuffer();
      if (object.hasUvs && !buffers.uv)
        buffers.uv = _gl.createBuffer();
      if (object.hasColors && !buffers.color)
        buffers.color = _gl.createBuffer();
      var programAttributes = program.getAttributes();
      if (object.hasPositions) {
        _gl.bindBuffer(34962, buffers.position);
        _gl.bufferData(34962, object.positionArray, 35048);
        state2.enableAttribute(programAttributes.position);
        _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
      }
      if (object.hasNormals) {
        _gl.bindBuffer(34962, buffers.normal);
        _gl.bufferData(34962, object.normalArray, 35048);
        state2.enableAttribute(programAttributes.normal);
        _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
      }
      if (object.hasUvs) {
        _gl.bindBuffer(34962, buffers.uv);
        _gl.bufferData(34962, object.uvArray, 35048);
        state2.enableAttribute(programAttributes.uv);
        _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
      }
      if (object.hasColors) {
        _gl.bindBuffer(34962, buffers.color);
        _gl.bufferData(34962, object.colorArray, 35048);
        state2.enableAttribute(programAttributes.color);
        _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
      }
      state2.disableUnusedAttributes();
      _gl.drawArrays(4, 0, object.count);
      object.count = 0;
    };
    this.renderBufferDirect = function(camera2, fog, geometry2, material, object, group) {
      var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      state2.setMaterial(material, frontFaceCW);
      var program = setProgram(camera2, fog, material, object);
      var updateBuffers = false;
      if (_currentGeometryProgram.geometry !== geometry2.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
        _currentGeometryProgram.geometry = geometry2.id;
        _currentGeometryProgram.program = program.id;
        _currentGeometryProgram.wireframe = material.wireframe === true;
        updateBuffers = true;
      }
      if (object.morphTargetInfluences) {
        morphtargets.update(object, geometry2, material, program);
        updateBuffers = true;
      }
      var index = geometry2.index;
      var position = geometry2.attributes.position;
      var rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry2);
        rangeFactor = 2;
      }
      var attribute;
      var renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (updateBuffers) {
        setupVertexAttributes(material, program, geometry2);
        if (index !== null) {
          _gl.bindBuffer(34963, attribute.buffer);
        }
      }
      var dataCount = Infinity;
      if (index !== null) {
        dataCount = index.count;
      } else if (position !== void 0) {
        dataCount = position.count;
      }
      var rangeStart = geometry2.drawRange.start * rangeFactor;
      var rangeCount = geometry2.drawRange.count * rangeFactor;
      var groupStart = group !== null ? group.start * rangeFactor : 0;
      var groupCount = group !== null ? group.count * rangeFactor : Infinity;
      var drawStart = Math.max(rangeStart, groupStart);
      var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
      var drawCount = Math.max(0, drawEnd - drawStart + 1);
      if (drawCount === 0)
        return;
      if (object.isMesh) {
        if (material.wireframe === true) {
          state2.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(1);
        } else {
          switch (object.drawMode) {
            case TrianglesDrawMode:
              renderer.setMode(4);
              break;
            case TriangleStripDrawMode:
              renderer.setMode(5);
              break;
            case TriangleFanDrawMode:
              renderer.setMode(6);
              break;
          }
        }
      } else if (object.isLine) {
        var lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state2.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(1);
        } else if (object.isLineLoop) {
          renderer.setMode(2);
        } else {
          renderer.setMode(3);
        }
      } else if (object.isPoints) {
        renderer.setMode(0);
      } else if (object.isSprite) {
        renderer.setMode(4);
      }
      if (geometry2 && geometry2.isInstancedBufferGeometry) {
        if (geometry2.maxInstancedCount > 0) {
          renderer.renderInstances(geometry2, drawStart, drawCount);
        }
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function setupVertexAttributes(material, program, geometry2) {
      if (geometry2 && geometry2.isInstancedBufferGeometry && !capabilities.isWebGL2) {
        if (extensions.get("ANGLE_instanced_arrays") === null) {
          console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
          return;
        }
      }
      state2.initAttributes();
      var geometryAttributes = geometry2.attributes;
      var programAttributes = program.getAttributes();
      var materialDefaultAttributeValues = material.defaultAttributeValues;
      for (var name in programAttributes) {
        var programAttribute = programAttributes[name];
        if (programAttribute >= 0) {
          var geometryAttribute = geometryAttributes[name];
          if (geometryAttribute !== void 0) {
            var normalized = geometryAttribute.normalized;
            var size2 = geometryAttribute.itemSize;
            var attribute = attributes.get(geometryAttribute);
            if (attribute === void 0)
              continue;
            var buffer = attribute.buffer;
            var type = attribute.type;
            var bytesPerElement = attribute.bytesPerElement;
            if (geometryAttribute.isInterleavedBufferAttribute) {
              var data = geometryAttribute.data;
              var stride = data.stride;
              var offset = geometryAttribute.offset;
              if (data && data.isInstancedInterleavedBuffer) {
                state2.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
                if (geometry2.maxInstancedCount === void 0) {
                  geometry2.maxInstancedCount = data.meshPerAttribute * data.count;
                }
              } else {
                state2.enableAttribute(programAttribute);
              }
              _gl.bindBuffer(34962, buffer);
              _gl.vertexAttribPointer(programAttribute, size2, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
            } else {
              if (geometryAttribute.isInstancedBufferAttribute) {
                state2.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
                if (geometry2.maxInstancedCount === void 0) {
                  geometry2.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
                }
              } else {
                state2.enableAttribute(programAttribute);
              }
              _gl.bindBuffer(34962, buffer);
              _gl.vertexAttribPointer(programAttribute, size2, type, normalized, 0, 0);
            }
          } else if (materialDefaultAttributeValues !== void 0) {
            var value = materialDefaultAttributeValues[name];
            if (value !== void 0) {
              switch (value.length) {
                case 2:
                  _gl.vertexAttrib2fv(programAttribute, value);
                  break;
                case 3:
                  _gl.vertexAttrib3fv(programAttribute, value);
                  break;
                case 4:
                  _gl.vertexAttrib4fv(programAttribute, value);
                  break;
                default:
                  _gl.vertexAttrib1fv(programAttribute, value);
              }
            }
          }
        }
      }
      state2.disableUnusedAttributes();
    }
    this.compile = function(scene2, camera2) {
      currentRenderState = renderStates.get(scene2, camera2);
      currentRenderState.init();
      scene2.traverse(function(object) {
        if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      currentRenderState.setupLights(camera2);
      scene2.traverse(function(object) {
        if (object.material) {
          if (Array.isArray(object.material)) {
            for (var i = 0; i < object.material.length; i++) {
              initMaterial(object.material[i], scene2.fog, object);
            }
          } else {
            initMaterial(object.material, scene2.fog, object);
          }
        }
      });
    };
    var onAnimationFrameCallback = null;
    function onAnimationFrame(time2) {
      if (vr.isPresenting())
        return;
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time2);
    }
    var animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof window !== "undefined")
      animation.setContext(window);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      vr.setAnimationLoop(callback);
      animation.start();
    };
    this.render = function(scene2, camera2) {
      var renderTarget, forceClear;
      if (arguments[2] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
        renderTarget = arguments[2];
      }
      if (arguments[3] !== void 0) {
        console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
        forceClear = arguments[3];
      }
      if (!(camera2 && camera2.isCamera)) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost)
        return;
      _currentGeometryProgram.geometry = null;
      _currentGeometryProgram.program = null;
      _currentGeometryProgram.wireframe = false;
      _currentMaterialId = -1;
      _currentCamera = null;
      if (scene2.autoUpdate === true)
        scene2.updateMatrixWorld();
      if (camera2.parent === null)
        camera2.updateMatrixWorld();
      if (vr.enabled) {
        camera2 = vr.getCamera(camera2);
      }
      currentRenderState = renderStates.get(scene2, camera2);
      currentRenderState.init();
      scene2.onBeforeRender(_this, scene2, camera2, renderTarget || _currentRenderTarget);
      _projScreenMatrix.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
      _frustum.setFromMatrix(_projScreenMatrix);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera2);
      currentRenderList = renderLists.get(scene2, camera2);
      currentRenderList.init();
      projectObject(scene2, camera2, 0, _this.sortObjects);
      if (_this.sortObjects === true) {
        currentRenderList.sort();
      }
      if (_clippingEnabled)
        _clipping.beginShadows();
      var shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene2, camera2);
      currentRenderState.setupLights(camera2);
      if (_clippingEnabled)
        _clipping.endShadows();
      if (this.info.autoReset)
        this.info.reset();
      if (renderTarget !== void 0) {
        this.setRenderTarget(renderTarget);
      }
      background.render(currentRenderList, scene2, camera2, forceClear);
      var opaqueObjects = currentRenderList.opaque;
      var transparentObjects = currentRenderList.transparent;
      if (scene2.overrideMaterial) {
        var overrideMaterial = scene2.overrideMaterial;
        if (opaqueObjects.length)
          renderObjects(opaqueObjects, scene2, camera2, overrideMaterial);
        if (transparentObjects.length)
          renderObjects(transparentObjects, scene2, camera2, overrideMaterial);
      } else {
        if (opaqueObjects.length)
          renderObjects(opaqueObjects, scene2, camera2);
        if (transparentObjects.length)
          renderObjects(transparentObjects, scene2, camera2);
      }
      scene2.onAfterRender(_this, scene2, camera2);
      if (_currentRenderTarget !== null) {
        textures.updateRenderTargetMipmap(_currentRenderTarget);
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
      }
      state2.buffers.depth.setTest(true);
      state2.buffers.depth.setMask(true);
      state2.buffers.color.setMask(true);
      state2.setPolygonOffset(false);
      if (vr.enabled) {
        vr.submitFrame();
      }
      currentRenderList = null;
      currentRenderState = null;
    };
    function projectObject(object, camera2, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      var visible = object.layers.test(camera2.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            var geometry2 = objects.update(object);
            var material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
            }
          }
        } else if (object.isImmediateRenderObject) {
          if (sortObjects) {
            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
          }
          currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (object.isSkinnedMesh) {
            object.skeleton.update();
          }
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            if (sortObjects) {
              _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
            }
            var geometry2 = objects.update(object);
            var material = object.material;
            if (Array.isArray(material)) {
              var groups = geometry2.groups;
              for (var i = 0, l = groups.length; i < l; i++) {
                var group = groups[i];
                var groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry2, groupMaterial, groupOrder, _vector3.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry2, material, groupOrder, _vector3.z, null);
            }
          }
        }
      }
      var children2 = object.children;
      for (var i = 0, l = children2.length; i < l; i++) {
        projectObject(children2[i], camera2, groupOrder, sortObjects);
      }
    }
    function renderObjects(renderList, scene2, camera2, overrideMaterial) {
      for (var i = 0, l = renderList.length; i < l; i++) {
        var renderItem = renderList[i];
        var object = renderItem.object;
        var geometry2 = renderItem.geometry;
        var material = overrideMaterial === void 0 ? renderItem.material : overrideMaterial;
        var group = renderItem.group;
        if (camera2.isArrayCamera) {
          _currentArrayCamera = camera2;
          var cameras = camera2.cameras;
          for (var j = 0, jl = cameras.length; j < jl; j++) {
            var camera22 = cameras[j];
            if (object.layers.test(camera22.layers)) {
              if ("viewport" in camera22) {
                state2.viewport(_currentViewport.copy(camera22.viewport));
              } else {
                var bounds = camera22.bounds;
                var x = bounds.x * _width;
                var y = bounds.y * _height;
                var width2 = bounds.z * _width;
                var height2 = bounds.w * _height;
                state2.viewport(_currentViewport.set(x, y, width2, height2).multiplyScalar(_pixelRatio));
              }
              currentRenderState.setupLights(camera22);
              renderObject(object, scene2, camera22, geometry2, material, group);
            }
          }
        } else {
          _currentArrayCamera = null;
          renderObject(object, scene2, camera2, geometry2, material, group);
        }
      }
    }
    function renderObject(object, scene2, camera2, geometry2, material, group) {
      object.onBeforeRender(_this, scene2, camera2, geometry2, material, group);
      currentRenderState = renderStates.get(scene2, _currentArrayCamera || camera2);
      object.modelViewMatrix.multiplyMatrices(camera2.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      if (object.isImmediateRenderObject) {
        state2.setMaterial(material);
        var program = setProgram(camera2, scene2.fog, material, object);
        _currentGeometryProgram.geometry = null;
        _currentGeometryProgram.program = null;
        _currentGeometryProgram.wireframe = false;
        renderObjectImmediate(object, program);
      } else {
        _this.renderBufferDirect(camera2, scene2.fog, geometry2, material, object, group);
      }
      object.onAfterRender(_this, scene2, camera2, geometry2, material, group);
      currentRenderState = renderStates.get(scene2, _currentArrayCamera || camera2);
    }
    function initMaterial(material, fog, object) {
      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;
      var shadowsArray = currentRenderState.state.shadowsArray;
      var lightsHash = materialProperties.lightsHash;
      var lightsStateHash = lights.state.hash;
      var parameters2 = programCache.getParameters(material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object);
      var code = programCache.getProgramCode(material, parameters2);
      var program = materialProperties.program;
      var programChange = true;
      if (program === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
      } else if (program.code !== code) {
        releaseMaterialProgramReference(material);
      } else if (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength) {
        lightsHash.stateID = lightsStateHash.stateID;
        lightsHash.directionalLength = lightsStateHash.directionalLength;
        lightsHash.pointLength = lightsStateHash.pointLength;
        lightsHash.spotLength = lightsStateHash.spotLength;
        lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
        lightsHash.hemiLength = lightsStateHash.hemiLength;
        lightsHash.shadowsLength = lightsStateHash.shadowsLength;
        programChange = false;
      } else if (parameters2.shaderID !== void 0) {
        return;
      } else {
        programChange = false;
      }
      if (programChange) {
        if (parameters2.shaderID) {
          var shader = ShaderLib[parameters2.shaderID];
          materialProperties.shader = {
            name: material.type,
            uniforms: cloneUniforms(shader.uniforms),
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
          };
        } else {
          materialProperties.shader = {
            name: material.type,
            uniforms: material.uniforms,
            vertexShader: material.vertexShader,
            fragmentShader: material.fragmentShader
          };
        }
        material.onBeforeCompile(materialProperties.shader, _this);
        code = programCache.getProgramCode(material, parameters2);
        program = programCache.acquireProgram(material, materialProperties.shader, parameters2, code);
        materialProperties.program = program;
        material.program = program;
      }
      var programAttributes = program.getAttributes();
      if (material.morphTargets) {
        material.numSupportedMorphTargets = 0;
        for (var i = 0; i < _this.maxMorphTargets; i++) {
          if (programAttributes["morphTarget" + i] >= 0) {
            material.numSupportedMorphTargets++;
          }
        }
      }
      if (material.morphNormals) {
        material.numSupportedMorphNormals = 0;
        for (var i = 0; i < _this.maxMorphNormals; i++) {
          if (programAttributes["morphNormal" + i] >= 0) {
            material.numSupportedMorphNormals++;
          }
        }
      }
      var uniforms = materialProperties.shader.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        materialProperties.numClippingPlanes = _clipping.numPlanes;
        materialProperties.numIntersection = _clipping.numIntersection;
        uniforms.clippingPlanes = _clipping.uniform;
      }
      materialProperties.fog = fog;
      if (lightsHash === void 0) {
        materialProperties.lightsHash = lightsHash = {};
      }
      lightsHash.stateID = lightsStateHash.stateID;
      lightsHash.directionalLength = lightsStateHash.directionalLength;
      lightsHash.pointLength = lightsStateHash.pointLength;
      lightsHash.spotLength = lightsStateHash.spotLength;
      lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
      lightsHash.hemiLength = lightsStateHash.hemiLength;
      lightsHash.shadowsLength = lightsStateHash.shadowsLength;
      if (material.lights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.pointLights.value = lights.state.point;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
      materialProperties.uniformsList = uniformsList;
    }
    function setProgram(camera2, fog, material, object) {
      textures.resetTextureUnits();
      var materialProperties = properties.get(material);
      var lights = currentRenderState.state.lights;
      var lightsHash = materialProperties.lightsHash;
      var lightsStateHash = lights.state.hash;
      if (_clippingEnabled) {
        if (_localClippingEnabled || camera2 !== _currentCamera) {
          var useCache = camera2 === _currentCamera && material.id === _currentMaterialId;
          _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera2, materialProperties, useCache);
        }
      }
      if (material.needsUpdate === false) {
        if (materialProperties.program === void 0) {
          material.needsUpdate = true;
        } else if (material.fog && materialProperties.fog !== fog) {
          material.needsUpdate = true;
        } else if (material.lights && (lightsHash.stateID !== lightsStateHash.stateID || lightsHash.directionalLength !== lightsStateHash.directionalLength || lightsHash.pointLength !== lightsStateHash.pointLength || lightsHash.spotLength !== lightsStateHash.spotLength || lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength || lightsHash.hemiLength !== lightsStateHash.hemiLength || lightsHash.shadowsLength !== lightsStateHash.shadowsLength)) {
          material.needsUpdate = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
          material.needsUpdate = true;
        }
      }
      if (material.needsUpdate) {
        initMaterial(material, fog, object);
        material.needsUpdate = false;
      }
      var refreshProgram = false;
      var refreshMaterial = false;
      var refreshLights = false;
      var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.shader.uniforms;
      if (state2.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera2) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera2.projectionMatrix);
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera2.far + 1) / Math.LN2));
        }
        if (_currentCamera !== camera2) {
          _currentCamera = camera2;
          refreshMaterial = true;
          refreshLights = true;
        }
        if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.envMap) {
          var uCamPos = p_uniforms.map.cameraPosition;
          if (uCamPos !== void 0) {
            uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera2.matrixWorld));
          }
        }
        if (material.isMeshPhongMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
          p_uniforms.setValue(_gl, "viewMatrix", camera2.matrixWorldInverse);
        }
      }
      if (material.skinning) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        var skeleton = object.skeleton;
        if (skeleton) {
          var bones2 = skeleton.bones;
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === void 0) {
              var size2 = Math.sqrt(bones2.length * 4);
              size2 = _Math.ceilPowerOfTwo(size2);
              size2 = Math.max(size2, 4);
              var boneMatrices = new Float32Array(size2 * size2 * 4);
              boneMatrices.set(skeleton.boneMatrices);
              var boneTexture = new DataTexture(boneMatrices, size2, size2, RGBAFormat, FloatType);
              boneTexture.needsUpdate = true;
              skeleton.boneMatrices = boneMatrices;
              skeleton.boneTexture = boneTexture;
              skeleton.boneTextureSize = size2;
            }
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
          }
        }
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
        if (material.lights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog) {
          refreshUniformsFog(m_uniforms, fog);
        }
        if (material.isMeshBasicMaterial) {
          refreshUniformsCommon(m_uniforms, material);
        } else if (material.isMeshLambertMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsLambert(m_uniforms, material);
        } else if (material.isMeshPhongMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          if (material.isMeshToonMaterial) {
            refreshUniformsToon(m_uniforms, material);
          } else {
            refreshUniformsPhong(m_uniforms, material);
          }
        } else if (material.isMeshStandardMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          if (material.isMeshPhysicalMaterial) {
            refreshUniformsPhysical(m_uniforms, material);
          } else {
            refreshUniformsStandard(m_uniforms, material);
          }
        } else if (material.isMeshMatcapMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsMatcap(m_uniforms, material);
        } else if (material.isMeshDepthMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsDepth(m_uniforms, material);
        } else if (material.isMeshDistanceMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsDistance(m_uniforms, material);
        } else if (material.isMeshNormalMaterial) {
          refreshUniformsCommon(m_uniforms, material);
          refreshUniformsNormal(m_uniforms, material);
        } else if (material.isLineBasicMaterial) {
          refreshUniformsLine(m_uniforms, material);
          if (material.isLineDashedMaterial) {
            refreshUniformsDash(m_uniforms, material);
          }
        } else if (material.isPointsMaterial) {
          refreshUniformsPoints(m_uniforms, material);
        } else if (material.isSpriteMaterial) {
          refreshUniformsSprites(m_uniforms, material);
        } else if (material.isShadowMaterial) {
          m_uniforms.color.value = material.color;
          m_uniforms.opacity.value = material.opacity;
        }
        if (m_uniforms.ltc_1 !== void 0)
          m_uniforms.ltc_1.value = UniformsLib.LTC_1;
        if (m_uniforms.ltc_2 !== void 0)
          m_uniforms.ltc_2.value = UniformsLib.LTC_2;
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      return program;
    }
    function refreshUniformsCommon(uniforms, material) {
      uniforms.opacity.value = material.opacity;
      if (material.color) {
        uniforms.diffuse.value = material.color;
      }
      if (material.emissive) {
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      }
      if (material.map) {
        uniforms.map.value = material.map;
      }
      if (material.alphaMap) {
        uniforms.alphaMap.value = material.alphaMap;
      }
      if (material.specularMap) {
        uniforms.specularMap.value = material.specularMap;
      }
      if (material.envMap) {
        uniforms.envMap.value = material.envMap;
        uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
        uniforms.maxMipLevel.value = properties.get(material.envMap).__maxMipLevel;
      }
      if (material.lightMap) {
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
      }
      if (material.aoMap) {
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity;
      }
      var uvScaleMap;
      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.roughnessMap) {
        uvScaleMap = material.roughnessMap;
      } else if (material.metalnessMap) {
        uvScaleMap = material.metalnessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      }
      if (uvScaleMap !== void 0) {
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }
        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }
        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }
    }
    function refreshUniformsLine(uniforms, material) {
      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;
    }
    function refreshUniformsDash(uniforms, material) {
      uniforms.dashSize.value = material.dashSize;
      uniforms.totalSize.value = material.dashSize + material.gapSize;
      uniforms.scale.value = material.scale;
    }
    function refreshUniformsPoints(uniforms, material) {
      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;
      uniforms.size.value = material.size * _pixelRatio;
      uniforms.scale.value = _height * 0.5;
      uniforms.map.value = material.map;
      if (material.map !== null) {
        if (material.map.matrixAutoUpdate === true) {
          material.map.updateMatrix();
        }
        uniforms.uvTransform.value.copy(material.map.matrix);
      }
    }
    function refreshUniformsSprites(uniforms, material) {
      uniforms.diffuse.value = material.color;
      uniforms.opacity.value = material.opacity;
      uniforms.rotation.value = material.rotation;
      uniforms.map.value = material.map;
      if (material.map !== null) {
        if (material.map.matrixAutoUpdate === true) {
          material.map.updateMatrix();
        }
        uniforms.uvTransform.value.copy(material.map.matrix);
      }
    }
    function refreshUniformsFog(uniforms, fog) {
      uniforms.fogColor.value = fog.color;
      if (fog.isFog) {
        uniforms.fogNear.value = fog.near;
        uniforms.fogFar.value = fog.far;
      } else if (fog.isFogExp2) {
        uniforms.fogDensity.value = fog.density;
      }
    }
    function refreshUniformsLambert(uniforms, material) {
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
    }
    function refreshUniformsPhong(uniforms, material) {
      uniforms.specular.value = material.specular;
      uniforms.shininess.value = Math.max(material.shininess, 1e-4);
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsToon(uniforms, material) {
      refreshUniformsPhong(uniforms, material);
      if (material.gradientMap) {
        uniforms.gradientMap.value = material.gradientMap;
      }
    }
    function refreshUniformsStandard(uniforms, material) {
      uniforms.roughness.value = material.roughness;
      uniforms.metalness.value = material.metalness;
      if (material.roughnessMap) {
        uniforms.roughnessMap.value = material.roughnessMap;
      }
      if (material.metalnessMap) {
        uniforms.metalnessMap.value = material.metalnessMap;
      }
      if (material.emissiveMap) {
        uniforms.emissiveMap.value = material.emissiveMap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      if (material.envMap) {
        uniforms.envMapIntensity.value = material.envMapIntensity;
      }
    }
    function refreshUniformsPhysical(uniforms, material) {
      refreshUniformsStandard(uniforms, material);
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.clearCoat.value = material.clearCoat;
      uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
    }
    function refreshUniformsMatcap(uniforms, material) {
      if (material.matcap) {
        uniforms.matcap.value = material.matcap;
      }
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDepth(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function refreshUniformsDistance(uniforms, material) {
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
      uniforms.referencePosition.value.copy(material.referencePosition);
      uniforms.nearDistance.value = material.nearDistance;
      uniforms.farDistance.value = material.farDistance;
    }
    function refreshUniformsNormal(uniforms, material) {
      if (material.bumpMap) {
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.bumpScale.value = material.bumpScale;
        if (material.side === BackSide)
          uniforms.bumpScale.value *= -1;
      }
      if (material.normalMap) {
        uniforms.normalMap.value = material.normalMap;
        uniforms.normalScale.value.copy(material.normalScale);
        if (material.side === BackSide)
          uniforms.normalScale.value.negate();
      }
      if (material.displacementMap) {
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;
      }
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    this.setFramebuffer = function(value) {
      _framebuffer = value;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace, activeMipMapLevel) {
      _currentRenderTarget = renderTarget;
      if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget);
      }
      var framebuffer = _framebuffer;
      var isCube = false;
      if (renderTarget) {
        var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLRenderTargetCube) {
          framebuffer = __webglFramebuffer[activeCubeFace || 0];
          isCube = true;
        } else if (renderTarget.isWebGLMultisampleRenderTarget) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          framebuffer = __webglFramebuffer;
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio);
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio);
        _currentScissorTest = _scissorTest;
      }
      if (_currentFramebuffer !== framebuffer) {
        _gl.bindFramebuffer(36160, framebuffer);
        _currentFramebuffer = framebuffer;
      }
      state2.viewport(_currentViewport);
      state2.scissor(_currentScissor);
      state2.setScissorTest(_currentScissorTest);
      if (isCube) {
        var textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipMapLevel || 0);
      }
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width2, height2, buffer) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      var framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (framebuffer) {
        var restore = false;
        if (framebuffer !== _currentFramebuffer) {
          _gl.bindFramebuffer(36160, framebuffer);
          restore = true;
        }
        try {
          var texture = renderTarget.texture;
          var textureFormat = texture.format;
          var textureType = texture.type;
          if (textureFormat !== RGBAFormat && utils2.convert(textureFormat) !== _gl.getParameter(35739)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (textureType !== UnsignedByteType && utils2.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (_gl.checkFramebufferStatus(36160) === 36053) {
            if (x >= 0 && x <= renderTarget.width - width2 && (y >= 0 && y <= renderTarget.height - height2)) {
              _gl.readPixels(x, y, width2, height2, utils2.convert(textureFormat), utils2.convert(textureType), buffer);
            }
          } else {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
          }
        } finally {
          if (restore) {
            _gl.bindFramebuffer(36160, _currentFramebuffer);
          }
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level) {
      var width2 = texture.image.width;
      var height2 = texture.image.height;
      var glFormat = utils2.convert(texture.format);
      textures.setTexture2D(texture, 0);
      _gl.copyTexImage2D(3553, level || 0, glFormat, position.x, position.y, width2, height2, 0);
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level) {
      var width2 = srcTexture.image.width;
      var height2 = srcTexture.image.height;
      var glFormat = utils2.convert(dstTexture.format);
      var glType = utils2.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(3553, level || 0, position.x, position.y, width2, height2, glFormat, glType, srcTexture.image.data);
      } else {
        _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
      }
    };
  }
  function FogExp2(color, density) {
    this.name = "";
    this.color = new Color(color);
    this.density = density !== void 0 ? density : 25e-5;
  }
  Object.assign(FogExp2.prototype, {
    isFogExp2: true,
    clone: function() {
      return new FogExp2(this.color, this.density);
    },
    toJSON: function() {
      return {
        type: "FogExp2",
        color: this.color.getHex(),
        density: this.density
      };
    }
  });
  function Fog(color, near, far) {
    this.name = "";
    this.color = new Color(color);
    this.near = near !== void 0 ? near : 1;
    this.far = far !== void 0 ? far : 1e3;
  }
  Object.assign(Fog.prototype, {
    isFog: true,
    clone: function() {
      return new Fog(this.color, this.near, this.far);
    },
    toJSON: function() {
      return {
        type: "Fog",
        color: this.color.getHex(),
        near: this.near,
        far: this.far
      };
    }
  });
  function Scene() {
    Object3D.call(this);
    this.type = "Scene";
    this.background = null;
    this.fog = null;
    this.overrideMaterial = null;
    this.autoUpdate = true;
  }
  Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Scene,
    isScene: true,
    copy: function(source, recursive) {
      Object3D.prototype.copy.call(this, source, recursive);
      if (source.background !== null)
        this.background = source.background.clone();
      if (source.fog !== null)
        this.fog = source.fog.clone();
      if (source.overrideMaterial !== null)
        this.overrideMaterial = source.overrideMaterial.clone();
      this.autoUpdate = source.autoUpdate;
      this.matrixAutoUpdate = source.matrixAutoUpdate;
      return this;
    },
    toJSON: function(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      if (this.background !== null)
        data.object.background = this.background.toJSON(meta);
      if (this.fog !== null)
        data.object.fog = this.fog.toJSON();
      return data;
    },
    dispose: function() {
      this.dispatchEvent({ type: "dispose" });
    }
  });
  function InterleavedBuffer(array, stride) {
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.dynamic = false;
    this.updateRange = { offset: 0, count: -1 };
    this.version = 0;
  }
  Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
    set: function(value) {
      if (value === true)
        this.version++;
    }
  });
  Object.assign(InterleavedBuffer.prototype, {
    isInterleavedBuffer: true,
    onUploadCallback: function() {
    },
    setArray: function(array) {
      if (Array.isArray(array)) {
        throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      }
      this.count = array !== void 0 ? array.length / this.stride : 0;
      this.array = array;
      return this;
    },
    setDynamic: function(value) {
      this.dynamic = value;
      return this;
    },
    copy: function(source) {
      this.array = new source.array.constructor(source.array);
      this.count = source.count;
      this.stride = source.stride;
      this.dynamic = source.dynamic;
      return this;
    },
    copyAt: function(index1, attribute, index2) {
      index1 *= this.stride;
      index2 *= attribute.stride;
      for (var i = 0, l = this.stride; i < l; i++) {
        this.array[index1 + i] = attribute.array[index2 + i];
      }
      return this;
    },
    set: function(value, offset) {
      if (offset === void 0)
        offset = 0;
      this.array.set(value, offset);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    onUpload: function(callback) {
      this.onUploadCallback = callback;
      return this;
    }
  });
  function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized === true;
  }
  Object.defineProperties(InterleavedBufferAttribute.prototype, {
    count: {
      get: function() {
        return this.data.count;
      }
    },
    array: {
      get: function() {
        return this.data.array;
      }
    }
  });
  Object.assign(InterleavedBufferAttribute.prototype, {
    isInterleavedBufferAttribute: true,
    setX: function(index, x) {
      this.data.array[index * this.data.stride + this.offset] = x;
      return this;
    },
    setY: function(index, y) {
      this.data.array[index * this.data.stride + this.offset + 1] = y;
      return this;
    },
    setZ: function(index, z) {
      this.data.array[index * this.data.stride + this.offset + 2] = z;
      return this;
    },
    setW: function(index, w) {
      this.data.array[index * this.data.stride + this.offset + 3] = w;
      return this;
    },
    getX: function(index) {
      return this.data.array[index * this.data.stride + this.offset];
    },
    getY: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 1];
    },
    getZ: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 2];
    },
    getW: function(index) {
      return this.data.array[index * this.data.stride + this.offset + 3];
    },
    setXY: function(index, x, y) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      return this;
    },
    setXYZ: function(index, x, y, z) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      return this;
    },
    setXYZW: function(index, x, y, z, w) {
      index = index * this.data.stride + this.offset;
      this.data.array[index + 0] = x;
      this.data.array[index + 1] = y;
      this.data.array[index + 2] = z;
      this.data.array[index + 3] = w;
      return this;
    }
  });
  function SpriteMaterial(parameters) {
    Material.call(this);
    this.type = "SpriteMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.rotation = 0;
    this.sizeAttenuation = true;
    this.lights = false;
    this.transparent = true;
    this.setValues(parameters);
  }
  SpriteMaterial.prototype = Object.create(Material.prototype);
  SpriteMaterial.prototype.constructor = SpriteMaterial;
  SpriteMaterial.prototype.isSpriteMaterial = true;
  SpriteMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.rotation = source.rotation;
    this.sizeAttenuation = source.sizeAttenuation;
    return this;
  };
  var geometry;
  function Sprite(material) {
    Object3D.call(this);
    this.type = "Sprite";
    if (geometry === void 0) {
      geometry = new BufferGeometry();
      var float32Array = new Float32Array([
        -0.5,
        -0.5,
        0,
        0,
        0,
        0.5,
        -0.5,
        0,
        1,
        0,
        0.5,
        0.5,
        0,
        1,
        1,
        -0.5,
        0.5,
        0,
        0,
        1
      ]);
      var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
      geometry.setIndex([0, 1, 2, 0, 2, 3]);
      geometry.addAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
      geometry.addAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
    }
    this.geometry = geometry;
    this.material = material !== void 0 ? material : new SpriteMaterial();
    this.center = new Vector2(0.5, 0.5);
  }
  Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Sprite,
    isSprite: true,
    raycast: function() {
      var intersectPoint = new Vector3();
      var worldScale = new Vector3();
      var mvPosition = new Vector3();
      var alignedPosition = new Vector2();
      var rotatedPosition = new Vector2();
      var viewWorldMatrix = new Matrix4();
      var vA = new Vector3();
      var vB = new Vector3();
      var vC = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();
      function transformVertex(vertexPosition, mvPosition2, center, scale3, sin, cos) {
        alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale3);
        if (sin !== void 0) {
          rotatedPosition.x = cos * alignedPosition.x - sin * alignedPosition.y;
          rotatedPosition.y = sin * alignedPosition.x + cos * alignedPosition.y;
        } else {
          rotatedPosition.copy(alignedPosition);
        }
        vertexPosition.copy(mvPosition2);
        vertexPosition.x += rotatedPosition.x;
        vertexPosition.y += rotatedPosition.y;
        vertexPosition.applyMatrix4(viewWorldMatrix);
      }
      return function raycast(raycaster, intersects2) {
        worldScale.setFromMatrixScale(this.matrixWorld);
        viewWorldMatrix.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld);
        mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        var rotation = this.material.rotation;
        var sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        var center = this.center;
        transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
        transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
        transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
        uvA.set(0, 0);
        uvB.set(1, 0);
        uvC.set(1, 1);
        var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);
        if (intersect === null) {
          transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
          uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far)
          return;
        intersects2.push({
          distance,
          point: intersectPoint.clone(),
          uv: Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2()),
          face: null,
          object: this
        });
      };
    }(),
    clone: function() {
      return new this.constructor(this.material).copy(this);
    },
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      if (source.center !== void 0)
        this.center.copy(source.center);
      return this;
    }
  });
  function LOD() {
    Object3D.call(this);
    this.type = "LOD";
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: []
      }
    });
  }
  LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: LOD,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source, false);
      var levels = source.levels;
      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        this.addLevel(level.object.clone(), level.distance);
      }
      return this;
    },
    addLevel: function(object, distance) {
      if (distance === void 0)
        distance = 0;
      distance = Math.abs(distance);
      var levels = this.levels;
      for (var l = 0; l < levels.length; l++) {
        if (distance < levels[l].distance) {
          break;
        }
      }
      levels.splice(l, 0, { distance, object });
      this.add(object);
    },
    getObjectForDistance: function(distance) {
      var levels = this.levels;
      for (var i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break;
        }
      }
      return levels[i - 1].object;
    },
    raycast: function() {
      var matrixPosition = new Vector3();
      return function raycast(raycaster, intersects2) {
        matrixPosition.setFromMatrixPosition(this.matrixWorld);
        var distance = raycaster.ray.origin.distanceTo(matrixPosition);
        this.getObjectForDistance(distance).raycast(raycaster, intersects2);
      };
    }(),
    update: function() {
      var v1 = new Vector3();
      var v2 = new Vector3();
      return function update3(camera2) {
        var levels = this.levels;
        if (levels.length > 1) {
          v1.setFromMatrixPosition(camera2.matrixWorld);
          v2.setFromMatrixPosition(this.matrixWorld);
          var distance = v1.distanceTo(v2);
          levels[0].object.visible = true;
          for (var i = 1, l = levels.length; i < l; i++) {
            if (distance >= levels[i].distance) {
              levels[i - 1].object.visible = false;
              levels[i].object.visible = true;
            } else {
              break;
            }
          }
          for (; i < l; i++) {
            levels[i].object.visible = false;
          }
        }
      };
    }(),
    toJSON: function(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.levels = [];
      var levels = this.levels;
      for (var i = 0, l = levels.length; i < l; i++) {
        var level = levels[i];
        data.object.levels.push({
          object: level.object.uuid,
          distance: level.distance
        });
      }
      return data;
    }
  });
  function SkinnedMesh(geometry2, material) {
    if (geometry2 && geometry2.isGeometry) {
      console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
    }
    Mesh.call(this, geometry2, material);
    this.type = "SkinnedMesh";
    this.bindMode = "attached";
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
  }
  SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
    constructor: SkinnedMesh,
    isSkinnedMesh: true,
    bind: function(skeleton, bindMatrix) {
      this.skeleton = skeleton;
      if (bindMatrix === void 0) {
        this.updateMatrixWorld(true);
        this.skeleton.calculateInverses();
        bindMatrix = this.matrixWorld;
      }
      this.bindMatrix.copy(bindMatrix);
      this.bindMatrixInverse.getInverse(bindMatrix);
    },
    pose: function() {
      this.skeleton.pose();
    },
    normalizeSkinWeights: function() {
      var vector = new Vector4();
      var skinWeight = this.geometry.attributes.skinWeight;
      for (var i = 0, l = skinWeight.count; i < l; i++) {
        vector.x = skinWeight.getX(i);
        vector.y = skinWeight.getY(i);
        vector.z = skinWeight.getZ(i);
        vector.w = skinWeight.getW(i);
        var scale3 = 1 / vector.manhattanLength();
        if (scale3 !== Infinity) {
          vector.multiplyScalar(scale3);
        } else {
          vector.set(1, 0, 0, 0);
        }
        skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
      }
    },
    updateMatrixWorld: function(force) {
      Mesh.prototype.updateMatrixWorld.call(this, force);
      if (this.bindMode === "attached") {
        this.bindMatrixInverse.getInverse(this.matrixWorld);
      } else if (this.bindMode === "detached") {
        this.bindMatrixInverse.getInverse(this.bindMatrix);
      } else {
        console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
      }
    },
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  function Skeleton(bones2, boneInverses) {
    bones2 = bones2 || [];
    this.bones = bones2.slice(0);
    this.boneMatrices = new Float32Array(this.bones.length * 16);
    if (boneInverses === void 0) {
      this.calculateInverses();
    } else {
      if (this.bones.length === boneInverses.length) {
        this.boneInverses = boneInverses.slice(0);
      } else {
        console.warn("THREE.Skeleton boneInverses is the wrong length.");
        this.boneInverses = [];
        for (var i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  Object.assign(Skeleton.prototype, {
    calculateInverses: function() {
      this.boneInverses = [];
      for (var i = 0, il = this.bones.length; i < il; i++) {
        var inverse = new Matrix4();
        if (this.bones[i]) {
          inverse.getInverse(this.bones[i].matrixWorld);
        }
        this.boneInverses.push(inverse);
      }
    },
    pose: function() {
      var bone, i, il;
      for (i = 0, il = this.bones.length; i < il; i++) {
        bone = this.bones[i];
        if (bone) {
          bone.matrixWorld.getInverse(this.boneInverses[i]);
        }
      }
      for (i = 0, il = this.bones.length; i < il; i++) {
        bone = this.bones[i];
        if (bone) {
          if (bone.parent && bone.parent.isBone) {
            bone.matrix.getInverse(bone.parent.matrixWorld);
            bone.matrix.multiply(bone.matrixWorld);
          } else {
            bone.matrix.copy(bone.matrixWorld);
          }
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        }
      }
    },
    update: function() {
      var offsetMatrix = new Matrix4();
      var identityMatrix = new Matrix4();
      return function update3() {
        var bones2 = this.bones;
        var boneInverses = this.boneInverses;
        var boneMatrices = this.boneMatrices;
        var boneTexture = this.boneTexture;
        for (var i = 0, il = bones2.length; i < il; i++) {
          var matrix = bones2[i] ? bones2[i].matrixWorld : identityMatrix;
          offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
          offsetMatrix.toArray(boneMatrices, i * 16);
        }
        if (boneTexture !== void 0) {
          boneTexture.needsUpdate = true;
        }
      };
    }(),
    clone: function() {
      return new Skeleton(this.bones, this.boneInverses);
    },
    getBoneByName: function(name) {
      for (var i = 0, il = this.bones.length; i < il; i++) {
        var bone = this.bones[i];
        if (bone.name === name) {
          return bone;
        }
      }
      return void 0;
    }
  });
  function Bone() {
    Object3D.call(this);
    this.type = "Bone";
  }
  Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Bone,
    isBone: true
  });
  function LineBasicMaterial(parameters) {
    Material.call(this);
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.lights = false;
    this.setValues(parameters);
  }
  LineBasicMaterial.prototype = Object.create(Material.prototype);
  LineBasicMaterial.prototype.constructor = LineBasicMaterial;
  LineBasicMaterial.prototype.isLineBasicMaterial = true;
  LineBasicMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    return this;
  };
  function Line(geometry2, material, mode) {
    if (mode === 1) {
      console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
    }
    Object3D.call(this);
    this.type = "Line";
    this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
    this.material = material !== void 0 ? material : new LineBasicMaterial({ color: Math.random() * 16777215 });
  }
  Line.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Line,
    isLine: true,
    computeLineDistances: function() {
      var start2 = new Vector3();
      var end2 = new Vector3();
      return function computeLineDistances() {
        var geometry2 = this.geometry;
        if (geometry2.isBufferGeometry) {
          if (geometry2.index === null) {
            var positionAttribute = geometry2.attributes.position;
            var lineDistances = [0];
            for (var i = 1, l = positionAttribute.count; i < l; i++) {
              start2.fromBufferAttribute(positionAttribute, i - 1);
              end2.fromBufferAttribute(positionAttribute, i);
              lineDistances[i] = lineDistances[i - 1];
              lineDistances[i] += start2.distanceTo(end2);
            }
            geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry2.isGeometry) {
          var vertices = geometry2.vertices;
          var lineDistances = geometry2.lineDistances;
          lineDistances[0] = 0;
          for (var i = 1, l = vertices.length; i < l; i++) {
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
          }
        }
        return this;
      };
    }(),
    raycast: function() {
      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();
      return function raycast(raycaster, intersects2) {
        var precision = raycaster.linePrecision;
        var geometry2 = this.geometry;
        var matrixWorld = this.matrixWorld;
        if (geometry2.boundingSphere === null)
          geometry2.computeBoundingSphere();
        sphere.copy(geometry2.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        sphere.radius += precision;
        if (raycaster.ray.intersectsSphere(sphere) === false)
          return;
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var localPrecision = precision / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localPrecisionSq = localPrecision * localPrecision;
        var vStart = new Vector3();
        var vEnd = new Vector3();
        var interSegment = new Vector3();
        var interRay = new Vector3();
        var step = this && this.isLineSegments ? 2 : 1;
        if (geometry2.isBufferGeometry) {
          var index = geometry2.index;
          var attributes = geometry2.attributes;
          var positions = attributes.position.array;
          if (index !== null) {
            var indices = index.array;
            for (var i = 0, l = indices.length - 1; i < l; i += step) {
              var a = indices[i];
              var b = indices[i + 1];
              vStart.fromArray(positions, a * 3);
              vEnd.fromArray(positions, b * 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localPrecisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          } else {
            for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
              vStart.fromArray(positions, 3 * i);
              vEnd.fromArray(positions, 3 * i + 3);
              var distSq = ray.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
              if (distSq > localPrecisionSq)
                continue;
              interRay.applyMatrix4(this.matrixWorld);
              var distance = raycaster.ray.origin.distanceTo(interRay);
              if (distance < raycaster.near || distance > raycaster.far)
                continue;
              intersects2.push({
                distance,
                point: interSegment.clone().applyMatrix4(this.matrixWorld),
                index: i,
                face: null,
                faceIndex: null,
                object: this
              });
            }
          }
        } else if (geometry2.isGeometry) {
          var vertices = geometry2.vertices;
          var nbVertices = vertices.length;
          for (var i = 0; i < nbVertices - 1; i += step) {
            var distSq = ray.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
            if (distSq > localPrecisionSq)
              continue;
            interRay.applyMatrix4(this.matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(interRay);
            if (distance < raycaster.near || distance > raycaster.far)
              continue;
            intersects2.push({
              distance,
              point: interSegment.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this
            });
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  function LineSegments(geometry2, material) {
    Line.call(this, geometry2, material);
    this.type = "LineSegments";
  }
  LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineSegments,
    isLineSegments: true,
    computeLineDistances: function() {
      var start2 = new Vector3();
      var end2 = new Vector3();
      return function computeLineDistances() {
        var geometry2 = this.geometry;
        if (geometry2.isBufferGeometry) {
          if (geometry2.index === null) {
            var positionAttribute = geometry2.attributes.position;
            var lineDistances = [];
            for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
              start2.fromBufferAttribute(positionAttribute, i);
              end2.fromBufferAttribute(positionAttribute, i + 1);
              lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
              lineDistances[i + 1] = lineDistances[i] + start2.distanceTo(end2);
            }
            geometry2.addAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
          } else {
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
          }
        } else if (geometry2.isGeometry) {
          var vertices = geometry2.vertices;
          var lineDistances = geometry2.lineDistances;
          for (var i = 0, l = vertices.length; i < l; i += 2) {
            start2.copy(vertices[i]);
            end2.copy(vertices[i + 1]);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + start2.distanceTo(end2);
          }
        }
        return this;
      };
    }()
  });
  function LineLoop(geometry2, material) {
    Line.call(this, geometry2, material);
    this.type = "LineLoop";
  }
  LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
    constructor: LineLoop,
    isLineLoop: true
  });
  function PointsMaterial(parameters) {
    Material.call(this);
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.morphTargets = false;
    this.lights = false;
    this.setValues(parameters);
  }
  PointsMaterial.prototype = Object.create(Material.prototype);
  PointsMaterial.prototype.constructor = PointsMaterial;
  PointsMaterial.prototype.isPointsMaterial = true;
  PointsMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.morphTargets = source.morphTargets;
    return this;
  };
  function Points(geometry2, material) {
    Object3D.call(this);
    this.type = "Points";
    this.geometry = geometry2 !== void 0 ? geometry2 : new BufferGeometry();
    this.material = material !== void 0 ? material : new PointsMaterial({ color: Math.random() * 16777215 });
  }
  Points.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Points,
    isPoints: true,
    raycast: function() {
      var inverseMatrix = new Matrix4();
      var ray = new Ray();
      var sphere = new Sphere();
      return function raycast(raycaster, intersects2) {
        var object = this;
        var geometry2 = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;
        if (geometry2.boundingSphere === null)
          geometry2.computeBoundingSphere();
        sphere.copy(geometry2.boundingSphere);
        sphere.applyMatrix4(matrixWorld);
        sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(sphere) === false)
          return;
        inverseMatrix.getInverse(matrixWorld);
        ray.copy(raycaster.ray).applyMatrix4(inverseMatrix);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var position = new Vector3();
        var intersectPoint = new Vector3();
        function testPoint(point, index2) {
          var rayPointDistanceSq = ray.distanceSqToPoint(point);
          if (rayPointDistanceSq < localThresholdSq) {
            ray.closestPointToPoint(point, intersectPoint);
            intersectPoint.applyMatrix4(matrixWorld);
            var distance = raycaster.ray.origin.distanceTo(intersectPoint);
            if (distance < raycaster.near || distance > raycaster.far)
              return;
            intersects2.push({
              distance,
              distanceToRay: Math.sqrt(rayPointDistanceSq),
              point: intersectPoint.clone(),
              index: index2,
              face: null,
              object
            });
          }
        }
        if (geometry2.isBufferGeometry) {
          var index = geometry2.index;
          var attributes = geometry2.attributes;
          var positions = attributes.position.array;
          if (index !== null) {
            var indices = index.array;
            for (var i = 0, il = indices.length; i < il; i++) {
              var a = indices[i];
              position.fromArray(positions, a * 3);
              testPoint(position, a);
            }
          } else {
            for (var i = 0, l = positions.length / 3; i < l; i++) {
              position.fromArray(positions, i * 3);
              testPoint(position, i);
            }
          }
        } else {
          var vertices = geometry2.vertices;
          for (var i = 0, l = vertices.length; i < l; i++) {
            testPoint(vertices[i], i);
          }
        }
      };
    }(),
    clone: function() {
      return new this.constructor(this.geometry, this.material).copy(this);
    }
  });
  function VideoTexture(video2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, video2, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.format = format !== void 0 ? format : RGBFormat;
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;
    this.generateMipmaps = false;
  }
  VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
    constructor: VideoTexture,
    isVideoTexture: true,
    update: function() {
      var video2 = this.image;
      if (video2.readyState >= video2.HAVE_CURRENT_DATA) {
        this.needsUpdate = true;
      }
    }
  });
  function CompressedTexture(mipmaps, width2, height2, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
    this.image = { width: width2, height: height2 };
    this.mipmaps = mipmaps;
    this.flipY = false;
    this.generateMipmaps = false;
  }
  CompressedTexture.prototype = Object.create(Texture.prototype);
  CompressedTexture.prototype.constructor = CompressedTexture;
  CompressedTexture.prototype.isCompressedTexture = true;
  function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
    Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.needsUpdate = true;
  }
  CanvasTexture.prototype = Object.create(Texture.prototype);
  CanvasTexture.prototype.constructor = CanvasTexture;
  CanvasTexture.prototype.isCanvasTexture = true;
  function DepthTexture(width2, height2, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedShortType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.image = { width: width2, height: height2 };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
  }
  DepthTexture.prototype = Object.create(Texture.prototype);
  DepthTexture.prototype.constructor = DepthTexture;
  DepthTexture.prototype.isDepthTexture = true;
  function WireframeGeometry(geometry2) {
    BufferGeometry.call(this);
    this.type = "WireframeGeometry";
    var vertices = [];
    var i, j, l, o, ol;
    var edge = [0, 0], edges = {}, e, edge1, edge2;
    var key, keys = ["a", "b", "c"];
    var vertex;
    if (geometry2 && geometry2.isGeometry) {
      var faces = geometry2.faces;
      for (i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        for (j = 0; j < 3; j++) {
          edge1 = face[keys[j]];
          edge2 = face[keys[(j + 1) % 3]];
          edge[0] = Math.min(edge1, edge2);
          edge[1] = Math.max(edge1, edge2);
          key = edge[0] + "," + edge[1];
          if (edges[key] === void 0) {
            edges[key] = { index1: edge[0], index2: edge[1] };
          }
        }
      }
      for (key in edges) {
        e = edges[key];
        vertex = geometry2.vertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = geometry2.vertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    } else if (geometry2 && geometry2.isBufferGeometry) {
      var position, indices, groups;
      var group, start2, count2;
      var index1, index2;
      vertex = new Vector3();
      if (geometry2.index !== null) {
        position = geometry2.attributes.position;
        indices = geometry2.index;
        groups = geometry2.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (o = 0, ol = groups.length; o < ol; ++o) {
          group = groups[o];
          start2 = group.start;
          count2 = group.count;
          for (i = start2, l = start2 + count2; i < l; i += 3) {
            for (j = 0; j < 3; j++) {
              edge1 = indices.getX(i + j);
              edge2 = indices.getX(i + (j + 1) % 3);
              edge[0] = Math.min(edge1, edge2);
              edge[1] = Math.max(edge1, edge2);
              key = edge[0] + "," + edge[1];
              if (edges[key] === void 0) {
                edges[key] = { index1: edge[0], index2: edge[1] };
              }
            }
          }
        }
        for (key in edges) {
          e = edges[key];
          vertex.fromBufferAttribute(position, e.index1);
          vertices.push(vertex.x, vertex.y, vertex.z);
          vertex.fromBufferAttribute(position, e.index2);
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      } else {
        position = geometry2.attributes.position;
        for (i = 0, l = position.count / 3; i < l; i++) {
          for (j = 0; j < 3; j++) {
            index1 = 3 * i + j;
            vertex.fromBufferAttribute(position, index1);
            vertices.push(vertex.x, vertex.y, vertex.z);
            index2 = 3 * i + (j + 1) % 3;
            vertex.fromBufferAttribute(position, index2);
            vertices.push(vertex.x, vertex.y, vertex.z);
          }
        }
      }
    }
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
  WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
  WireframeGeometry.prototype.constructor = WireframeGeometry;
  function ParametricGeometry(func, slices, stacks) {
    Geometry.call(this);
    this.type = "ParametricGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
    this.mergeVertices();
  }
  ParametricGeometry.prototype = Object.create(Geometry.prototype);
  ParametricGeometry.prototype.constructor = ParametricGeometry;
  function ParametricBufferGeometry(func, slices, stacks) {
    BufferGeometry.call(this);
    this.type = "ParametricBufferGeometry";
    this.parameters = {
      func,
      slices,
      stacks
    };
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var EPS = 1e-5;
    var normal = new Vector3();
    var p0 = new Vector3(), p1 = new Vector3();
    var pu = new Vector3(), pv = new Vector3();
    var i, j;
    if (func.length < 3) {
      console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
    }
    var sliceCount = slices + 1;
    for (i = 0; i <= stacks; i++) {
      var v = i / stacks;
      for (j = 0; j <= slices; j++) {
        var u = j / slices;
        func(u, v, p0);
        vertices.push(p0.x, p0.y, p0.z);
        if (u - EPS >= 0) {
          func(u - EPS, v, p1);
          pu.subVectors(p0, p1);
        } else {
          func(u + EPS, v, p1);
          pu.subVectors(p1, p0);
        }
        if (v - EPS >= 0) {
          func(u, v - EPS, p1);
          pv.subVectors(p0, p1);
        } else {
          func(u, v + EPS, p1);
          pv.subVectors(p1, p0);
        }
        normal.crossVectors(pu, pv).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u, v);
      }
    }
    for (i = 0; i < stacks; i++) {
      for (j = 0; j < slices; j++) {
        var a = i * sliceCount + j;
        var b = i * sliceCount + j + 1;
        var c = (i + 1) * sliceCount + j + 1;
        var d = (i + 1) * sliceCount + j;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
  function PolyhedronGeometry(vertices, indices, radius, detail) {
    Geometry.call(this);
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
    this.mergeVertices();
  }
  PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
  PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
  function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
    BufferGeometry.call(this);
    this.type = "PolyhedronBufferGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    radius = radius || 1;
    detail = detail || 0;
    var vertexBuffer = [];
    var uvBuffer = [];
    subdivide(detail);
    appplyRadius(radius);
    generateUVs();
    this.addAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
    this.addAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();
      for (var i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      var cols = Math.pow(2, detail2);
      var v = [];
      var i, j;
      for (i = 0; i <= cols; i++) {
        v[i] = [];
        var aj = a.clone().lerp(c, i / cols);
        var bj = b.clone().lerp(c, i / cols);
        var rows = cols - i;
        for (j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (i = 0; i < cols; i++) {
        for (j = 0; j < 2 * (cols - i) - 1; j++) {
          var k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function appplyRadius(radius2) {
      var vertex = new Vector3();
      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        vertex.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex.x;
        vertexBuffer[i + 1] = vertex.y;
        vertexBuffer[i + 2] = vertex.z;
      }
    }
    function generateUVs() {
      var vertex = new Vector3();
      for (var i = 0; i < vertexBuffer.length; i += 3) {
        vertex.x = vertexBuffer[i + 0];
        vertex.y = vertexBuffer[i + 1];
        vertex.z = vertexBuffer[i + 2];
        var u = azimuth(vertex) / 2 / Math.PI + 0.5;
        var v = inclination(vertex) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (var i = 0; i < uvBuffer.length; i += 6) {
        var x0 = uvBuffer[i + 0];
        var x1 = uvBuffer[i + 2];
        var x2 = uvBuffer[i + 4];
        var max = Math.max(x0, x1, x2);
        var min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex) {
      vertexBuffer.push(vertex.x, vertex.y, vertex.z);
    }
    function getVertexByIndex(index, vertex) {
      var stride = index * 3;
      vertex.x = vertices[stride + 0];
      vertex.y = vertices[stride + 1];
      vertex.z = vertices[stride + 2];
    }
    function correctUVs() {
      var a = new Vector3();
      var b = new Vector3();
      var c = new Vector3();
      var centroid = new Vector3();
      var uvA = new Vector2();
      var uvB = new Vector2();
      var uvC = new Vector2();
      for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        var azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
  function TetrahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
    this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }
  TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
  TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
  function TetrahedronBufferGeometry(radius, detail) {
    var vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    var indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "TetrahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
  function OctahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
    this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }
  OctahedronGeometry.prototype = Object.create(Geometry.prototype);
  OctahedronGeometry.prototype.constructor = OctahedronGeometry;
  function OctahedronBufferGeometry(radius, detail) {
    var vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    var indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "OctahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
  function IcosahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
    this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }
  IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
  IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
  function IcosahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    var indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "IcosahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
  function DodecahedronGeometry(radius, detail) {
    Geometry.call(this);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
    this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
    this.mergeVertices();
  }
  DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
  DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
  function DodecahedronBufferGeometry(radius, detail) {
    var t = (1 + Math.sqrt(5)) / 2;
    var r = 1 / t;
    var vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    var indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
    this.type = "DodecahedronBufferGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
  DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
  function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
    Geometry.call(this);
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    if (taper !== void 0)
      console.warn("THREE.TubeGeometry: taper has been removed.");
    var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
    this.tangents = bufferGeometry.tangents;
    this.normals = bufferGeometry.normals;
    this.binormals = bufferGeometry.binormals;
    this.fromBufferGeometry(bufferGeometry);
    this.mergeVertices();
  }
  TubeGeometry.prototype = Object.create(Geometry.prototype);
  TubeGeometry.prototype.constructor = TubeGeometry;
  function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
    BufferGeometry.call(this);
    this.type = "TubeBufferGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    tubularSegments = tubularSegments || 64;
    radius = radius || 1;
    radialSegments = radialSegments || 8;
    closed = closed || false;
    var frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    var vertex = new Vector3();
    var normal = new Vector3();
    var uv = new Vector2();
    var P = new Vector3();
    var i, j;
    var vertices = [];
    var normals = [];
    var uvs = [];
    var indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateBufferData() {
      for (i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i2) {
      P = path.getPointAt(i2 / tubularSegments, P);
      var N = frames.normals[i2];
      var B = frames.binormals[i2];
      for (j = 0; j <= radialSegments; j++) {
        var v = j / radialSegments * Math.PI * 2;
        var sin = Math.sin(v);
        var cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex.x = P.x + radius * normal.x;
        vertex.y = P.y + radius * normal.y;
        vertex.z = P.z + radius * normal.z;
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    function generateIndices() {
      for (j = 1; j <= tubularSegments; j++) {
        for (i = 1; i <= radialSegments; i++) {
          var a = (radialSegments + 1) * (j - 1) + (i - 1);
          var b = (radialSegments + 1) * j + (i - 1);
          var c = (radialSegments + 1) * j + i;
          var d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (i = 0; i <= tubularSegments; i++) {
        for (j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
  TubeBufferGeometry.prototype.toJSON = function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    data.path = this.parameters.path.toJSON();
    return data;
  };
  function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p2, q2, heightScale) {
    Geometry.call(this);
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q: q2
    };
    if (heightScale !== void 0)
      console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
    this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p2, q2));
    this.mergeVertices();
  }
  TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
  TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
  function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p2, q2) {
    BufferGeometry.call(this);
    this.type = "TorusKnotBufferGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q: q2
    };
    radius = radius || 1;
    tube = tube || 0.4;
    tubularSegments = Math.floor(tubularSegments) || 64;
    radialSegments = Math.floor(radialSegments) || 8;
    p2 = p2 || 2;
    q2 = q2 || 3;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var i, j;
    var vertex = new Vector3();
    var normal = new Vector3();
    var P1 = new Vector3();
    var P2 = new Vector3();
    var B = new Vector3();
    var T = new Vector3();
    var N = new Vector3();
    for (i = 0; i <= tubularSegments; ++i) {
      var u = i / tubularSegments * p2 * Math.PI * 2;
      calculatePositionOnCurve(u, p2, q2, radius, P1);
      calculatePositionOnCurve(u + 0.01, p2, q2, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (j = 0; j <= radialSegments; ++j) {
        var v = j / radialSegments * Math.PI * 2;
        var cx = -tube * Math.cos(v);
        var cy = tube * Math.sin(v);
        vertex.x = P1.x + (cx * N.x + cy * B.x);
        vertex.y = P1.y + (cx * N.y + cy * B.y);
        vertex.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.subVectors(vertex, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (j = 1; j <= tubularSegments; j++) {
      for (i = 1; i <= radialSegments; i++) {
        var a = (radialSegments + 1) * (j - 1) + (i - 1);
        var b = (radialSegments + 1) * j + (i - 1);
        var c = (radialSegments + 1) * j + i;
        var d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function calculatePositionOnCurve(u2, p3, q3, radius2, position) {
      var cu = Math.cos(u2);
      var su = Math.sin(u2);
      var quOverP = q3 / p3 * u2;
      var cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
  function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    Geometry.call(this);
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
    this.mergeVertices();
  }
  TorusGeometry.prototype = Object.create(Geometry.prototype);
  TorusGeometry.prototype.constructor = TorusGeometry;
  function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
    BufferGeometry.call(this);
    this.type = "TorusBufferGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radius = radius || 1;
    tube = tube || 0.4;
    radialSegments = Math.floor(radialSegments) || 8;
    tubularSegments = Math.floor(tubularSegments) || 6;
    arc = arc || Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var center = new Vector3();
    var vertex = new Vector3();
    var normal = new Vector3();
    var j, i;
    for (j = 0; j <= radialSegments; j++) {
      for (i = 0; i <= tubularSegments; i++) {
        var u = i / tubularSegments * arc;
        var v = j / radialSegments * Math.PI * 2;
        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex.z = tube * Math.sin(v);
        vertices.push(vertex.x, vertex.y, vertex.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (j = 1; j <= radialSegments; j++) {
      for (i = 1; i <= tubularSegments; i++) {
        var a = (tubularSegments + 1) * j + i - 1;
        var b = (tubularSegments + 1) * (j - 1) + i - 1;
        var c = (tubularSegments + 1) * (j - 1) + i;
        var d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
  var Earcut = {
    triangulate: function(data, holeIndices, dim) {
      dim = dim || 2;
      var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
      if (!outerNode)
        return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles)
        outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    }
  };
  function linkedList(data, start2, end2, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start2, end2, dim) > 0) {
      for (i = start2; i < end2; i += dim)
        last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end2 - dim; i >= start2; i -= dim)
        last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }
  function filterPoints(start2, end2) {
    if (!start2)
      return start2;
    if (!end2)
      end2 = start2;
    var p2 = start2, again;
    do {
      again = false;
      if (!p2.steiner && (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)) {
        removeNode(p2);
        p2 = end2 = p2.prev;
        if (p2 === p2.next)
          break;
        again = true;
      } else {
        p2 = p2.next;
      }
    } while (again || p2 !== end2);
    return end2;
  }
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear)
      return;
    if (!pass && invSize)
      indexCurve(ear, minX, minY, invSize);
    var stop = ear, prev, next;
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear);
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;
      if (ear === stop) {
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
        } else if (pass === 1) {
          ear = cureLocalIntersections(ear, triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }
  function isEar(ear) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    var p2 = ear.next.next;
    while (p2 !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0) {
        return false;
      }
      p2 = p2.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev, b = ear, c = ear.next;
    if (area(a, b, c) >= 0)
      return false;
    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p2 = ear.nextZ;
    while (p2 && p2.z <= maxZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.nextZ;
    }
    p2 = ear.prevZ;
    while (p2 && p2.z >= minZ) {
      if (p2 !== ear.prev && p2 !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) && area(p2.prev, p2, p2.next) >= 0)
        return false;
      p2 = p2.prevZ;
    }
    return true;
  }
  function cureLocalIntersections(start2, triangles, dim) {
    var p2 = start2;
    do {
      var a = p2.prev, b = p2.next.next;
      if (!equals(a, b) && intersects(a, p2, p2.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p2.i / dim);
        triangles.push(b.i / dim);
        removeNode(p2);
        removeNode(p2.next);
        p2 = start2 = b;
      }
      p2 = p2.next;
    } while (p2 !== start2);
    return p2;
  }
  function splitEarcut(start2, triangles, dim, minX, minY, invSize) {
    var a = start2;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          var c = splitPolygon(a, b);
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);
          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start2);
  }
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [], i, len, start2, end2, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start2 = holeIndices[i] * dim;
      end2 = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start2, end2, dim, false);
      if (list === list.next)
        list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);
    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }
  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
      var b = splitPolygon(outerNode, hole);
      filterPoints(b, b.next);
    }
  }
  function findHoleBridge(hole, outerNode) {
    var p2 = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
    do {
      if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
        var x = p2.x + (hy - p2.y) * (p2.next.x - p2.x) / (p2.next.y - p2.y);
        if (x <= hx && x > qx) {
          qx = x;
          if (x === hx) {
            if (hy === p2.y)
              return p2;
            if (hy === p2.next.y)
              return p2.next;
          }
          m = p2.x < p2.next.x ? p2 : p2.next;
        }
      }
      p2 = p2.next;
    } while (p2 !== outerNode);
    if (!m)
      return null;
    if (hx === qx)
      return m.prev;
    var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
    p2 = m.next;
    while (p2 !== stop) {
      if (hx >= p2.x && p2.x >= mx && hx !== p2.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p2.x, p2.y)) {
        tan = Math.abs(hy - p2.y) / (hx - p2.x);
        if ((tan < tanMin || tan === tanMin && p2.x > m.x) && locallyInside(p2, hole)) {
          m = p2;
          tanMin = tan;
        }
      }
      p2 = p2.next;
    }
    return m;
  }
  function indexCurve(start2, minX, minY, invSize) {
    var p2 = start2;
    do {
      if (p2.z === null)
        p2.z = zOrder(p2.x, p2.y, minX, minY, invSize);
      p2.prevZ = p2.prev;
      p2.nextZ = p2.next;
      p2 = p2.next;
    } while (p2 !== start2);
    p2.prevZ.nextZ = null;
    p2.prevZ = null;
    sortLinked(p2);
  }
  function sortLinked(list) {
    var i, p2, q2, e, tail, numMerges, pSize, qSize, inSize = 1;
    do {
      p2 = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p2) {
        numMerges++;
        q2 = p2;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q2 = q2.nextZ;
          if (!q2)
            break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q2) {
          if (pSize !== 0 && (qSize === 0 || !q2 || p2.z <= q2.z)) {
            e = p2;
            p2 = p2.nextZ;
            pSize--;
          } else {
            e = q2;
            q2 = q2.nextZ;
            qSize--;
          }
          if (tail)
            tail.nextZ = e;
          else
            list = e;
          e.prevZ = tail;
          tail = e;
        }
        p2 = q2;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }
  function zOrder(x, y, minX, minY, invSize) {
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 16711935;
    x = (x | x << 4) & 252645135;
    x = (x | x << 2) & 858993459;
    x = (x | x << 1) & 1431655765;
    y = (y | y << 8) & 16711935;
    y = (y | y << 4) & 252645135;
    y = (y | y << 2) & 858993459;
    y = (y | y << 1) & 1431655765;
    return x | y << 1;
  }
  function getLeftmost(start2) {
    var p2 = start2, leftmost = start2;
    do {
      if (p2.x < leftmost.x)
        leftmost = p2;
      p2 = p2.next;
    } while (p2 !== start2);
    return leftmost;
  }
  function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
    return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
  }
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
  }
  function area(p2, q2, r) {
    return (q2.y - p2.y) * (r.x - q2.x) - (q2.x - p2.x) * (r.y - q2.y);
  }
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }
  function intersects(p1, q1, p2, q2) {
    if (equals(p1, q1) && equals(p2, q2) || equals(p1, q2) && equals(p2, q1))
      return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
  }
  function intersectsPolygon(a, b) {
    var p2 = a;
    do {
      if (p2.i !== a.i && p2.next.i !== a.i && p2.i !== b.i && p2.next.i !== b.i && intersects(p2, p2.next, a, b)) {
        return true;
      }
      p2 = p2.next;
    } while (p2 !== a);
    return false;
  }
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }
  function middleInside(a, b) {
    var p2 = a, inside = false, px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
    do {
      if (p2.y > py2 !== p2.next.y > py2 && p2.next.y !== p2.y && px2 < (p2.next.x - p2.x) * (py2 - p2.y) / (p2.next.y - p2.y) + p2.x) {
        inside = !inside;
      }
      p2 = p2.next;
    } while (p2 !== a);
    return inside;
  }
  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }
  function insertNode(i, x, y, last) {
    var p2 = new Node(i, x, y);
    if (!last) {
      p2.prev = p2;
      p2.next = p2;
    } else {
      p2.next = last.next;
      p2.prev = last;
      last.next.prev = p2;
      last.next = p2;
    }
    return p2;
  }
  function removeNode(p2) {
    p2.next.prev = p2.prev;
    p2.prev.next = p2.next;
    if (p2.prevZ)
      p2.prevZ.nextZ = p2.nextZ;
    if (p2.nextZ)
      p2.nextZ.prevZ = p2.prevZ;
  }
  function Node(i, x, y) {
    this.i = i;
    this.x = x;
    this.y = y;
    this.prev = null;
    this.next = null;
    this.z = null;
    this.prevZ = null;
    this.nextZ = null;
    this.steiner = false;
  }
  function signedArea(data, start2, end2, dim) {
    var sum = 0;
    for (var i = start2, j = end2 - dim; i < end2; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  var ShapeUtils = {
    area: function(contour) {
      var n = contour.length;
      var a = 0;
      for (var p2 = n - 1, q2 = 0; q2 < n; p2 = q2++) {
        a += contour[p2].x * contour[q2].y - contour[q2].x * contour[p2].y;
      }
      return a * 0.5;
    },
    isClockWise: function(pts) {
      return ShapeUtils.area(pts) < 0;
    },
    triangulateShape: function(contour, holes) {
      var vertices = [];
      var holeIndices = [];
      var faces = [];
      removeDupEndPts(contour);
      addContour(vertices, contour);
      var holeIndex = contour.length;
      holes.forEach(removeDupEndPts);
      for (var i = 0; i < holes.length; i++) {
        holeIndices.push(holeIndex);
        holeIndex += holes[i].length;
        addContour(vertices, holes[i]);
      }
      var triangles = Earcut.triangulate(vertices, holeIndices);
      for (var i = 0; i < triangles.length; i += 3) {
        faces.push(triangles.slice(i, i + 3));
      }
      return faces;
    }
  };
  function removeDupEndPts(points) {
    var l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (var i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }
  function ExtrudeGeometry(shapes, options) {
    Geometry.call(this);
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
    this.mergeVertices();
  }
  ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
  ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
  ExtrudeGeometry.prototype.toJSON = function() {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
  };
  function ExtrudeBufferGeometry(shapes, options) {
    BufferGeometry.call(this);
    this.type = "ExtrudeBufferGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    var scope = this;
    var verticesArray = [];
    var uvArray = [];
    for (var i = 0, l = shapes.length; i < l; i++) {
      var shape = shapes[i];
      addShape(shape);
    }
    this.addAttribute("position", new Float32BufferAttribute(verticesArray, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape2) {
      var placeholder = [];
      var curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      var steps = options.steps !== void 0 ? options.steps : 1;
      var depth = options.depth !== void 0 ? options.depth : 100;
      var bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      var bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;
      var bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;
      var bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      var extrudePath = options.extrudePath;
      var uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      if (options.amount !== void 0) {
        console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
        depth = options.amount;
      }
      var extrudePts, extrudeByPath = false;
      var splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector3();
        normal = new Vector3();
        position2 = new Vector3();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
      }
      var ahole, h, hl;
      var shapePoints = shape2.extractPoints(curveSegments);
      var vertices = shapePoints.shape;
      var holes = shapePoints.holes;
      var reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      var faces = ShapeUtils.triangulateShape(vertices, holes);
      var contour = vertices;
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size2) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return vec.clone().multiplyScalar(size2).add(pt);
      }
      var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        var v_trans_x, v_trans_y, shrink_by;
        var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          var v_prev_len = Math.sqrt(v_prev_lensq);
          var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          var ptNextShift_x = inNext.x - v_next_y / v_next_len;
          var ptNextShift_y = inNext.y + v_next_x / v_next_len;
          var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          var direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      var contourMovements = [];
      for (var i2 = 0, il = contour.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i2] = getBevelVec(contour[i2], contour[j], contour[k]);
      }
      var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
      for (h = 0, hl = holes.length; h < hl; h++) {
        ahole = holes[h];
        oneHoleMovements = [];
        for (i2 = 0, il = ahole.length, j = il - 1, k = i2 + 1; i2 < il; i2++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i2] = getBevelVec(ahole[i2], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (b = 0; b < bevelSegments; b++) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i2 = 0, il = contour.length; i2 < il; i2++) {
          vert = scalePt2(contour[i2], contourMovements[i2], bs);
          v(vert.x, vert.y, -z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i2 = 0, il = ahole.length; i2 < il; i2++) {
            vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs);
            v(vert.x, vert.y, -z);
          }
        }
      }
      bs = bevelSize;
      for (i2 = 0; i2 < vlen; i2++) {
        vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      var s2;
      for (s2 = 1; s2 <= steps; s2++) {
        for (i2 = 0; i2 < vlen; i2++) {
          vert = bevelEnabled ? scalePt2(vertices[i2], verticesMovements[i2], bs) : vertices[i2];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s2);
          } else {
            normal.copy(splineTube.normals[s2]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s2]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s2]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (b = bevelSegments - 1; b >= 0; b--) {
        t = b / bevelSegments;
        z = bevelThickness * Math.cos(t * Math.PI / 2);
        bs = bevelSize * Math.sin(t * Math.PI / 2);
        for (i2 = 0, il = contour.length; i2 < il; i2++) {
          vert = scalePt2(contour[i2], contourMovements[i2], bs);
          v(vert.x, vert.y, depth + z);
        }
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (i2 = 0, il = ahole.length; i2 < il; i2++) {
            vert = scalePt2(ahole[i2], oneHoleMovements[i2], bs);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        var start2 = verticesArray.length / 3;
        if (bevelEnabled) {
          var layer = 0;
          var offset = vlen * layer;
          for (i2 = 0; i2 < flen; i2++) {
            face = faces[i2];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (i2 = 0; i2 < flen; i2++) {
            face = faces[i2];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (i2 = 0; i2 < flen; i2++) {
            face = faces[i2];
            f3(face[2], face[1], face[0]);
          }
          for (i2 = 0; i2 < flen; i2++) {
            face = faces[i2];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 0);
      }
      function buildSideFaces() {
        var start2 = verticesArray.length / 3;
        var layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (h = 0, hl = holes.length; h < hl; h++) {
          ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start2, verticesArray.length / 3 - start2, 1);
      }
      function sidewalls(contour2, layeroffset) {
        var j2, k2;
        i2 = contour2.length;
        while (--i2 >= 0) {
          j2 = i2;
          k2 = i2 - 1;
          if (k2 < 0)
            k2 = contour2.length - 1;
          var s3 = 0, sl = steps + bevelSegments * 2;
          for (s3 = 0; s3 < sl; s3++) {
            var slen1 = vlen * s3;
            var slen2 = vlen * (s3 + 1);
            var a = layeroffset + j2 + slen1, b2 = layeroffset + k2 + slen1, c = layeroffset + k2 + slen2, d = layeroffset + j2 + slen2;
            f4(a, b2, c, d);
          }
        }
      }
      function v(x, y, z2) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z2);
      }
      function f3(a, b2, c) {
        addVertex(a);
        addVertex(b2);
        addVertex(c);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b2, c, d) {
        addVertex(a);
        addVertex(b2);
        addVertex(d);
        addVertex(b2);
        addVertex(c);
        addVertex(d);
        var nextIndex = verticesArray.length / 3;
        var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
  ExtrudeBufferGeometry.prototype.toJSON = function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    var options = this.parameters.options;
    return toJSON(shapes, options, data);
  };
  var WorldUVGenerator = {
    generateTopUV: function(geometry2, vertices, indexA, indexB, indexC) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      return [
        new Vector2(a_x, a_y),
        new Vector2(b_x, b_y),
        new Vector2(c_x, c_y)
      ];
    },
    generateSideWallUV: function(geometry2, vertices, indexA, indexB, indexC, indexD) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var a_z = vertices[indexA * 3 + 2];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var b_z = vertices[indexB * 3 + 2];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      var c_z = vertices[indexC * 3 + 2];
      var d_x = vertices[indexD * 3];
      var d_y = vertices[indexD * 3 + 1];
      var d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < 0.01) {
        return [
          new Vector2(a_x, 1 - a_z),
          new Vector2(b_x, 1 - b_z),
          new Vector2(c_x, 1 - c_z),
          new Vector2(d_x, 1 - d_z)
        ];
      } else {
        return [
          new Vector2(a_y, 1 - a_z),
          new Vector2(b_y, 1 - b_z),
          new Vector2(c_y, 1 - c_z),
          new Vector2(d_y, 1 - d_z)
        ];
      }
    }
  };
  function toJSON(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    if (options.extrudePath !== void 0)
      data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  function TextGeometry(text2, parameters) {
    Geometry.call(this);
    this.type = "TextGeometry";
    this.parameters = {
      text: text2,
      parameters
    };
    this.fromBufferGeometry(new TextBufferGeometry(text2, parameters));
    this.mergeVertices();
  }
  TextGeometry.prototype = Object.create(Geometry.prototype);
  TextGeometry.prototype.constructor = TextGeometry;
  function TextBufferGeometry(text2, parameters) {
    parameters = parameters || {};
    var font = parameters.font;
    if (!(font && font.isFont)) {
      console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
      return new Geometry();
    }
    var shapes = font.generateShapes(text2, parameters.size);
    parameters.depth = parameters.height !== void 0 ? parameters.height : 50;
    if (parameters.bevelThickness === void 0)
      parameters.bevelThickness = 10;
    if (parameters.bevelSize === void 0)
      parameters.bevelSize = 8;
    if (parameters.bevelEnabled === void 0)
      parameters.bevelEnabled = false;
    ExtrudeBufferGeometry.call(this, shapes, parameters);
    this.type = "TextBufferGeometry";
  }
  TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
  TextBufferGeometry.prototype.constructor = TextBufferGeometry;
  function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
    this.mergeVertices();
  }
  SphereGeometry.prototype = Object.create(Geometry.prototype);
  SphereGeometry.prototype.constructor = SphereGeometry;
  function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "SphereBufferGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    radius = radius || 1;
    widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
    heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
    phiStart = phiStart !== void 0 ? phiStart : 0;
    phiLength = phiLength !== void 0 ? phiLength : Math.PI * 2;
    thetaStart = thetaStart !== void 0 ? thetaStart : 0;
    thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI;
    var thetaEnd = thetaStart + thetaLength;
    var ix, iy;
    var index = 0;
    var grid = [];
    var vertex = new Vector3();
    var normal = new Vector3();
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    for (iy = 0; iy <= heightSegments; iy++) {
      var verticesRow = [];
      var v = iy / heightSegments;
      var uOffset = iy == 0 ? 0.5 / widthSegments : iy == heightSegments ? -0.5 / widthSegments : 0;
      for (ix = 0; ix <= widthSegments; ix++) {
        var u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (iy = 0; iy < heightSegments; iy++) {
      for (ix = 0; ix < widthSegments; ix++) {
        var a = grid[iy][ix + 1];
        var b = grid[iy][ix];
        var c = grid[iy + 1][ix];
        var d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
  function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
    this.mergeVertices();
  }
  RingGeometry.prototype = Object.create(Geometry.prototype);
  RingGeometry.prototype.constructor = RingGeometry;
  function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "RingBufferGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    innerRadius = innerRadius || 0.5;
    outerRadius = outerRadius || 1;
    thetaStart = thetaStart !== void 0 ? thetaStart : 0;
    thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
    thetaSegments = thetaSegments !== void 0 ? Math.max(3, thetaSegments) : 8;
    phiSegments = phiSegments !== void 0 ? Math.max(1, phiSegments) : 1;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var segment;
    var radius = innerRadius;
    var radiusStep = (outerRadius - innerRadius) / phiSegments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var j, i;
    for (j = 0; j <= phiSegments; j++) {
      for (i = 0; i <= thetaSegments; i++) {
        segment = thetaStart + i / thetaSegments * thetaLength;
        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, 0, 1);
        uv.x = (vertex.x / outerRadius + 1) / 2;
        uv.y = (vertex.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (j = 0; j < phiSegments; j++) {
      var thetaSegmentLevel = j * (thetaSegments + 1);
      for (i = 0; i < thetaSegments; i++) {
        segment = i + thetaSegmentLevel;
        var a = segment;
        var b = segment + thetaSegments + 1;
        var c = segment + thetaSegments + 2;
        var d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  RingBufferGeometry.prototype.constructor = RingBufferGeometry;
  function LatheGeometry(points, segments, phiStart, phiLength) {
    Geometry.call(this);
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
    this.mergeVertices();
  }
  LatheGeometry.prototype = Object.create(Geometry.prototype);
  LatheGeometry.prototype.constructor = LatheGeometry;
  function LatheBufferGeometry(points, segments, phiStart, phiLength) {
    BufferGeometry.call(this);
    this.type = "LatheBufferGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments) || 12;
    phiStart = phiStart || 0;
    phiLength = phiLength || Math.PI * 2;
    phiLength = _Math.clamp(phiLength, 0, Math.PI * 2);
    var indices = [];
    var vertices = [];
    var uvs = [];
    var base;
    var inverseSegments = 1 / segments;
    var vertex = new Vector3();
    var uv = new Vector2();
    var i, j;
    for (i = 0; i <= segments; i++) {
      var phi = phiStart + i * inverseSegments * phiLength;
      var sin = Math.sin(phi);
      var cos = Math.cos(phi);
      for (j = 0; j <= points.length - 1; j++) {
        vertex.x = points[j].x * sin;
        vertex.y = points[j].y;
        vertex.z = points[j].x * cos;
        vertices.push(vertex.x, vertex.y, vertex.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
      }
    }
    for (i = 0; i < segments; i++) {
      for (j = 0; j < points.length - 1; j++) {
        base = j + i * points.length;
        var a = base;
        var b = base + points.length;
        var c = base + points.length + 1;
        var d = base + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    this.computeVertexNormals();
    if (phiLength === Math.PI * 2) {
      var normals = this.attributes.normal.array;
      var n1 = new Vector3();
      var n2 = new Vector3();
      var n = new Vector3();
      base = segments * points.length * 3;
      for (i = 0, j = 0; i < points.length; i++, j += 3) {
        n1.x = normals[j + 0];
        n1.y = normals[j + 1];
        n1.z = normals[j + 2];
        n2.x = normals[base + j + 0];
        n2.y = normals[base + j + 1];
        n2.z = normals[base + j + 2];
        n.addVectors(n1, n2).normalize();
        normals[j + 0] = normals[base + j + 0] = n.x;
        normals[j + 1] = normals[base + j + 1] = n.y;
        normals[j + 2] = normals[base + j + 2] = n.z;
      }
    }
  }
  LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
  function ShapeGeometry(shapes, curveSegments) {
    Geometry.call(this);
    this.type = "ShapeGeometry";
    if (typeof curveSegments === "object") {
      console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
      curveSegments = curveSegments.curveSegments;
    }
    this.parameters = {
      shapes,
      curveSegments
    };
    this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
    this.mergeVertices();
  }
  ShapeGeometry.prototype = Object.create(Geometry.prototype);
  ShapeGeometry.prototype.constructor = ShapeGeometry;
  ShapeGeometry.prototype.toJSON = function() {
    var data = Geometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  };
  function ShapeBufferGeometry(shapes, curveSegments) {
    BufferGeometry.call(this);
    this.type = "ShapeBufferGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    curveSegments = curveSegments || 12;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var groupStart = 0;
    var groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (var i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function addShape(shape) {
      var i2, l, shapeHole;
      var indexOffset = vertices.length / 3;
      var points = shape.extractPoints(curveSegments);
      var shapeVertices = points.shape;
      var shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
        shapeHole = shapeHoles[i2];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i2] = shapeHole.reverse();
        }
      }
      var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (i2 = 0, l = shapeHoles.length; i2 < l; i2++) {
        shapeHole = shapeHoles[i2];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (i2 = 0, l = shapeVertices.length; i2 < l; i2++) {
        var vertex = shapeVertices[i2];
        vertices.push(vertex.x, vertex.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex.x, vertex.y);
      }
      for (i2 = 0, l = faces.length; i2 < l; i2++) {
        var face = faces[i2];
        var a = face[0] + indexOffset;
        var b = face[1] + indexOffset;
        var c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
  ShapeBufferGeometry.prototype.toJSON = function() {
    var data = BufferGeometry.prototype.toJSON.call(this);
    var shapes = this.parameters.shapes;
    return toJSON$1(shapes, data);
  };
  function toJSON$1(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  function EdgesGeometry(geometry2, thresholdAngle) {
    BufferGeometry.call(this);
    this.type = "EdgesGeometry";
    this.parameters = {
      thresholdAngle
    };
    thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;
    var vertices = [];
    var thresholdDot = Math.cos(_Math.DEG2RAD * thresholdAngle);
    var edge = [0, 0], edges = {}, edge1, edge2;
    var key, keys = ["a", "b", "c"];
    var geometry22;
    if (geometry2.isBufferGeometry) {
      geometry22 = new Geometry();
      geometry22.fromBufferGeometry(geometry2);
    } else {
      geometry22 = geometry2.clone();
    }
    geometry22.mergeVertices();
    geometry22.computeFaceNormals();
    var sourceVertices = geometry22.vertices;
    var faces = geometry22.faces;
    for (var i = 0, l = faces.length; i < l; i++) {
      var face = faces[i];
      for (var j = 0; j < 3; j++) {
        edge1 = face[keys[j]];
        edge2 = face[keys[(j + 1) % 3]];
        edge[0] = Math.min(edge1, edge2);
        edge[1] = Math.max(edge1, edge2);
        key = edge[0] + "," + edge[1];
        if (edges[key] === void 0) {
          edges[key] = { index1: edge[0], index2: edge[1], face1: i, face2: void 0 };
        } else {
          edges[key].face2 = i;
        }
      }
    }
    for (key in edges) {
      var e = edges[key];
      if (e.face2 === void 0 || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
        var vertex = sourceVertices[e.index1];
        vertices.push(vertex.x, vertex.y, vertex.z);
        vertex = sourceVertices[e.index2];
        vertices.push(vertex.x, vertex.y, vertex.z);
      }
    }
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
  }
  EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
  EdgesGeometry.prototype.constructor = EdgesGeometry;
  function CylinderGeometry(radiusTop, radiusBottom, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
    this.mergeVertices();
  }
  CylinderGeometry.prototype = Object.create(Geometry.prototype);
  CylinderGeometry.prototype.constructor = CylinderGeometry;
  function CylinderBufferGeometry(radiusTop, radiusBottom, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "CylinderBufferGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    var scope = this;
    radiusTop = radiusTop !== void 0 ? radiusTop : 1;
    radiusBottom = radiusBottom !== void 0 ? radiusBottom : 1;
    height2 = height2 || 1;
    radialSegments = Math.floor(radialSegments) || 8;
    heightSegments = Math.floor(heightSegments) || 1;
    openEnded = openEnded !== void 0 ? openEnded : false;
    thetaStart = thetaStart !== void 0 ? thetaStart : 0;
    thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var index = 0;
    var indexArray = [];
    var halfHeight = height2 / 2;
    var groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function generateTorso() {
      var x, y;
      var normal = new Vector3();
      var vertex = new Vector3();
      var groupCount = 0;
      var slope = (radiusBottom - radiusTop) / height2;
      for (y = 0; y <= heightSegments; y++) {
        var indexRow = [];
        var v = y / heightSegments;
        var radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (x = 0; x <= radialSegments; x++) {
          var u = x / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var sinTheta = Math.sin(theta);
          var cosTheta = Math.cos(theta);
          vertex.x = radius * sinTheta;
          vertex.y = -v * height2 + halfHeight;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (x = 0; x < radialSegments; x++) {
        for (y = 0; y < heightSegments; y++) {
          var a = indexArray[y][x];
          var b = indexArray[y + 1][x];
          var c = indexArray[y + 1][x + 1];
          var d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      var x, centerIndexStart, centerIndexEnd;
      var uv = new Vector2();
      var vertex = new Vector3();
      var groupCount = 0;
      var radius = top === true ? radiusTop : radiusBottom;
      var sign = top === true ? 1 : -1;
      centerIndexStart = index;
      for (x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign, 0);
        normals.push(0, sign, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      centerIndexEnd = index;
      for (x = 0; x <= radialSegments; x++) {
        var u = x / radialSegments;
        var theta = u * thetaLength + thetaStart;
        var cosTheta = Math.cos(theta);
        var sinTheta = Math.sin(theta);
        vertex.x = radius * sinTheta;
        vertex.y = halfHeight * sign;
        vertex.z = radius * cosTheta;
        vertices.push(vertex.x, vertex.y, vertex.z);
        normals.push(0, sign, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (x = 0; x < radialSegments; x++) {
        var c = centerIndexStart + x;
        var i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
  function ConeGeometry(radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderGeometry.call(this, 0, radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
  ConeGeometry.prototype.constructor = ConeGeometry;
  function ConeBufferGeometry(radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
    CylinderBufferGeometry.call(this, 0, radius, height2, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeBufferGeometry";
    this.parameters = {
      radius,
      height: height2,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
  ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
  function CircleGeometry(radius, segments, thetaStart, thetaLength) {
    Geometry.call(this);
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
    this.mergeVertices();
  }
  CircleGeometry.prototype = Object.create(Geometry.prototype);
  CircleGeometry.prototype.constructor = CircleGeometry;
  function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
    BufferGeometry.call(this);
    this.type = "CircleBufferGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    radius = radius || 1;
    segments = segments !== void 0 ? Math.max(3, segments) : 8;
    thetaStart = thetaStart !== void 0 ? thetaStart : 0;
    thetaLength = thetaLength !== void 0 ? thetaLength : Math.PI * 2;
    var indices = [];
    var vertices = [];
    var normals = [];
    var uvs = [];
    var i, s2;
    var vertex = new Vector3();
    var uv = new Vector2();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (s2 = 0, i = 3; s2 <= segments; s2++, i += 3) {
      var segment = thetaStart + s2 / segments * thetaLength;
      vertex.x = radius * Math.cos(segment);
      vertex.y = radius * Math.sin(segment);
      vertices.push(vertex.x, vertex.y, vertex.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.addAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.addAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
  CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
  var Geometries = /* @__PURE__ */ Object.freeze({
    WireframeGeometry,
    ParametricGeometry,
    ParametricBufferGeometry,
    TetrahedronGeometry,
    TetrahedronBufferGeometry,
    OctahedronGeometry,
    OctahedronBufferGeometry,
    IcosahedronGeometry,
    IcosahedronBufferGeometry,
    DodecahedronGeometry,
    DodecahedronBufferGeometry,
    PolyhedronGeometry,
    PolyhedronBufferGeometry,
    TubeGeometry,
    TubeBufferGeometry,
    TorusKnotGeometry,
    TorusKnotBufferGeometry,
    TorusGeometry,
    TorusBufferGeometry,
    TextGeometry,
    TextBufferGeometry,
    SphereGeometry,
    SphereBufferGeometry,
    RingGeometry,
    RingBufferGeometry,
    PlaneGeometry,
    PlaneBufferGeometry,
    LatheGeometry,
    LatheBufferGeometry,
    ShapeGeometry,
    ShapeBufferGeometry,
    ExtrudeGeometry,
    ExtrudeBufferGeometry,
    EdgesGeometry,
    ConeGeometry,
    ConeBufferGeometry,
    CylinderGeometry,
    CylinderBufferGeometry,
    CircleGeometry,
    CircleBufferGeometry,
    BoxGeometry,
    BoxBufferGeometry
  });
  function ShadowMaterial(parameters) {
    Material.call(this);
    this.type = "ShadowMaterial";
    this.color = new Color(0);
    this.transparent = true;
    this.setValues(parameters);
  }
  ShadowMaterial.prototype = Object.create(Material.prototype);
  ShadowMaterial.prototype.constructor = ShadowMaterial;
  ShadowMaterial.prototype.isShadowMaterial = true;
  ShadowMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    return this;
  };
  function RawShaderMaterial(parameters) {
    ShaderMaterial.call(this, parameters);
    this.type = "RawShaderMaterial";
  }
  RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
  RawShaderMaterial.prototype.constructor = RawShaderMaterial;
  RawShaderMaterial.prototype.isRawShaderMaterial = true;
  function MeshStandardMaterial(parameters) {
    Material.call(this);
    this.defines = { "STANDARD": "" };
    this.type = "MeshStandardMaterial";
    this.color = new Color(16777215);
    this.roughness = 0.5;
    this.metalness = 0.5;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapIntensity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshStandardMaterial.prototype = Object.create(Material.prototype);
  MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
  MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
  MeshStandardMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapIntensity = source.envMapIntensity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshPhysicalMaterial(parameters) {
    MeshStandardMaterial.call(this);
    this.defines = { "PHYSICAL": "" };
    this.type = "MeshPhysicalMaterial";
    this.reflectivity = 0.5;
    this.clearCoat = 0;
    this.clearCoatRoughness = 0;
    this.setValues(parameters);
  }
  MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
  MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
  MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
  MeshPhysicalMaterial.prototype.copy = function(source) {
    MeshStandardMaterial.prototype.copy.call(this, source);
    this.defines = { "PHYSICAL": "" };
    this.reflectivity = source.reflectivity;
    this.clearCoat = source.clearCoat;
    this.clearCoatRoughness = source.clearCoatRoughness;
    return this;
  };
  function MeshPhongMaterial(parameters) {
    Material.call(this);
    this.type = "MeshPhongMaterial";
    this.color = new Color(16777215);
    this.specular = new Color(1118481);
    this.shininess = 30;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshPhongMaterial.prototype = Object.create(Material.prototype);
  MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
  MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
  MeshPhongMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.specular.copy(source.specular);
    this.shininess = source.shininess;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshToonMaterial(parameters) {
    MeshPhongMaterial.call(this);
    this.defines = { "TOON": "" };
    this.type = "MeshToonMaterial";
    this.gradientMap = null;
    this.setValues(parameters);
  }
  MeshToonMaterial.prototype = Object.create(MeshPhongMaterial.prototype);
  MeshToonMaterial.prototype.constructor = MeshToonMaterial;
  MeshToonMaterial.prototype.isMeshToonMaterial = true;
  MeshToonMaterial.prototype.copy = function(source) {
    MeshPhongMaterial.prototype.copy.call(this, source);
    this.gradientMap = source.gradientMap;
    return this;
  };
  function MeshNormalMaterial(parameters) {
    Material.call(this);
    this.type = "MeshNormalMaterial";
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshNormalMaterial.prototype = Object.create(Material.prototype);
  MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
  MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
  MeshNormalMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshLambertMaterial(parameters) {
    Material.call(this);
    this.type = "MeshLambertMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.setValues(parameters);
  }
  MeshLambertMaterial.prototype = Object.create(Material.prototype);
  MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
  MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
  MeshLambertMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function MeshMatcapMaterial(parameters) {
    Material.call(this);
    this.defines = { "MATCAP": "" };
    this.type = "MeshMatcapMaterial";
    this.color = new Color(16777215);
    this.matcap = null;
    this.map = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.alphaMap = null;
    this.skinning = false;
    this.morphTargets = false;
    this.morphNormals = false;
    this.lights = false;
    this.setValues(parameters);
  }
  MeshMatcapMaterial.prototype = Object.create(Material.prototype);
  MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
  MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
  MeshMatcapMaterial.prototype.copy = function(source) {
    Material.prototype.copy.call(this, source);
    this.defines = { "MATCAP": "" };
    this.color.copy(source.color);
    this.matcap = source.matcap;
    this.map = source.map;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.alphaMap = source.alphaMap;
    this.skinning = source.skinning;
    this.morphTargets = source.morphTargets;
    this.morphNormals = source.morphNormals;
    return this;
  };
  function LineDashedMaterial(parameters) {
    LineBasicMaterial.call(this);
    this.type = "LineDashedMaterial";
    this.scale = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.setValues(parameters);
  }
  LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
  LineDashedMaterial.prototype.constructor = LineDashedMaterial;
  LineDashedMaterial.prototype.isLineDashedMaterial = true;
  LineDashedMaterial.prototype.copy = function(source) {
    LineBasicMaterial.prototype.copy.call(this, source);
    this.scale = source.scale;
    this.dashSize = source.dashSize;
    this.gapSize = source.gapSize;
    return this;
  };
  var Materials = /* @__PURE__ */ Object.freeze({
    ShadowMaterial,
    SpriteMaterial,
    RawShaderMaterial,
    ShaderMaterial,
    PointsMaterial,
    MeshPhysicalMaterial,
    MeshStandardMaterial,
    MeshPhongMaterial,
    MeshToonMaterial,
    MeshNormalMaterial,
    MeshLambertMaterial,
    MeshDepthMaterial,
    MeshDistanceMaterial,
    MeshBasicMaterial,
    MeshMatcapMaterial,
    LineDashedMaterial,
    LineBasicMaterial,
    Material
  });
  var AnimationUtils = {
    arraySlice: function(array, from, to) {
      if (AnimationUtils.isTypedArray(array)) {
        return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));
      }
      return array.slice(from, to);
    },
    convertArray: function(array, type, forceClone) {
      if (!array || !forceClone && array.constructor === type)
        return array;
      if (typeof type.BYTES_PER_ELEMENT === "number") {
        return new type(array);
      }
      return Array.prototype.slice.call(array);
    },
    isTypedArray: function(object) {
      return ArrayBuffer.isView(object) && !(object instanceof DataView);
    },
    getKeyframeOrder: function(times) {
      function compareTime(i2, j) {
        return times[i2] - times[j];
      }
      var n = times.length;
      var result = new Array(n);
      for (var i = 0; i !== n; ++i)
        result[i] = i;
      result.sort(compareTime);
      return result;
    },
    sortedArray: function(values, stride, order) {
      var nValues = values.length;
      var result = new values.constructor(nValues);
      for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
        var srcOffset = order[i] * stride;
        for (var j = 0; j !== stride; ++j) {
          result[dstOffset++] = values[srcOffset + j];
        }
      }
      return result;
    },
    flattenJSON: function(jsonKeys, times, values, valuePropertyName) {
      var i = 1, key = jsonKeys[0];
      while (key !== void 0 && key[valuePropertyName] === void 0) {
        key = jsonKeys[i++];
      }
      if (key === void 0)
        return;
      var value = key[valuePropertyName];
      if (value === void 0)
        return;
      if (Array.isArray(value)) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push.apply(values, value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else if (value.toArray !== void 0) {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            value.toArray(values, values.length);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      } else {
        do {
          value = key[valuePropertyName];
          if (value !== void 0) {
            times.push(key.time);
            values.push(value);
          }
          key = jsonKeys[i++];
        } while (key !== void 0);
      }
    }
  };
  function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
  }
  Object.assign(Interpolant.prototype, {
    evaluate: function(t) {
      var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
      validate_interval: {
        seek: {
          var right;
          linear_scan: {
            forward_scan:
              if (!(t < t1)) {
                for (var giveUpAt = i1 + 2; ; ) {
                  if (t1 === void 0) {
                    if (t < t0)
                      break forward_scan;
                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_(i1 - 1, t, t0);
                  }
                  if (i1 === giveUpAt)
                    break;
                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    break seek;
                  }
                }
                right = pp.length;
                break linear_scan;
              }
            if (!(t >= t0)) {
              var t1global = pp[1];
              if (t < t1global) {
                i1 = 2;
                t0 = t1global;
              }
              for (var giveUpAt = i1 - 2; ; ) {
                if (t0 === void 0) {
                  this._cachedIndex = 0;
                  return this.beforeStart_(0, t, t1);
                }
                if (i1 === giveUpAt)
                  break;
                t1 = t0;
                t0 = pp[--i1 - 1];
                if (t >= t0) {
                  break seek;
                }
              }
              right = i1;
              i1 = 0;
              break linear_scan;
            }
            break validate_interval;
          }
          while (i1 < right) {
            var mid = i1 + right >>> 1;
            if (t < pp[mid]) {
              right = mid;
            } else {
              i1 = mid + 1;
            }
          }
          t1 = pp[i1];
          t0 = pp[i1 - 1];
          if (t0 === void 0) {
            this._cachedIndex = 0;
            return this.beforeStart_(0, t, t1);
          }
          if (t1 === void 0) {
            i1 = pp.length;
            this._cachedIndex = i1;
            return this.afterEnd_(i1 - 1, t0, t);
          }
        }
        this._cachedIndex = i1;
        this.intervalChanged_(i1, t0, t1);
      }
      return this.interpolate_(i1, t0, t, t1);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function(index) {
      var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset + i];
      }
      return result;
    },
    interpolate_: function() {
      throw new Error("call to abstract method");
    },
    intervalChanged_: function() {
    }
  });
  Object.assign(Interpolant.prototype, {
    beforeStart_: Interpolant.prototype.copySampleValue_,
    afterEnd_: Interpolant.prototype.copySampleValue_
  });
  function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
  }
  CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: CubicInterpolant,
    DefaultSettings_: {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    },
    intervalChanged_: function(i1, t0, t1) {
      var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
      if (tPrev === void 0) {
        switch (this.getSettings_().endingStart) {
          case ZeroSlopeEnding:
            iPrev = i1;
            tPrev = 2 * t0 - t1;
            break;
          case WrapAroundEnding:
            iPrev = pp.length - 2;
            tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
            break;
          default:
            iPrev = i1;
            tPrev = t1;
        }
      }
      if (tNext === void 0) {
        switch (this.getSettings_().endingEnd) {
          case ZeroSlopeEnding:
            iNext = i1;
            tNext = 2 * t1 - t0;
            break;
          case WrapAroundEnding:
            iNext = 1;
            tNext = t1 + pp[1] - pp[0];
            break;
          default:
            iNext = i1 - 1;
            tNext = t0;
        }
      }
      var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
      this._weightPrev = halfDt / (t0 - tPrev);
      this._weightNext = halfDt / (tNext - t1);
      this._offsetPrev = iPrev * stride;
      this._offsetNext = iNext * stride;
    },
    interpolate_: function(i1, t0, t, t1) {
      var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
      var sP = -wP * ppp + 2 * wP * pp - wP * p2;
      var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
      var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
      var sN = wN * ppp - wN * pp;
      for (var i = 0; i !== stride; ++i) {
        result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
      }
      return result;
    }
  });
  function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: LinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
      for (var i = 0; i !== stride; ++i) {
        result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
      }
      return result;
    }
  });
  function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: DiscreteInterpolant,
    interpolate_: function(i1) {
      return this.copySampleValue_(i1 - 1);
    }
  });
  function KeyframeTrack(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  Object.assign(KeyframeTrack, {
    toJSON: function(track) {
      var trackType = track.constructor;
      var json;
      if (trackType.toJSON !== void 0) {
        json = trackType.toJSON(track);
      } else {
        json = {
          "name": track.name,
          "times": AnimationUtils.convertArray(track.times, Array),
          "values": AnimationUtils.convertArray(track.values, Array)
        };
        var interpolation = track.getInterpolation();
        if (interpolation !== track.DefaultInterpolation) {
          json.interpolation = interpolation;
        }
      }
      json.type = track.ValueTypeName;
      return json;
    }
  });
  Object.assign(KeyframeTrack.prototype, {
    constructor: KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(result) {
      return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodLinear: function(result) {
      return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: function(result) {
      return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    setInterpolation: function(interpolation) {
      var factoryMethod;
      switch (interpolation) {
        case InterpolateDiscrete:
          factoryMethod = this.InterpolantFactoryMethodDiscrete;
          break;
        case InterpolateLinear:
          factoryMethod = this.InterpolantFactoryMethodLinear;
          break;
        case InterpolateSmooth:
          factoryMethod = this.InterpolantFactoryMethodSmooth;
          break;
      }
      if (factoryMethod === void 0) {
        var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
        if (this.createInterpolant === void 0) {
          if (interpolation !== this.DefaultInterpolation) {
            this.setInterpolation(this.DefaultInterpolation);
          } else {
            throw new Error(message);
          }
        }
        console.warn("THREE.KeyframeTrack:", message);
        return this;
      }
      this.createInterpolant = factoryMethod;
      return this;
    },
    getInterpolation: function() {
      switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
          return InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
          return InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
          return InterpolateSmooth;
      }
    },
    getValueSize: function() {
      return this.values.length / this.times.length;
    },
    shift: function(timeOffset) {
      if (timeOffset !== 0) {
        var times = this.times;
        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] += timeOffset;
        }
      }
      return this;
    },
    scale: function(timeScale) {
      if (timeScale !== 1) {
        var times = this.times;
        for (var i = 0, n = times.length; i !== n; ++i) {
          times[i] *= timeScale;
        }
      }
      return this;
    },
    trim: function(startTime, endTime) {
      var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
      while (from !== nKeys && times[from] < startTime) {
        ++from;
      }
      while (to !== -1 && times[to] > endTime) {
        --to;
      }
      ++to;
      if (from !== 0 || to !== nKeys) {
        if (from >= to)
          to = Math.max(to, 1), from = to - 1;
        var stride = this.getValueSize();
        this.times = AnimationUtils.arraySlice(times, from, to);
        this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
      }
      return this;
    },
    validate: function() {
      var valid = true;
      var valueSize = this.getValueSize();
      if (valueSize - Math.floor(valueSize) !== 0) {
        console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
        valid = false;
      }
      var times = this.times, values = this.values, nKeys = times.length;
      if (nKeys === 0) {
        console.error("THREE.KeyframeTrack: Track is empty.", this);
        valid = false;
      }
      var prevTime = null;
      for (var i = 0; i !== nKeys; i++) {
        var currTime = times[i];
        if (typeof currTime === "number" && isNaN(currTime)) {
          console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
          valid = false;
          break;
        }
        if (prevTime !== null && prevTime > currTime) {
          console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
          valid = false;
          break;
        }
        prevTime = currTime;
      }
      if (values !== void 0) {
        if (AnimationUtils.isTypedArray(values)) {
          for (var i = 0, n = values.length; i !== n; ++i) {
            var value = values[i];
            if (isNaN(value)) {
              console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
              valid = false;
              break;
            }
          }
        }
      }
      return valid;
    },
    optimize: function() {
      var times = this.times, values = this.values, stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
      for (var i = 1; i < lastIndex; ++i) {
        var keep = false;
        var time2 = times[i];
        var timeNext = times[i + 1];
        if (time2 !== timeNext && (i !== 1 || time2 !== time2[0])) {
          if (!smoothInterpolation) {
            var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
            for (var j = 0; j !== stride; ++j) {
              var value = values[offset + j];
              if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                keep = true;
                break;
              }
            }
          } else {
            keep = true;
          }
        }
        if (keep) {
          if (i !== writeIndex) {
            times[writeIndex] = times[i];
            var readOffset = i * stride, writeOffset = writeIndex * stride;
            for (var j = 0; j !== stride; ++j) {
              values[writeOffset + j] = values[readOffset + j];
            }
          }
          ++writeIndex;
        }
      }
      if (lastIndex > 0) {
        times[writeIndex] = times[lastIndex];
        for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
          values[writeOffset + j] = values[readOffset + j];
        }
        ++writeIndex;
      }
      if (writeIndex !== times.length) {
        this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
        this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
      }
      return this;
    },
    clone: function() {
      var times = AnimationUtils.arraySlice(this.times, 0);
      var values = AnimationUtils.arraySlice(this.values, 0);
      var TypedKeyframeTrack = this.constructor;
      var track = new TypedKeyframeTrack(this.name, times, values);
      track.createInterpolant = this.createInterpolant;
      return track;
    }
  });
  function BooleanKeyframeTrack(name, times, values) {
    KeyframeTrack.call(this, name, times, values);
  }
  BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  function ColorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: ColorKeyframeTrack,
    ValueTypeName: "color"
  });
  function NumberKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: NumberKeyframeTrack,
    ValueTypeName: "number"
  });
  function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
    constructor: QuaternionLinearInterpolant,
    interpolate_: function(i1, t0, t, t1) {
      var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
      for (var end2 = offset + stride; offset !== end2; offset += 4) {
        Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
      }
      return result;
    }
  });
  function QuaternionKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: InterpolateLinear,
    InterpolantFactoryMethodLinear: function(result) {
      return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
    },
    InterpolantFactoryMethodSmooth: void 0
  });
  function StringKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: InterpolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
  });
  function VectorKeyframeTrack(name, times, values, interpolation) {
    KeyframeTrack.call(this, name, times, values, interpolation);
  }
  VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
    constructor: VectorKeyframeTrack,
    ValueTypeName: "vector"
  });
  function AnimationClip(name, duration, tracks) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration !== void 0 ? duration : -1;
    this.uuid = _Math.generateUUID();
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return NumberKeyframeTrack;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return VectorKeyframeTrack;
      case "color":
        return ColorKeyframeTrack;
      case "quaternion":
        return QuaternionKeyframeTrack;
      case "bool":
      case "boolean":
        return BooleanKeyframeTrack;
      case "string":
        return StringKeyframeTrack;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === void 0) {
      throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    }
    var trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === void 0) {
      var times = [], values = [];
      AnimationUtils.flattenJSON(json.keys, times, values, "value");
      json.times = times;
      json.values = values;
    }
    if (trackType.parse !== void 0) {
      return trackType.parse(json);
    } else {
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  Object.assign(AnimationClip, {
    parse: function(json) {
      var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
      for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
        tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
      }
      return new AnimationClip(json.name, json.duration, tracks);
    },
    toJSON: function(clip) {
      var tracks = [], clipTracks = clip.tracks;
      var json = {
        "name": clip.name,
        "duration": clip.duration,
        "tracks": tracks,
        "uuid": clip.uuid
      };
      for (var i = 0, n = clipTracks.length; i !== n; ++i) {
        tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
      }
      return json;
    },
    CreateFromMorphTargetSequence: function(name, morphTargetSequence, fps, noLoop) {
      var numMorphTargets = morphTargetSequence.length;
      var tracks = [];
      for (var i = 0; i < numMorphTargets; i++) {
        var times = [];
        var values = [];
        times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
        values.push(0, 1, 0);
        var order = AnimationUtils.getKeyframeOrder(times);
        times = AnimationUtils.sortedArray(times, 1, order);
        values = AnimationUtils.sortedArray(values, 1, order);
        if (!noLoop && times[0] === 0) {
          times.push(numMorphTargets);
          values.push(values[0]);
        }
        tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
      }
      return new AnimationClip(name, -1, tracks);
    },
    findByName: function(objectOrClipArray, name) {
      var clipArray = objectOrClipArray;
      if (!Array.isArray(objectOrClipArray)) {
        var o = objectOrClipArray;
        clipArray = o.geometry && o.geometry.animations || o.animations;
      }
      for (var i = 0; i < clipArray.length; i++) {
        if (clipArray[i].name === name) {
          return clipArray[i];
        }
      }
      return null;
    },
    CreateClipsFromMorphTargetSequences: function(morphTargets, fps, noLoop) {
      var animationToMorphTargets = {};
      var pattern = /^([\w-]*?)([\d]+)$/;
      for (var i = 0, il = morphTargets.length; i < il; i++) {
        var morphTarget = morphTargets[i];
        var parts = morphTarget.name.match(pattern);
        if (parts && parts.length > 1) {
          var name = parts[1];
          var animationMorphTargets = animationToMorphTargets[name];
          if (!animationMorphTargets) {
            animationToMorphTargets[name] = animationMorphTargets = [];
          }
          animationMorphTargets.push(morphTarget);
        }
      }
      var clips = [];
      for (var name in animationToMorphTargets) {
        clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
      }
      return clips;
    },
    parseAnimation: function(animation, bones2) {
      if (!animation) {
        console.error("THREE.AnimationClip: No animation in JSONLoader data.");
        return null;
      }
      var addNonemptyTrack = function(trackType, trackName, animationKeys2, propertyName, destTracks) {
        if (animationKeys2.length !== 0) {
          var times2 = [];
          var values2 = [];
          AnimationUtils.flattenJSON(animationKeys2, times2, values2, propertyName);
          if (times2.length !== 0) {
            destTracks.push(new trackType(trackName, times2, values2));
          }
        }
      };
      var tracks = [];
      var clipName = animation.name || "default";
      var duration = animation.length || -1;
      var fps = animation.fps || 30;
      var hierarchyTracks = animation.hierarchy || [];
      for (var h = 0; h < hierarchyTracks.length; h++) {
        var animationKeys = hierarchyTracks[h].keys;
        if (!animationKeys || animationKeys.length === 0)
          continue;
        if (animationKeys[0].morphTargets) {
          var morphTargetNames = {};
          for (var k = 0; k < animationKeys.length; k++) {
            if (animationKeys[k].morphTargets) {
              for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
              }
            }
          }
          for (var morphTargetName in morphTargetNames) {
            var times = [];
            var values = [];
            for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
              var animationKey = animationKeys[k];
              times.push(animationKey.time);
              values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
            }
            tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
          }
          duration = morphTargetNames.length * (fps || 1);
        } else {
          var boneName = ".bones[" + bones2[h].name + "]";
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
          addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
          addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
        }
      }
      if (tracks.length === 0) {
        return null;
      }
      var clip = new AnimationClip(clipName, duration, tracks);
      return clip;
    }
  });
  Object.assign(AnimationClip.prototype, {
    resetDuration: function() {
      var tracks = this.tracks, duration = 0;
      for (var i = 0, n = tracks.length; i !== n; ++i) {
        var track = this.tracks[i];
        duration = Math.max(duration, track.times[track.times.length - 1]);
      }
      this.duration = duration;
      return this;
    },
    trim: function() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].trim(0, this.duration);
      }
      return this;
    },
    validate: function() {
      var valid = true;
      for (var i = 0; i < this.tracks.length; i++) {
        valid = valid && this.tracks[i].validate();
      }
      return valid;
    },
    optimize: function() {
      for (var i = 0; i < this.tracks.length; i++) {
        this.tracks[i].optimize();
      }
      return this;
    },
    clone: function() {
      var tracks = [];
      for (var i = 0; i < this.tracks.length; i++) {
        tracks.push(this.tracks[i].clone());
      }
      return new AnimationClip(this.name, this.duration, tracks);
    }
  });
  var Cache = {
    enabled: false,
    files: {},
    add: function(key, file) {
      if (this.enabled === false)
        return;
      this.files[key] = file;
    },
    get: function(key) {
      if (this.enabled === false)
        return;
      return this.files[key];
    },
    remove: function(key) {
      delete this.files[key];
    },
    clear: function() {
      this.files = {};
    }
  };
  function LoadingManager(onLoad, onProgress, onError) {
    var scope = this;
    var isLoading = false;
    var itemsLoaded = 0;
    var itemsTotal = 0;
    var urlModifier = void 0;
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
  }
  var DefaultLoadingManager = new LoadingManager();
  var loading2 = {};
  function FileLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(FileLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      if (loading2[url] !== void 0) {
        loading2[url].push({
          onLoad,
          onProgress,
          onError
        });
        return;
      }
      var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
      var dataUriRegexResult = url.match(dataUriRegex);
      if (dataUriRegexResult) {
        var mimeType = dataUriRegexResult[1];
        var isBase64 = !!dataUriRegexResult[2];
        var data = dataUriRegexResult[3];
        data = decodeURIComponent(data);
        if (isBase64)
          data = atob(data);
        try {
          var response;
          var responseType = (this.responseType || "").toLowerCase();
          switch (responseType) {
            case "arraybuffer":
            case "blob":
              var view = new Uint8Array(data.length);
              for (var i = 0; i < data.length; i++) {
                view[i] = data.charCodeAt(i);
              }
              if (responseType === "blob") {
                response = new Blob([view.buffer], { type: mimeType });
              } else {
                response = view.buffer;
              }
              break;
            case "document":
              var parser = new DOMParser();
              response = parser.parseFromString(data, mimeType);
              break;
            case "json":
              response = JSON.parse(data);
              break;
            default:
              response = data;
              break;
          }
          setTimeout(function() {
            if (onLoad)
              onLoad(response);
            scope.manager.itemEnd(url);
          }, 0);
        } catch (error) {
          setTimeout(function() {
            if (onError)
              onError(error);
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }, 0);
        }
      } else {
        loading2[url] = [];
        loading2[url].push({
          onLoad,
          onProgress,
          onError
        });
        var request = new XMLHttpRequest();
        request.open("GET", url, true);
        request.addEventListener("load", function(event) {
          var response2 = this.response;
          Cache.add(url, response2);
          var callbacks = loading2[url];
          delete loading2[url];
          if (this.status === 200 || this.status === 0) {
            if (this.status === 0)
              console.warn("THREE.FileLoader: HTTP Status 0 received.");
            for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
              var callback = callbacks[i2];
              if (callback.onLoad)
                callback.onLoad(response2);
            }
            scope.manager.itemEnd(url);
          } else {
            for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
              var callback = callbacks[i2];
              if (callback.onError)
                callback.onError(event);
            }
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          }
        }, false);
        request.addEventListener("progress", function(event) {
          var callbacks = loading2[url];
          for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
            var callback = callbacks[i2];
            if (callback.onProgress)
              callback.onProgress(event);
          }
        }, false);
        request.addEventListener("error", function(event) {
          var callbacks = loading2[url];
          delete loading2[url];
          for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
            var callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        request.addEventListener("abort", function(event) {
          var callbacks = loading2[url];
          delete loading2[url];
          for (var i2 = 0, il = callbacks.length; i2 < il; i2++) {
            var callback = callbacks[i2];
            if (callback.onError)
              callback.onError(event);
          }
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }, false);
        if (this.responseType !== void 0)
          request.responseType = this.responseType;
        if (this.withCredentials !== void 0)
          request.withCredentials = this.withCredentials;
        if (request.overrideMimeType)
          request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : "text/plain");
        for (var header in this.requestHeader) {
          request.setRequestHeader(header, this.requestHeader[header]);
        }
        request.send(null);
      }
      scope.manager.itemStart(url);
      return request;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    },
    setResponseType: function(value) {
      this.responseType = value;
      return this;
    },
    setWithCredentials: function(value) {
      this.withCredentials = value;
      return this;
    },
    setMimeType: function(value) {
      this.mimeType = value;
      return this;
    },
    setRequestHeader: function(value) {
      this.requestHeader = value;
      return this;
    }
  });
  function AnimationLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(AnimationLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function(text2) {
        onLoad(scope.parse(JSON.parse(text2)));
      }, onProgress, onError);
    },
    parse: function(json) {
      var animations = [];
      for (var i = 0; i < json.length; i++) {
        var clip = AnimationClip.parse(json[i]);
        animations.push(clip);
      }
      return animations;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function CompressedTextureLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this._parser = null;
  }
  Object.assign(CompressedTextureLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var images = [];
      var texture = new CompressedTexture();
      texture.image = images;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setResponseType("arraybuffer");
      function loadTexture(i2) {
        loader.load(url[i2], function(buffer) {
          var texDatas = scope._parser(buffer, true);
          images[i2] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps
          };
          loaded += 1;
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1)
              texture.minFilter = LinearFilter;
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, onProgress, onError);
      }
      if (Array.isArray(url)) {
        var loaded = 0;
        for (var i = 0, il = url.length; i < il; ++i) {
          loadTexture(i);
        }
      } else {
        loader.load(url, function(buffer) {
          var texDatas = scope._parser(buffer, true);
          if (texDatas.isCubemap) {
            var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
            for (var f = 0; f < faces; f++) {
              images[f] = { mipmaps: [] };
              for (var i2 = 0; i2 < texDatas.mipmapCount; i2++) {
                images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i2]);
                images[f].format = texDatas.format;
                images[f].width = texDatas.width;
                images[f].height = texDatas.height;
              }
            }
          } else {
            texture.image.width = texDatas.width;
            texture.image.height = texDatas.height;
            texture.mipmaps = texDatas.mipmaps;
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          texture.format = texDatas.format;
          texture.needsUpdate = true;
          if (onLoad)
            onLoad(texture);
        }, onProgress, onError);
      }
      return texture;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function DataTextureLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this._parser = null;
  }
  Object.assign(DataTextureLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var texture = new DataTexture();
      var loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setPath(this.path);
      loader.load(url, function(buffer) {
        var texData = scope._parser(buffer);
        if (!texData)
          return;
        if (texData.image !== void 0) {
          texture.image = texData.image;
        } else if (texData.data !== void 0) {
          texture.image.width = texData.width;
          texture.image.height = texData.height;
          texture.image.data = texData.data;
        }
        texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;
        texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;
        texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;
        texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearMipMapLinearFilter;
        texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;
        if (texData.format !== void 0) {
          texture.format = texData.format;
        }
        if (texData.type !== void 0) {
          texture.type = texData.type;
        }
        if (texData.mipmaps !== void 0) {
          texture.mipmaps = texData.mipmaps;
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter;
        }
        texture.needsUpdate = true;
        if (onLoad)
          onLoad(texture, texData);
      }, onProgress, onError);
      return texture;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function ImageLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(ImageLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
      function onImageLoad() {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        Cache.add(url, this);
        if (onLoad)
          onLoad(this);
        scope.manager.itemEnd(url);
      }
      function onImageError(event) {
        image.removeEventListener("load", onImageLoad, false);
        image.removeEventListener("error", onImageError, false);
        if (onError)
          onError(event);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      }
      image.addEventListener("load", onImageLoad, false);
      image.addEventListener("error", onImageError, false);
      if (url.substr(0, 5) !== "data:") {
        if (this.crossOrigin !== void 0)
          image.crossOrigin = this.crossOrigin;
      }
      scope.manager.itemStart(url);
      image.src = url;
      return image;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      return this;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function CubeTextureLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(CubeTextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(urls, onLoad, onProgress, onError) {
      var texture = new CubeTexture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      var loaded = 0;
      function loadTexture(i2) {
        loader.load(urls[i2], function(image) {
          texture.images[i2] = image;
          loaded++;
          if (loaded === 6) {
            texture.needsUpdate = true;
            if (onLoad)
              onLoad(texture);
          }
        }, void 0, onError);
      }
      for (var i = 0; i < urls.length; ++i) {
        loadTexture(i);
      }
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      return this;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function TextureLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(TextureLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
      var texture = new Texture();
      var loader = new ImageLoader(this.manager);
      loader.setCrossOrigin(this.crossOrigin);
      loader.setPath(this.path);
      loader.load(url, function(image) {
        texture.image = image;
        var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
        texture.format = isJPEG ? RGBFormat : RGBAFormat;
        texture.needsUpdate = true;
        if (onLoad !== void 0) {
          onLoad(texture);
        }
      }, onProgress, onError);
      return texture;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      return this;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function Curve() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  Object.assign(Curve.prototype, {
    getPoint: function() {
      console.warn("THREE.Curve: .getPoint() not implemented.");
      return null;
    },
    getPointAt: function(u, optionalTarget) {
      var t = this.getUtoTmapping(u);
      return this.getPoint(t, optionalTarget);
    },
    getPoints: function(divisions) {
      if (divisions === void 0)
        divisions = 5;
      var points = [];
      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPoint(d / divisions));
      }
      return points;
    },
    getSpacedPoints: function(divisions) {
      if (divisions === void 0)
        divisions = 5;
      var points = [];
      for (var d = 0; d <= divisions; d++) {
        points.push(this.getPointAt(d / divisions));
      }
      return points;
    },
    getLength: function() {
      var lengths = this.getLengths();
      return lengths[lengths.length - 1];
    },
    getLengths: function(divisions) {
      if (divisions === void 0)
        divisions = this.arcLengthDivisions;
      if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
        return this.cacheArcLengths;
      }
      this.needsUpdate = false;
      var cache = [];
      var current, last = this.getPoint(0);
      var p2, sum = 0;
      cache.push(0);
      for (p2 = 1; p2 <= divisions; p2++) {
        current = this.getPoint(p2 / divisions);
        sum += current.distanceTo(last);
        cache.push(sum);
        last = current;
      }
      this.cacheArcLengths = cache;
      return cache;
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.getLengths();
    },
    getUtoTmapping: function(u, distance) {
      var arcLengths = this.getLengths();
      var i = 0, il = arcLengths.length;
      var targetArcLength;
      if (distance) {
        targetArcLength = distance;
      } else {
        targetArcLength = u * arcLengths[il - 1];
      }
      var low = 0, high = il - 1, comparison;
      while (low <= high) {
        i = Math.floor(low + (high - low) / 2);
        comparison = arcLengths[i] - targetArcLength;
        if (comparison < 0) {
          low = i + 1;
        } else if (comparison > 0) {
          high = i - 1;
        } else {
          high = i;
          break;
        }
      }
      i = high;
      if (arcLengths[i] === targetArcLength) {
        return i / (il - 1);
      }
      var lengthBefore = arcLengths[i];
      var lengthAfter = arcLengths[i + 1];
      var segmentLength = lengthAfter - lengthBefore;
      var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
      var t = (i + segmentFraction) / (il - 1);
      return t;
    },
    getTangent: function(t) {
      var delta = 1e-4;
      var t1 = t - delta;
      var t2 = t + delta;
      if (t1 < 0)
        t1 = 0;
      if (t2 > 1)
        t2 = 1;
      var pt1 = this.getPoint(t1);
      var pt2 = this.getPoint(t2);
      var vec = pt2.clone().sub(pt1);
      return vec.normalize();
    },
    getTangentAt: function(u) {
      var t = this.getUtoTmapping(u);
      return this.getTangent(t);
    },
    computeFrenetFrames: function(segments, closed) {
      var normal = new Vector3();
      var tangents = [];
      var normals = [];
      var binormals = [];
      var vec = new Vector3();
      var mat = new Matrix4();
      var i, u, theta;
      for (i = 0; i <= segments; i++) {
        u = i / segments;
        tangents[i] = this.getTangentAt(u);
        tangents[i].normalize();
      }
      normals[0] = new Vector3();
      binormals[0] = new Vector3();
      var min = Number.MAX_VALUE;
      var tx = Math.abs(tangents[0].x);
      var ty = Math.abs(tangents[0].y);
      var tz = Math.abs(tangents[0].z);
      if (tx <= min) {
        min = tx;
        normal.set(1, 0, 0);
      }
      if (ty <= min) {
        min = ty;
        normal.set(0, 1, 0);
      }
      if (tz <= min) {
        normal.set(0, 0, 1);
      }
      vec.crossVectors(tangents[0], normal).normalize();
      normals[0].crossVectors(tangents[0], vec);
      binormals[0].crossVectors(tangents[0], normals[0]);
      for (i = 1; i <= segments; i++) {
        normals[i] = normals[i - 1].clone();
        binormals[i] = binormals[i - 1].clone();
        vec.crossVectors(tangents[i - 1], tangents[i]);
        if (vec.length() > Number.EPSILON) {
          vec.normalize();
          theta = Math.acos(_Math.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
          normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
        }
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
      if (closed === true) {
        theta = Math.acos(_Math.clamp(normals[0].dot(normals[segments]), -1, 1));
        theta /= segments;
        if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
          theta = -theta;
        }
        for (i = 1; i <= segments; i++) {
          normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
          binormals[i].crossVectors(tangents[i], normals[i]);
        }
      }
      return {
        tangents,
        normals,
        binormals
      };
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(source) {
      this.arcLengthDivisions = source.arcLengthDivisions;
      return this;
    },
    toJSON: function() {
      var data = {
        metadata: {
          version: 4.5,
          type: "Curve",
          generator: "Curve.toJSON"
        }
      };
      data.arcLengthDivisions = this.arcLengthDivisions;
      data.type = this.type;
      return data;
    },
    fromJSON: function(json) {
      this.arcLengthDivisions = json.arcLengthDivisions;
      return this;
    }
  });
  function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    Curve.call(this);
    this.type = "EllipseCurve";
    this.aX = aX || 0;
    this.aY = aY || 0;
    this.xRadius = xRadius || 1;
    this.yRadius = yRadius || 1;
    this.aStartAngle = aStartAngle || 0;
    this.aEndAngle = aEndAngle || 2 * Math.PI;
    this.aClockwise = aClockwise || false;
    this.aRotation = aRotation || 0;
  }
  EllipseCurve.prototype = Object.create(Curve.prototype);
  EllipseCurve.prototype.constructor = EllipseCurve;
  EllipseCurve.prototype.isEllipseCurve = true;
  EllipseCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var twoPi = Math.PI * 2;
    var deltaAngle = this.aEndAngle - this.aStartAngle;
    var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    var angle = this.aStartAngle + t * deltaAngle;
    var x = this.aX + this.xRadius * Math.cos(angle);
    var y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      var cos = Math.cos(this.aRotation);
      var sin = Math.sin(this.aRotation);
      var tx = x - this.aX;
      var ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  };
  EllipseCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  };
  EllipseCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  };
  EllipseCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  };
  function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.type = "ArcCurve";
  }
  ArcCurve.prototype = Object.create(EllipseCurve.prototype);
  ArcCurve.prototype.constructor = ArcCurve;
  ArcCurve.prototype.isArcCurve = true;
  function CubicPoly() {
    var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
    function init3(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function(x0, x1, x2, x3, tension) {
        init3(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
        t1 *= dt1;
        t2 *= dt1;
        init3(x1, x2, t1, t2);
      },
      calc: function(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }
  var tmp = new Vector3();
  var px = new CubicPoly();
  var py = new CubicPoly();
  var pz = new CubicPoly();
  function CatmullRomCurve3(points, closed, curveType, tension) {
    Curve.call(this);
    this.type = "CatmullRomCurve3";
    this.points = points || [];
    this.closed = closed || false;
    this.curveType = curveType || "centripetal";
    this.tension = tension || 0.5;
  }
  CatmullRomCurve3.prototype = Object.create(Curve.prototype);
  CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
  CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
  CatmullRomCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var points = this.points;
    var l = points.length;
    var p2 = (l - (this.closed ? 0 : 1)) * t;
    var intPoint = Math.floor(p2);
    var weight = p2 - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    var p0, p1, p22, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    p1 = points[intPoint % l];
    p22 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      var pow = this.curveType === "chordal" ? 0.5 : 0.25;
      var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      var dt1 = Math.pow(p1.distanceToSquared(p22), pow);
      var dt2 = Math.pow(p22.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension);
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
    return point;
  };
  CatmullRomCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for (var i = 0, l = source.points.length; i < l; i++) {
      var point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  };
  CatmullRomCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for (var i = 0, l = this.points.length; i < l; i++) {
      var point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  };
  CatmullRomCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for (var i = 0, l = json.points.length; i < l; i++) {
      var point = json.points[i];
      this.points.push(new Vector3().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  };
  function CatmullRom(t, p0, p1, p2, p3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }
  function QuadraticBezierP0(t, p2) {
    var k = 1 - t;
    return k * k * p2;
  }
  function QuadraticBezierP1(t, p2) {
    return 2 * (1 - t) * t * p2;
  }
  function QuadraticBezierP2(t, p2) {
    return t * t * p2;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }
  function CubicBezierP0(t, p2) {
    var k = 1 - t;
    return k * k * k * p2;
  }
  function CubicBezierP1(t, p2) {
    var k = 1 - t;
    return 3 * k * k * t * p2;
  }
  function CubicBezierP2(t, p2) {
    return 3 * (1 - t) * t * t * p2;
  }
  function CubicBezierP3(t, p2) {
    return t * t * t * p2;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  function CubicBezierCurve(v0, v1, v2, v32) {
    Curve.call(this);
    this.type = "CubicBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
    this.v3 = v32 || new Vector2();
  }
  CubicBezierCurve.prototype = Object.create(Curve.prototype);
  CubicBezierCurve.prototype.constructor = CubicBezierCurve;
  CubicBezierCurve.prototype.isCubicBezierCurve = true;
  CubicBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v32 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v32.x), CubicBezier(t, v0.y, v1.y, v2.y, v32.y));
    return point;
  };
  CubicBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };
  CubicBezierCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };
  CubicBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };
  function CubicBezierCurve3(v0, v1, v2, v32) {
    Curve.call(this);
    this.type = "CubicBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
    this.v3 = v32 || new Vector3();
  }
  CubicBezierCurve3.prototype = Object.create(Curve.prototype);
  CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
  CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
  CubicBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2, v32 = this.v3;
    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v32.x), CubicBezier(t, v0.y, v1.y, v2.y, v32.y), CubicBezier(t, v0.z, v1.z, v2.z, v32.z));
    return point;
  };
  CubicBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  };
  CubicBezierCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  };
  CubicBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  };
  function LineCurve(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve";
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
  }
  LineCurve.prototype = Object.create(Curve.prototype);
  LineCurve.prototype.constructor = LineCurve;
  LineCurve.prototype.isLineCurve = true;
  LineCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  };
  LineCurve.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };
  LineCurve.prototype.getTangent = function() {
    var tangent = this.v2.clone().sub(this.v1);
    return tangent.normalize();
  };
  LineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  LineCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  LineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function LineCurve3(v1, v2) {
    Curve.call(this);
    this.type = "LineCurve3";
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
  }
  LineCurve3.prototype = Object.create(Curve.prototype);
  LineCurve3.prototype.constructor = LineCurve3;
  LineCurve3.prototype.isLineCurve3 = true;
  LineCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  };
  LineCurve3.prototype.getPointAt = function(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  };
  LineCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  LineCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  LineCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function QuadraticBezierCurve(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve";
    this.v0 = v0 || new Vector2();
    this.v1 = v1 || new Vector2();
    this.v2 = v2 || new Vector2();
  }
  QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
  QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
  QuadraticBezierCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
    return point;
  };
  QuadraticBezierCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  QuadraticBezierCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  QuadraticBezierCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function QuadraticBezierCurve3(v0, v1, v2) {
    Curve.call(this);
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0 || new Vector3();
    this.v1 = v1 || new Vector3();
    this.v2 = v2 || new Vector3();
  }
  QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
  QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
  QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
  QuadraticBezierCurve3.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector3();
    var v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
    return point;
  };
  QuadraticBezierCurve3.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  };
  QuadraticBezierCurve3.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  };
  QuadraticBezierCurve3.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  };
  function SplineCurve(points) {
    Curve.call(this);
    this.type = "SplineCurve";
    this.points = points || [];
  }
  SplineCurve.prototype = Object.create(Curve.prototype);
  SplineCurve.prototype.constructor = SplineCurve;
  SplineCurve.prototype.isSplineCurve = true;
  SplineCurve.prototype.getPoint = function(t, optionalTarget) {
    var point = optionalTarget || new Vector2();
    var points = this.points;
    var p2 = (points.length - 1) * t;
    var intPoint = Math.floor(p2);
    var weight = p2 - intPoint;
    var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    var p1 = points[intPoint];
    var p22 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(CatmullRom(weight, p0.x, p1.x, p22.x, p3.x), CatmullRom(weight, p0.y, p1.y, p22.y, p3.y));
    return point;
  };
  SplineCurve.prototype.copy = function(source) {
    Curve.prototype.copy.call(this, source);
    this.points = [];
    for (var i = 0, l = source.points.length; i < l; i++) {
      var point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  };
  SplineCurve.prototype.toJSON = function() {
    var data = Curve.prototype.toJSON.call(this);
    data.points = [];
    for (var i = 0, l = this.points.length; i < l; i++) {
      var point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  };
  SplineCurve.prototype.fromJSON = function(json) {
    Curve.prototype.fromJSON.call(this, json);
    this.points = [];
    for (var i = 0, l = json.points.length; i < l; i++) {
      var point = json.points[i];
      this.points.push(new Vector2().fromArray(point));
    }
    return this;
  };
  var Curves = /* @__PURE__ */ Object.freeze({
    ArcCurve,
    CatmullRomCurve3,
    CubicBezierCurve,
    CubicBezierCurve3,
    EllipseCurve,
    LineCurve,
    LineCurve3,
    QuadraticBezierCurve,
    QuadraticBezierCurve3,
    SplineCurve
  });
  function CurvePath() {
    Curve.call(this);
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
    constructor: CurvePath,
    add: function(curve) {
      this.curves.push(curve);
    },
    closePath: function() {
      var startPoint = this.curves[0].getPoint(0);
      var endPoint = this.curves[this.curves.length - 1].getPoint(1);
      if (!startPoint.equals(endPoint)) {
        this.curves.push(new LineCurve(endPoint, startPoint));
      }
    },
    getPoint: function(t) {
      var d = t * this.getLength();
      var curveLengths = this.getCurveLengths();
      var i = 0;
      while (i < curveLengths.length) {
        if (curveLengths[i] >= d) {
          var diff = curveLengths[i] - d;
          var curve = this.curves[i];
          var segmentLength = curve.getLength();
          var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
          return curve.getPointAt(u);
        }
        i++;
      }
      return null;
    },
    getLength: function() {
      var lens = this.getCurveLengths();
      return lens[lens.length - 1];
    },
    updateArcLengths: function() {
      this.needsUpdate = true;
      this.cacheLengths = null;
      this.getCurveLengths();
    },
    getCurveLengths: function() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
        return this.cacheLengths;
      }
      var lengths = [], sums = 0;
      for (var i = 0, l = this.curves.length; i < l; i++) {
        sums += this.curves[i].getLength();
        lengths.push(sums);
      }
      this.cacheLengths = lengths;
      return lengths;
    },
    getSpacedPoints: function(divisions) {
      if (divisions === void 0)
        divisions = 40;
      var points = [];
      for (var i = 0; i <= divisions; i++) {
        points.push(this.getPoint(i / divisions));
      }
      if (this.autoClose) {
        points.push(points[0]);
      }
      return points;
    },
    getPoints: function(divisions) {
      divisions = divisions || 12;
      var points = [], last;
      for (var i = 0, curves = this.curves; i < curves.length; i++) {
        var curve = curves[i];
        var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
        var pts = curve.getPoints(resolution);
        for (var j = 0; j < pts.length; j++) {
          var point = pts[j];
          if (last && last.equals(point))
            continue;
          points.push(point);
          last = point;
        }
      }
      if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
        points.push(points[0]);
      }
      return points;
    },
    copy: function(source) {
      Curve.prototype.copy.call(this, source);
      this.curves = [];
      for (var i = 0, l = source.curves.length; i < l; i++) {
        var curve = source.curves[i];
        this.curves.push(curve.clone());
      }
      this.autoClose = source.autoClose;
      return this;
    },
    toJSON: function() {
      var data = Curve.prototype.toJSON.call(this);
      data.autoClose = this.autoClose;
      data.curves = [];
      for (var i = 0, l = this.curves.length; i < l; i++) {
        var curve = this.curves[i];
        data.curves.push(curve.toJSON());
      }
      return data;
    },
    fromJSON: function(json) {
      Curve.prototype.fromJSON.call(this, json);
      this.autoClose = json.autoClose;
      this.curves = [];
      for (var i = 0, l = json.curves.length; i < l; i++) {
        var curve = json.curves[i];
        this.curves.push(new Curves[curve.type]().fromJSON(curve));
      }
      return this;
    }
  });
  function Path(points) {
    CurvePath.call(this);
    this.type = "Path";
    this.currentPoint = new Vector2();
    if (points) {
      this.setFromPoints(points);
    }
  }
  Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
    constructor: Path,
    setFromPoints: function(points) {
      this.moveTo(points[0].x, points[0].y);
      for (var i = 1, l = points.length; i < l; i++) {
        this.lineTo(points[i].x, points[i].y);
      }
    },
    moveTo: function(x, y) {
      this.currentPoint.set(x, y);
    },
    lineTo: function(x, y) {
      var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
      this.curves.push(curve);
      this.currentPoint.set(x, y);
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
      var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
      this.curves.push(curve);
      this.currentPoint.set(aX, aY);
    },
    splineThru: function(pts) {
      var npts = [this.currentPoint.clone()].concat(pts);
      var curve = new SplineCurve(npts);
      this.curves.push(curve);
      this.currentPoint.copy(pts[pts.length - 1]);
    },
    arc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    absarc: function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    },
    ellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var x0 = this.currentPoint.x;
      var y0 = this.currentPoint.y;
      this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    },
    absellipse: function(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
      var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
      if (this.curves.length > 0) {
        var firstPoint = curve.getPoint(0);
        if (!firstPoint.equals(this.currentPoint)) {
          this.lineTo(firstPoint.x, firstPoint.y);
        }
      }
      this.curves.push(curve);
      var lastPoint = curve.getPoint(1);
      this.currentPoint.copy(lastPoint);
    },
    copy: function(source) {
      CurvePath.prototype.copy.call(this, source);
      this.currentPoint.copy(source.currentPoint);
      return this;
    },
    toJSON: function() {
      var data = CurvePath.prototype.toJSON.call(this);
      data.currentPoint = this.currentPoint.toArray();
      return data;
    },
    fromJSON: function(json) {
      CurvePath.prototype.fromJSON.call(this, json);
      this.currentPoint.fromArray(json.currentPoint);
      return this;
    }
  });
  function Shape(points) {
    Path.call(this, points);
    this.uuid = _Math.generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  Shape.prototype = Object.assign(Object.create(Path.prototype), {
    constructor: Shape,
    getPointsHoles: function(divisions) {
      var holesPts = [];
      for (var i = 0, l = this.holes.length; i < l; i++) {
        holesPts[i] = this.holes[i].getPoints(divisions);
      }
      return holesPts;
    },
    extractPoints: function(divisions) {
      return {
        shape: this.getPoints(divisions),
        holes: this.getPointsHoles(divisions)
      };
    },
    copy: function(source) {
      Path.prototype.copy.call(this, source);
      this.holes = [];
      for (var i = 0, l = source.holes.length; i < l; i++) {
        var hole = source.holes[i];
        this.holes.push(hole.clone());
      }
      return this;
    },
    toJSON: function() {
      var data = Path.prototype.toJSON.call(this);
      data.uuid = this.uuid;
      data.holes = [];
      for (var i = 0, l = this.holes.length; i < l; i++) {
        var hole = this.holes[i];
        data.holes.push(hole.toJSON());
      }
      return data;
    },
    fromJSON: function(json) {
      Path.prototype.fromJSON.call(this, json);
      this.uuid = json.uuid;
      this.holes = [];
      for (var i = 0, l = json.holes.length; i < l; i++) {
        var hole = json.holes[i];
        this.holes.push(new Path().fromJSON(hole));
      }
      return this;
    }
  });
  function Light(color, intensity) {
    Object3D.call(this);
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity !== void 0 ? intensity : 1;
    this.receiveShadow = void 0;
  }
  Light.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Light,
    isLight: true,
    copy: function(source) {
      Object3D.prototype.copy.call(this, source);
      this.color.copy(source.color);
      this.intensity = source.intensity;
      return this;
    },
    toJSON: function(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.color = this.color.getHex();
      data.object.intensity = this.intensity;
      if (this.groundColor !== void 0)
        data.object.groundColor = this.groundColor.getHex();
      if (this.distance !== void 0)
        data.object.distance = this.distance;
      if (this.angle !== void 0)
        data.object.angle = this.angle;
      if (this.decay !== void 0)
        data.object.decay = this.decay;
      if (this.penumbra !== void 0)
        data.object.penumbra = this.penumbra;
      if (this.shadow !== void 0)
        data.object.shadow = this.shadow.toJSON();
      return data;
    }
  });
  function HemisphereLight(skyColor, groundColor, intensity) {
    Light.call(this, skyColor, intensity);
    this.type = "HemisphereLight";
    this.castShadow = void 0;
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.groundColor = new Color(groundColor);
  }
  HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: HemisphereLight,
    isHemisphereLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.groundColor.copy(source.groundColor);
      return this;
    }
  });
  function LightShadow(camera2) {
    this.camera = camera2;
    this.bias = 0;
    this.radius = 1;
    this.mapSize = new Vector2(512, 512);
    this.map = null;
    this.matrix = new Matrix4();
  }
  Object.assign(LightShadow.prototype, {
    copy: function(source) {
      this.camera = source.camera.clone();
      this.bias = source.bias;
      this.radius = source.radius;
      this.mapSize.copy(source.mapSize);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    toJSON: function() {
      var object = {};
      if (this.bias !== 0)
        object.bias = this.bias;
      if (this.radius !== 1)
        object.radius = this.radius;
      if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
        object.mapSize = this.mapSize.toArray();
      object.camera = this.camera.toJSON(false).object;
      delete object.camera.matrix;
      return object;
    }
  });
  function SpotLightShadow() {
    LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
  }
  SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: SpotLightShadow,
    isSpotLightShadow: true,
    update: function(light2) {
      var camera2 = this.camera;
      var fov = _Math.RAD2DEG * 2 * light2.angle;
      var aspect = this.mapSize.width / this.mapSize.height;
      var far = light2.distance || camera2.far;
      if (fov !== camera2.fov || aspect !== camera2.aspect || far !== camera2.far) {
        camera2.fov = fov;
        camera2.aspect = aspect;
        camera2.far = far;
        camera2.updateProjectionMatrix();
      }
    }
  });
  function SpotLight(color, intensity, distance, angle, penumbra, decay) {
    Light.call(this, color, intensity);
    this.type = "SpotLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * Math.PI;
      },
      set: function(power) {
        this.intensity = power / Math.PI;
      }
    });
    this.distance = distance !== void 0 ? distance : 0;
    this.angle = angle !== void 0 ? angle : Math.PI / 3;
    this.penumbra = penumbra !== void 0 ? penumbra : 0;
    this.decay = decay !== void 0 ? decay : 1;
    this.shadow = new SpotLightShadow();
  }
  SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: SpotLight,
    isSpotLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.angle = source.angle;
      this.penumbra = source.penumbra;
      this.decay = source.decay;
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function PointLight(color, intensity, distance, decay) {
    Light.call(this, color, intensity);
    this.type = "PointLight";
    Object.defineProperty(this, "power", {
      get: function() {
        return this.intensity * 4 * Math.PI;
      },
      set: function(power) {
        this.intensity = power / (4 * Math.PI);
      }
    });
    this.distance = distance !== void 0 ? distance : 0;
    this.decay = decay !== void 0 ? decay : 1;
    this.shadow = new LightShadow(new PerspectiveCamera(90, 1, 0.5, 500));
  }
  PointLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: PointLight,
    isPointLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.distance = source.distance;
      this.decay = source.decay;
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function OrthographicCamera(left, right, top, bottom, near, far) {
    Camera2.call(this);
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left !== void 0 ? left : -1;
    this.right = right !== void 0 ? right : 1;
    this.top = top !== void 0 ? top : 1;
    this.bottom = bottom !== void 0 ? bottom : -1;
    this.near = near !== void 0 ? near : 0.1;
    this.far = far !== void 0 ? far : 2e3;
    this.updateProjectionMatrix();
  }
  OrthographicCamera.prototype = Object.assign(Object.create(Camera2.prototype), {
    constructor: OrthographicCamera,
    isOrthographicCamera: true,
    copy: function(source, recursive) {
      Camera2.prototype.copy.call(this, source, recursive);
      this.left = source.left;
      this.right = source.right;
      this.top = source.top;
      this.bottom = source.bottom;
      this.near = source.near;
      this.far = source.far;
      this.zoom = source.zoom;
      this.view = source.view === null ? null : Object.assign({}, source.view);
      return this;
    },
    setViewOffset: function(fullWidth, fullHeight, x, y, width2, height2) {
      if (this.view === null) {
        this.view = {
          enabled: true,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1
        };
      }
      this.view.enabled = true;
      this.view.fullWidth = fullWidth;
      this.view.fullHeight = fullHeight;
      this.view.offsetX = x;
      this.view.offsetY = y;
      this.view.width = width2;
      this.view.height = height2;
      this.updateProjectionMatrix();
    },
    clearViewOffset: function() {
      if (this.view !== null) {
        this.view.enabled = false;
      }
      this.updateProjectionMatrix();
    },
    updateProjectionMatrix: function() {
      var dx = (this.right - this.left) / (2 * this.zoom);
      var dy = (this.top - this.bottom) / (2 * this.zoom);
      var cx = (this.right + this.left) / 2;
      var cy = (this.top + this.bottom) / 2;
      var left = cx - dx;
      var right = cx + dx;
      var top = cy + dy;
      var bottom = cy - dy;
      if (this.view !== null && this.view.enabled) {
        var zoomW = this.zoom / (this.view.width / this.view.fullWidth);
        var zoomH = this.zoom / (this.view.height / this.view.fullHeight);
        var scaleW = (this.right - this.left) / this.view.width;
        var scaleH = (this.top - this.bottom) / this.view.height;
        left += scaleW * (this.view.offsetX / zoomW);
        right = left + scaleW * (this.view.width / zoomW);
        top -= scaleH * (this.view.offsetY / zoomH);
        bottom = top - scaleH * (this.view.height / zoomH);
      }
      this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
      this.projectionMatrixInverse.getInverse(this.projectionMatrix);
    },
    toJSON: function(meta) {
      var data = Object3D.prototype.toJSON.call(this, meta);
      data.object.zoom = this.zoom;
      data.object.left = this.left;
      data.object.right = this.right;
      data.object.top = this.top;
      data.object.bottom = this.bottom;
      data.object.near = this.near;
      data.object.far = this.far;
      if (this.view !== null)
        data.object.view = Object.assign({}, this.view);
      return data;
    }
  });
  function DirectionalLightShadow() {
    LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
  }
  DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
    constructor: DirectionalLightShadow
  });
  function DirectionalLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DefaultUp);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: DirectionalLight,
    isDirectionalLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.target = source.target.clone();
      this.shadow = source.shadow.clone();
      return this;
    }
  });
  function AmbientLight(color, intensity) {
    Light.call(this, color, intensity);
    this.type = "AmbientLight";
    this.castShadow = void 0;
  }
  AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: AmbientLight,
    isAmbientLight: true
  });
  function RectAreaLight(color, intensity, width2, height2) {
    Light.call(this, color, intensity);
    this.type = "RectAreaLight";
    this.width = width2 !== void 0 ? width2 : 10;
    this.height = height2 !== void 0 ? height2 : 10;
  }
  RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
    constructor: RectAreaLight,
    isRectAreaLight: true,
    copy: function(source) {
      Light.prototype.copy.call(this, source);
      this.width = source.width;
      this.height = source.height;
      return this;
    },
    toJSON: function(meta) {
      var data = Light.prototype.toJSON.call(this, meta);
      data.object.width = this.width;
      data.object.height = this.height;
      return data;
    }
  });
  function MaterialLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.textures = {};
  }
  Object.assign(MaterialLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function(text2) {
        onLoad(scope.parse(JSON.parse(text2)));
      }, onProgress, onError);
    },
    parse: function(json) {
      var textures = this.textures;
      function getTexture(name2) {
        if (textures[name2] === void 0) {
          console.warn("THREE.MaterialLoader: Undefined texture", name2);
        }
        return textures[name2];
      }
      var material = new Materials[json.type]();
      if (json.uuid !== void 0)
        material.uuid = json.uuid;
      if (json.name !== void 0)
        material.name = json.name;
      if (json.color !== void 0)
        material.color.setHex(json.color);
      if (json.roughness !== void 0)
        material.roughness = json.roughness;
      if (json.metalness !== void 0)
        material.metalness = json.metalness;
      if (json.emissive !== void 0)
        material.emissive.setHex(json.emissive);
      if (json.specular !== void 0)
        material.specular.setHex(json.specular);
      if (json.shininess !== void 0)
        material.shininess = json.shininess;
      if (json.clearCoat !== void 0)
        material.clearCoat = json.clearCoat;
      if (json.clearCoatRoughness !== void 0)
        material.clearCoatRoughness = json.clearCoatRoughness;
      if (json.vertexColors !== void 0)
        material.vertexColors = json.vertexColors;
      if (json.fog !== void 0)
        material.fog = json.fog;
      if (json.flatShading !== void 0)
        material.flatShading = json.flatShading;
      if (json.blending !== void 0)
        material.blending = json.blending;
      if (json.combine !== void 0)
        material.combine = json.combine;
      if (json.side !== void 0)
        material.side = json.side;
      if (json.opacity !== void 0)
        material.opacity = json.opacity;
      if (json.transparent !== void 0)
        material.transparent = json.transparent;
      if (json.alphaTest !== void 0)
        material.alphaTest = json.alphaTest;
      if (json.depthTest !== void 0)
        material.depthTest = json.depthTest;
      if (json.depthWrite !== void 0)
        material.depthWrite = json.depthWrite;
      if (json.colorWrite !== void 0)
        material.colorWrite = json.colorWrite;
      if (json.wireframe !== void 0)
        material.wireframe = json.wireframe;
      if (json.wireframeLinewidth !== void 0)
        material.wireframeLinewidth = json.wireframeLinewidth;
      if (json.wireframeLinecap !== void 0)
        material.wireframeLinecap = json.wireframeLinecap;
      if (json.wireframeLinejoin !== void 0)
        material.wireframeLinejoin = json.wireframeLinejoin;
      if (json.rotation !== void 0)
        material.rotation = json.rotation;
      if (json.linewidth !== 1)
        material.linewidth = json.linewidth;
      if (json.dashSize !== void 0)
        material.dashSize = json.dashSize;
      if (json.gapSize !== void 0)
        material.gapSize = json.gapSize;
      if (json.scale !== void 0)
        material.scale = json.scale;
      if (json.polygonOffset !== void 0)
        material.polygonOffset = json.polygonOffset;
      if (json.polygonOffsetFactor !== void 0)
        material.polygonOffsetFactor = json.polygonOffsetFactor;
      if (json.polygonOffsetUnits !== void 0)
        material.polygonOffsetUnits = json.polygonOffsetUnits;
      if (json.skinning !== void 0)
        material.skinning = json.skinning;
      if (json.morphTargets !== void 0)
        material.morphTargets = json.morphTargets;
      if (json.dithering !== void 0)
        material.dithering = json.dithering;
      if (json.visible !== void 0)
        material.visible = json.visible;
      if (json.userData !== void 0)
        material.userData = json.userData;
      if (json.uniforms !== void 0) {
        for (var name in json.uniforms) {
          var uniform = json.uniforms[name];
          material.uniforms[name] = {};
          switch (uniform.type) {
            case "t":
              material.uniforms[name].value = getTexture(uniform.value);
              break;
            case "c":
              material.uniforms[name].value = new Color().setHex(uniform.value);
              break;
            case "v2":
              material.uniforms[name].value = new Vector2().fromArray(uniform.value);
              break;
            case "v3":
              material.uniforms[name].value = new Vector3().fromArray(uniform.value);
              break;
            case "v4":
              material.uniforms[name].value = new Vector4().fromArray(uniform.value);
              break;
            case "m3":
              material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
            case "m4":
              material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
              break;
            default:
              material.uniforms[name].value = uniform.value;
          }
        }
      }
      if (json.defines !== void 0)
        material.defines = json.defines;
      if (json.vertexShader !== void 0)
        material.vertexShader = json.vertexShader;
      if (json.fragmentShader !== void 0)
        material.fragmentShader = json.fragmentShader;
      if (json.extensions !== void 0) {
        for (var key in json.extensions) {
          material.extensions[key] = json.extensions[key];
        }
      }
      if (json.shading !== void 0)
        material.flatShading = json.shading === 1;
      if (json.size !== void 0)
        material.size = json.size;
      if (json.sizeAttenuation !== void 0)
        material.sizeAttenuation = json.sizeAttenuation;
      if (json.map !== void 0)
        material.map = getTexture(json.map);
      if (json.alphaMap !== void 0) {
        material.alphaMap = getTexture(json.alphaMap);
        material.transparent = true;
      }
      if (json.bumpMap !== void 0)
        material.bumpMap = getTexture(json.bumpMap);
      if (json.bumpScale !== void 0)
        material.bumpScale = json.bumpScale;
      if (json.normalMap !== void 0)
        material.normalMap = getTexture(json.normalMap);
      if (json.normalMapType !== void 0)
        material.normalMapType = json.normalMapType;
      if (json.normalScale !== void 0) {
        var normalScale = json.normalScale;
        if (Array.isArray(normalScale) === false) {
          normalScale = [normalScale, normalScale];
        }
        material.normalScale = new Vector2().fromArray(normalScale);
      }
      if (json.displacementMap !== void 0)
        material.displacementMap = getTexture(json.displacementMap);
      if (json.displacementScale !== void 0)
        material.displacementScale = json.displacementScale;
      if (json.displacementBias !== void 0)
        material.displacementBias = json.displacementBias;
      if (json.roughnessMap !== void 0)
        material.roughnessMap = getTexture(json.roughnessMap);
      if (json.metalnessMap !== void 0)
        material.metalnessMap = getTexture(json.metalnessMap);
      if (json.emissiveMap !== void 0)
        material.emissiveMap = getTexture(json.emissiveMap);
      if (json.emissiveIntensity !== void 0)
        material.emissiveIntensity = json.emissiveIntensity;
      if (json.specularMap !== void 0)
        material.specularMap = getTexture(json.specularMap);
      if (json.envMap !== void 0)
        material.envMap = getTexture(json.envMap);
      if (json.envMapIntensity !== void 0)
        material.envMapIntensity = json.envMapIntensity;
      if (json.reflectivity !== void 0)
        material.reflectivity = json.reflectivity;
      if (json.lightMap !== void 0)
        material.lightMap = getTexture(json.lightMap);
      if (json.lightMapIntensity !== void 0)
        material.lightMapIntensity = json.lightMapIntensity;
      if (json.aoMap !== void 0)
        material.aoMap = getTexture(json.aoMap);
      if (json.aoMapIntensity !== void 0)
        material.aoMapIntensity = json.aoMapIntensity;
      if (json.gradientMap !== void 0)
        material.gradientMap = getTexture(json.gradientMap);
      return material;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    },
    setTextures: function(value) {
      this.textures = value;
      return this;
    }
  });
  var LoaderUtils = {
    decodeText: function(array) {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(array);
      }
      var s2 = "";
      for (var i = 0, il = array.length; i < il; i++) {
        s2 += String.fromCharCode(array[i]);
      }
      return decodeURIComponent(escape(s2));
    },
    extractUrlBase: function(url) {
      var index = url.lastIndexOf("/");
      if (index === -1)
        return "./";
      return url.substr(0, index + 1);
    }
  };
  function BufferGeometryLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(BufferGeometryLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(scope.manager);
      loader.setPath(scope.path);
      loader.load(url, function(text2) {
        onLoad(scope.parse(JSON.parse(text2)));
      }, onProgress, onError);
    },
    parse: function(json) {
      var geometry2 = new BufferGeometry();
      var index = json.data.index;
      if (index !== void 0) {
        var typedArray = new TYPED_ARRAYS[index.type](index.array);
        geometry2.setIndex(new BufferAttribute(typedArray, 1));
      }
      var attributes = json.data.attributes;
      for (var key in attributes) {
        var attribute = attributes[key];
        var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
        var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
        if (attribute.name !== void 0)
          bufferAttribute.name = attribute.name;
        geometry2.addAttribute(key, bufferAttribute);
      }
      var morphAttributes = json.data.morphAttributes;
      if (morphAttributes) {
        for (var key in morphAttributes) {
          var attributeArray = morphAttributes[key];
          var array = [];
          for (var i = 0, il = attributeArray.length; i < il; i++) {
            var attribute = attributeArray[i];
            var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
            var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
            if (attribute.name !== void 0)
              bufferAttribute.name = attribute.name;
            array.push(bufferAttribute);
          }
          geometry2.morphAttributes[key] = array;
        }
      }
      var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
      if (groups !== void 0) {
        for (var i = 0, n = groups.length; i !== n; ++i) {
          var group = groups[i];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
      }
      var boundingSphere = json.data.boundingSphere;
      if (boundingSphere !== void 0) {
        var center = new Vector3();
        if (boundingSphere.center !== void 0) {
          center.fromArray(boundingSphere.center);
        }
        geometry2.boundingSphere = new Sphere(center, boundingSphere.radius);
      }
      if (json.name)
        geometry2.name = json.name;
      if (json.userData)
        geometry2.userData = json.userData;
      return geometry2;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  var TYPED_ARRAYS = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
  };
  function ObjectLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.resourcePath = "";
  }
  Object.assign(ObjectLoader.prototype, {
    crossOrigin: "anonymous",
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path === void 0 ? LoaderUtils.extractUrlBase(url) : this.path;
      this.resourcePath = this.resourcePath || path;
      var loader = new FileLoader(scope.manager);
      loader.setPath(this.path);
      loader.load(url, function(text2) {
        var json = null;
        try {
          json = JSON.parse(text2);
        } catch (error) {
          if (onError !== void 0)
            onError(error);
          console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
          return;
        }
        var metadata = json.metadata;
        if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === "geometry") {
          console.error("THREE.ObjectLoader: Can't load " + url);
          return;
        }
        scope.parse(json, onLoad);
      }, onProgress, onError);
    },
    setPath: function(value) {
      this.path = value;
      return this;
    },
    setResourcePath: function(value) {
      this.resourcePath = value;
      return this;
    },
    setCrossOrigin: function(value) {
      this.crossOrigin = value;
      return this;
    },
    parse: function(json, onLoad) {
      var shapes = this.parseShape(json.shapes);
      var geometries = this.parseGeometries(json.geometries, shapes);
      var images = this.parseImages(json.images, function() {
        if (onLoad !== void 0)
          onLoad(object);
      });
      var textures = this.parseTextures(json.textures, images);
      var materials = this.parseMaterials(json.materials, textures);
      var object = this.parseObject(json.object, geometries, materials);
      if (json.animations) {
        object.animations = this.parseAnimations(json.animations);
      }
      if (json.images === void 0 || json.images.length === 0) {
        if (onLoad !== void 0)
          onLoad(object);
      }
      return object;
    },
    parseShape: function(json) {
      var shapes = {};
      if (json !== void 0) {
        for (var i = 0, l = json.length; i < l; i++) {
          var shape = new Shape().fromJSON(json[i]);
          shapes[shape.uuid] = shape;
        }
      }
      return shapes;
    },
    parseGeometries: function(json, shapes) {
      var geometries = {};
      if (json !== void 0) {
        var bufferGeometryLoader = new BufferGeometryLoader();
        for (var i = 0, l = json.length; i < l; i++) {
          var geometry2;
          var data = json[i];
          switch (data.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
              geometry2 = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
              break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
              geometry2 = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
              break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
              break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
              geometry2 = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;
            case "ConeGeometry":
            case "ConeBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
              break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
              break;
            case "DodecahedronGeometry":
            case "DodecahedronBufferGeometry":
            case "IcosahedronGeometry":
            case "IcosahedronBufferGeometry":
            case "OctahedronGeometry":
            case "OctahedronBufferGeometry":
            case "TetrahedronGeometry":
            case "TetrahedronBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.detail);
              break;
            case "RingGeometry":
            case "RingBufferGeometry":
              geometry2 = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
              break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
              break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
              geometry2 = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
              break;
            case "TubeGeometry":
            case "TubeBufferGeometry":
              geometry2 = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
              break;
            case "LatheGeometry":
            case "LatheBufferGeometry":
              geometry2 = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
              break;
            case "PolyhedronGeometry":
            case "PolyhedronBufferGeometry":
              geometry2 = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
              break;
            case "ShapeGeometry":
            case "ShapeBufferGeometry":
              var geometryShapes = [];
              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              geometry2 = new Geometries[data.type](geometryShapes, data.curveSegments);
              break;
            case "ExtrudeGeometry":
            case "ExtrudeBufferGeometry":
              var geometryShapes = [];
              for (var j = 0, jl = data.shapes.length; j < jl; j++) {
                var shape = shapes[data.shapes[j]];
                geometryShapes.push(shape);
              }
              var extrudePath = data.options.extrudePath;
              if (extrudePath !== void 0) {
                data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
              }
              geometry2 = new Geometries[data.type](geometryShapes, data.options);
              break;
            case "BufferGeometry":
              geometry2 = bufferGeometryLoader.parse(data);
              break;
            case "Geometry":
              if ("THREE" in window && "LegacyJSONLoader" in THREE) {
                var geometryLoader = new THREE.LegacyJSONLoader();
                geometry2 = geometryLoader.parse(data, this.resourcePath).geometry;
              } else {
                console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
              }
              break;
            default:
              console.warn('THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"');
              continue;
          }
          geometry2.uuid = data.uuid;
          if (data.name !== void 0)
            geometry2.name = data.name;
          if (geometry2.isBufferGeometry === true && data.userData !== void 0)
            geometry2.userData = data.userData;
          geometries[data.uuid] = geometry2;
        }
      }
      return geometries;
    },
    parseMaterials: function(json, textures) {
      var cache = {};
      var materials = {};
      if (json !== void 0) {
        var loader = new MaterialLoader();
        loader.setTextures(textures);
        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];
          if (data.type === "MultiMaterial") {
            var array = [];
            for (var j = 0; j < data.materials.length; j++) {
              var material = data.materials[j];
              if (cache[material.uuid] === void 0) {
                cache[material.uuid] = loader.parse(material);
              }
              array.push(cache[material.uuid]);
            }
            materials[data.uuid] = array;
          } else {
            if (cache[data.uuid] === void 0) {
              cache[data.uuid] = loader.parse(data);
            }
            materials[data.uuid] = cache[data.uuid];
          }
        }
      }
      return materials;
    },
    parseAnimations: function(json) {
      var animations = [];
      for (var i = 0; i < json.length; i++) {
        var data = json[i];
        var clip = AnimationClip.parse(data);
        if (data.uuid !== void 0)
          clip.uuid = data.uuid;
        animations.push(clip);
      }
      return animations;
    },
    parseImages: function(json, onLoad) {
      var scope = this;
      var images = {};
      function loadImage(url2) {
        scope.manager.itemStart(url2);
        return loader.load(url2, function() {
          scope.manager.itemEnd(url2);
        }, void 0, function() {
          scope.manager.itemError(url2);
          scope.manager.itemEnd(url2);
        });
      }
      if (json !== void 0 && json.length > 0) {
        var manager = new LoadingManager(onLoad);
        var loader = new ImageLoader(manager);
        loader.setCrossOrigin(this.crossOrigin);
        for (var i = 0, il = json.length; i < il; i++) {
          var image = json[i];
          var url = image.url;
          if (Array.isArray(url)) {
            images[image.uuid] = [];
            for (var j = 0, jl = url.length; j < jl; j++) {
              var currentUrl = url[j];
              var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
              images[image.uuid].push(loadImage(path));
            }
          } else {
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url) ? image.url : scope.resourcePath + image.url;
            images[image.uuid] = loadImage(path);
          }
        }
      }
      return images;
    },
    parseTextures: function(json, images) {
      function parseConstant(value, type) {
        if (typeof value === "number")
          return value;
        console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
        return type[value];
      }
      var textures = {};
      if (json !== void 0) {
        for (var i = 0, l = json.length; i < l; i++) {
          var data = json[i];
          if (data.image === void 0) {
            console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
          }
          if (images[data.image] === void 0) {
            console.warn("THREE.ObjectLoader: Undefined image", data.image);
          }
          var texture;
          if (Array.isArray(images[data.image])) {
            texture = new CubeTexture(images[data.image]);
          } else {
            texture = new Texture(images[data.image]);
          }
          texture.needsUpdate = true;
          texture.uuid = data.uuid;
          if (data.name !== void 0)
            texture.name = data.name;
          if (data.mapping !== void 0)
            texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
          if (data.offset !== void 0)
            texture.offset.fromArray(data.offset);
          if (data.repeat !== void 0)
            texture.repeat.fromArray(data.repeat);
          if (data.center !== void 0)
            texture.center.fromArray(data.center);
          if (data.rotation !== void 0)
            texture.rotation = data.rotation;
          if (data.wrap !== void 0) {
            texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
            texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
          }
          if (data.format !== void 0)
            texture.format = data.format;
          if (data.type !== void 0)
            texture.type = data.type;
          if (data.encoding !== void 0)
            texture.encoding = data.encoding;
          if (data.minFilter !== void 0)
            texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
          if (data.magFilter !== void 0)
            texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
          if (data.anisotropy !== void 0)
            texture.anisotropy = data.anisotropy;
          if (data.flipY !== void 0)
            texture.flipY = data.flipY;
          if (data.premultiplyAlpha !== void 0)
            texture.premultiplyAlpha = data.premultiplyAlpha;
          if (data.unpackAlignment !== void 0)
            texture.unpackAlignment = data.unpackAlignment;
          textures[data.uuid] = texture;
        }
      }
      return textures;
    },
    parseObject: function(data, geometries, materials) {
      var object;
      function getGeometry(name) {
        if (geometries[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined geometry", name);
        }
        return geometries[name];
      }
      function getMaterial(name) {
        if (name === void 0)
          return void 0;
        if (Array.isArray(name)) {
          var array = [];
          for (var i2 = 0, l2 = name.length; i2 < l2; i2++) {
            var uuid = name[i2];
            if (materials[uuid] === void 0) {
              console.warn("THREE.ObjectLoader: Undefined material", uuid);
            }
            array.push(materials[uuid]);
          }
          return array;
        }
        if (materials[name] === void 0) {
          console.warn("THREE.ObjectLoader: Undefined material", name);
        }
        return materials[name];
      }
      switch (data.type) {
        case "Scene":
          object = new Scene();
          if (data.background !== void 0) {
            if (Number.isInteger(data.background)) {
              object.background = new Color(data.background);
            }
          }
          if (data.fog !== void 0) {
            if (data.fog.type === "Fog") {
              object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
            } else if (data.fog.type === "FogExp2") {
              object.fog = new FogExp2(data.fog.color, data.fog.density);
            }
          }
          break;
        case "PerspectiveCamera":
          object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
          if (data.focus !== void 0)
            object.focus = data.focus;
          if (data.zoom !== void 0)
            object.zoom = data.zoom;
          if (data.filmGauge !== void 0)
            object.filmGauge = data.filmGauge;
          if (data.filmOffset !== void 0)
            object.filmOffset = data.filmOffset;
          if (data.view !== void 0)
            object.view = Object.assign({}, data.view);
          break;
        case "OrthographicCamera":
          object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
          if (data.zoom !== void 0)
            object.zoom = data.zoom;
          if (data.view !== void 0)
            object.view = Object.assign({}, data.view);
          break;
        case "AmbientLight":
          object = new AmbientLight(data.color, data.intensity);
          break;
        case "DirectionalLight":
          object = new DirectionalLight(data.color, data.intensity);
          break;
        case "PointLight":
          object = new PointLight(data.color, data.intensity, data.distance, data.decay);
          break;
        case "RectAreaLight":
          object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
          break;
        case "SpotLight":
          object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
          break;
        case "HemisphereLight":
          object = new HemisphereLight(data.color, data.groundColor, data.intensity);
          break;
        case "SkinnedMesh":
          console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
        case "Mesh":
          var geometry2 = getGeometry(data.geometry);
          var material = getMaterial(data.material);
          if (geometry2.bones && geometry2.bones.length > 0) {
            object = new SkinnedMesh(geometry2, material);
          } else {
            object = new Mesh(geometry2, material);
          }
          if (data.drawMode !== void 0)
            object.setDrawMode(data.drawMode);
          break;
        case "LOD":
          object = new LOD();
          break;
        case "Line":
          object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
          break;
        case "LineLoop":
          object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "LineSegments":
          object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "PointCloud":
        case "Points":
          object = new Points(getGeometry(data.geometry), getMaterial(data.material));
          break;
        case "Sprite":
          object = new Sprite(getMaterial(data.material));
          break;
        case "Group":
          object = new Group();
          break;
        default:
          object = new Object3D();
      }
      object.uuid = data.uuid;
      if (data.name !== void 0)
        object.name = data.name;
      if (data.matrix !== void 0) {
        object.matrix.fromArray(data.matrix);
        if (data.matrixAutoUpdate !== void 0)
          object.matrixAutoUpdate = data.matrixAutoUpdate;
        if (object.matrixAutoUpdate)
          object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        if (data.position !== void 0)
          object.position.fromArray(data.position);
        if (data.rotation !== void 0)
          object.rotation.fromArray(data.rotation);
        if (data.quaternion !== void 0)
          object.quaternion.fromArray(data.quaternion);
        if (data.scale !== void 0)
          object.scale.fromArray(data.scale);
      }
      if (data.castShadow !== void 0)
        object.castShadow = data.castShadow;
      if (data.receiveShadow !== void 0)
        object.receiveShadow = data.receiveShadow;
      if (data.shadow) {
        if (data.shadow.bias !== void 0)
          object.shadow.bias = data.shadow.bias;
        if (data.shadow.radius !== void 0)
          object.shadow.radius = data.shadow.radius;
        if (data.shadow.mapSize !== void 0)
          object.shadow.mapSize.fromArray(data.shadow.mapSize);
        if (data.shadow.camera !== void 0)
          object.shadow.camera = this.parseObject(data.shadow.camera);
      }
      if (data.visible !== void 0)
        object.visible = data.visible;
      if (data.frustumCulled !== void 0)
        object.frustumCulled = data.frustumCulled;
      if (data.renderOrder !== void 0)
        object.renderOrder = data.renderOrder;
      if (data.userData !== void 0)
        object.userData = data.userData;
      if (data.layers !== void 0)
        object.layers.mask = data.layers;
      if (data.children !== void 0) {
        var children2 = data.children;
        for (var i = 0; i < children2.length; i++) {
          object.add(this.parseObject(children2[i], geometries, materials));
        }
      }
      if (data.type === "LOD") {
        var levels = data.levels;
        for (var l = 0; l < levels.length; l++) {
          var level = levels[l];
          var child = object.getObjectByProperty("uuid", level.object);
          if (child !== void 0) {
            object.addLevel(child, level.distance);
          }
        }
      }
      return object;
    }
  });
  var TEXTURE_MAPPING = {
    UVMapping,
    CubeReflectionMapping,
    CubeRefractionMapping,
    EquirectangularReflectionMapping,
    EquirectangularRefractionMapping,
    SphericalReflectionMapping,
    CubeUVReflectionMapping,
    CubeUVRefractionMapping
  };
  var TEXTURE_WRAPPING = {
    RepeatWrapping,
    ClampToEdgeWrapping,
    MirroredRepeatWrapping
  };
  var TEXTURE_FILTER = {
    NearestFilter,
    NearestMipMapNearestFilter,
    NearestMipMapLinearFilter,
    LinearFilter,
    LinearMipMapNearestFilter,
    LinearMipMapLinearFilter
  };
  function ImageBitmapLoader(manager) {
    if (typeof createImageBitmap === "undefined") {
      console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
    }
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.options = void 0;
  }
  ImageBitmapLoader.prototype = {
    constructor: ImageBitmapLoader,
    setOptions: function setOptions(options) {
      this.options = options;
      return this;
    },
    load: function(url, onLoad, onProgress, onError) {
      if (url === void 0)
        url = "";
      if (this.path !== void 0)
        url = this.path + url;
      url = this.manager.resolveURL(url);
      var scope = this;
      var cached = Cache.get(url);
      if (cached !== void 0) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad)
            onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
        return cached;
      }
      fetch(url).then(function(res) {
        return res.blob();
      }).then(function(blob) {
        if (scope.options === void 0) {
          return createImageBitmap(blob);
        } else {
          return createImageBitmap(blob, scope.options);
        }
      }).then(function(imageBitmap) {
        Cache.add(url, imageBitmap);
        if (onLoad)
          onLoad(imageBitmap);
        scope.manager.itemEnd(url);
      }).catch(function(e) {
        if (onError)
          onError(e);
        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      });
      scope.manager.itemStart(url);
    },
    setCrossOrigin: function() {
      return this;
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  };
  function ShapePath() {
    this.type = "ShapePath";
    this.color = new Color();
    this.subPaths = [];
    this.currentPath = null;
  }
  Object.assign(ShapePath.prototype, {
    moveTo: function(x, y) {
      this.currentPath = new Path();
      this.subPaths.push(this.currentPath);
      this.currentPath.moveTo(x, y);
    },
    lineTo: function(x, y) {
      this.currentPath.lineTo(x, y);
    },
    quadraticCurveTo: function(aCPx, aCPy, aX, aY) {
      this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
    },
    bezierCurveTo: function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
    },
    splineThru: function(pts) {
      this.currentPath.splineThru(pts);
    },
    toShapes: function(isCCW, noHoles) {
      function toShapesNoHoles(inSubpaths) {
        var shapes2 = [];
        for (var i2 = 0, l2 = inSubpaths.length; i2 < l2; i2++) {
          var tmpPath2 = inSubpaths[i2];
          var tmpShape2 = new Shape();
          tmpShape2.curves = tmpPath2.curves;
          shapes2.push(tmpShape2);
        }
        return shapes2;
      }
      function isPointInsidePolygon(inPt, inPolygon) {
        var polyLen = inPolygon.length;
        var inside = false;
        for (var p2 = polyLen - 1, q2 = 0; q2 < polyLen; p2 = q2++) {
          var edgeLowPt = inPolygon[p2];
          var edgeHighPt = inPolygon[q2];
          var edgeDx = edgeHighPt.x - edgeLowPt.x;
          var edgeDy = edgeHighPt.y - edgeLowPt.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLowPt = inPolygon[q2];
              edgeDx = -edgeDx;
              edgeHighPt = inPolygon[p2];
              edgeDy = -edgeDy;
            }
            if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)
              continue;
            if (inPt.y === edgeLowPt.y) {
              if (inPt.x === edgeLowPt.x)
                return true;
            } else {
              var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
              if (perpEdge === 0)
                return true;
              if (perpEdge < 0)
                continue;
              inside = !inside;
            }
          } else {
            if (inPt.y !== edgeLowPt.y)
              continue;
            if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
              return true;
          }
        }
        return inside;
      }
      var isClockWise = ShapeUtils.isClockWise;
      var subPaths = this.subPaths;
      if (subPaths.length === 0)
        return [];
      if (noHoles === true)
        return toShapesNoHoles(subPaths);
      var solid, tmpPath, tmpShape, shapes = [];
      if (subPaths.length === 1) {
        tmpPath = subPaths[0];
        tmpShape = new Shape();
        tmpShape.curves = tmpPath.curves;
        shapes.push(tmpShape);
        return shapes;
      }
      var holesFirst = !isClockWise(subPaths[0].getPoints());
      holesFirst = isCCW ? !holesFirst : holesFirst;
      var betterShapeHoles = [];
      var newShapes = [];
      var newShapeHoles = [];
      var mainIdx = 0;
      var tmpPoints;
      newShapes[mainIdx] = void 0;
      newShapeHoles[mainIdx] = [];
      for (var i = 0, l = subPaths.length; i < l; i++) {
        tmpPath = subPaths[i];
        tmpPoints = tmpPath.getPoints();
        solid = isClockWise(tmpPoints);
        solid = isCCW ? !solid : solid;
        if (solid) {
          if (!holesFirst && newShapes[mainIdx])
            mainIdx++;
          newShapes[mainIdx] = { s: new Shape(), p: tmpPoints };
          newShapes[mainIdx].s.curves = tmpPath.curves;
          if (holesFirst)
            mainIdx++;
          newShapeHoles[mainIdx] = [];
        } else {
          newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] });
        }
      }
      if (!newShapes[0])
        return toShapesNoHoles(subPaths);
      if (newShapes.length > 1) {
        var ambiguous = false;
        var toChange = [];
        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          betterShapeHoles[sIdx] = [];
        }
        for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
          var sho = newShapeHoles[sIdx];
          for (var hIdx = 0; hIdx < sho.length; hIdx++) {
            var ho = sho[hIdx];
            var hole_unassigned = true;
            for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
              if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                if (sIdx !== s2Idx)
                  toChange.push({ froms: sIdx, tos: s2Idx, hole: hIdx });
                if (hole_unassigned) {
                  hole_unassigned = false;
                  betterShapeHoles[s2Idx].push(ho);
                } else {
                  ambiguous = true;
                }
              }
            }
            if (hole_unassigned) {
              betterShapeHoles[sIdx].push(ho);
            }
          }
        }
        if (toChange.length > 0) {
          if (!ambiguous)
            newShapeHoles = betterShapeHoles;
        }
      }
      var tmpHoles;
      for (var i = 0, il = newShapes.length; i < il; i++) {
        tmpShape = newShapes[i].s;
        shapes.push(tmpShape);
        tmpHoles = newShapeHoles[i];
        for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
          tmpShape.holes.push(tmpHoles[j].h);
        }
      }
      return shapes;
    }
  });
  function Font(data) {
    this.type = "Font";
    this.data = data;
  }
  Object.assign(Font.prototype, {
    isFont: true,
    generateShapes: function(text2, size2) {
      if (size2 === void 0)
        size2 = 100;
      var shapes = [];
      var paths2 = createPaths(text2, size2, this.data);
      for (var p2 = 0, pl = paths2.length; p2 < pl; p2++) {
        Array.prototype.push.apply(shapes, paths2[p2].toShapes());
      }
      return shapes;
    }
  });
  function createPaths(text2, size2, data) {
    var chars = Array.from ? Array.from(text2) : String(text2).split("");
    var scale3 = size2 / data.resolution;
    var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale3;
    var paths2 = [];
    var offsetX = 0, offsetY = 0;
    for (var i = 0; i < chars.length; i++) {
      var char = chars[i];
      if (char === "\n") {
        offsetX = 0;
        offsetY -= line_height;
      } else {
        var ret = createPath(char, scale3, offsetX, offsetY, data);
        offsetX += ret.offsetX;
        paths2.push(ret.path);
      }
    }
    return paths2;
  }
  function createPath(char, scale3, offsetX, offsetY, data) {
    var glyph = data.glyphs[char] || data.glyphs["?"];
    if (!glyph)
      return;
    var path = new ShapePath();
    var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
    if (glyph.o) {
      var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
      for (var i = 0, l = outline.length; i < l; ) {
        var action = outline[i++];
        switch (action) {
          case "m":
            x = outline[i++] * scale3 + offsetX;
            y = outline[i++] * scale3 + offsetY;
            path.moveTo(x, y);
            break;
          case "l":
            x = outline[i++] * scale3 + offsetX;
            y = outline[i++] * scale3 + offsetY;
            path.lineTo(x, y);
            break;
          case "q":
            cpx = outline[i++] * scale3 + offsetX;
            cpy = outline[i++] * scale3 + offsetY;
            cpx1 = outline[i++] * scale3 + offsetX;
            cpy1 = outline[i++] * scale3 + offsetY;
            path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
            break;
          case "b":
            cpx = outline[i++] * scale3 + offsetX;
            cpy = outline[i++] * scale3 + offsetY;
            cpx1 = outline[i++] * scale3 + offsetX;
            cpy1 = outline[i++] * scale3 + offsetY;
            cpx2 = outline[i++] * scale3 + offsetX;
            cpy2 = outline[i++] * scale3 + offsetY;
            path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
            break;
        }
      }
    }
    return { offsetX: glyph.ha * scale3, path };
  }
  function FontLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(FontLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.load(url, function(text2) {
        var json;
        try {
          json = JSON.parse(text2);
        } catch (e) {
          console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
          json = JSON.parse(text2.substring(65, text2.length - 2));
        }
        var font = scope.parse(json);
        if (onLoad)
          onLoad(font);
      }, onProgress, onError);
    },
    parse: function(json) {
      return new Font(json);
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function Loader() {
  }
  Loader.Handlers = {
    handlers: [],
    add: function(regex, loader) {
      this.handlers.push(regex, loader);
    },
    get: function(file) {
      var handlers = this.handlers;
      for (var i = 0, l = handlers.length; i < l; i += 2) {
        var regex = handlers[i];
        var loader = handlers[i + 1];
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    }
  };
  Object.assign(Loader.prototype, {
    crossOrigin: "anonymous",
    onLoadStart: function() {
    },
    onLoadProgress: function() {
    },
    onLoadComplete: function() {
    },
    initMaterials: function(materials, texturePath, crossOrigin) {
      var array = [];
      for (var i = 0; i < materials.length; ++i) {
        array[i] = this.createMaterial(materials[i], texturePath, crossOrigin);
      }
      return array;
    },
    createMaterial: function() {
      var BlendingMode = {
        NoBlending,
        NormalBlending,
        AdditiveBlending,
        SubtractiveBlending,
        MultiplyBlending,
        CustomBlending
      };
      var color = new Color();
      var textureLoader = new TextureLoader();
      var materialLoader = new MaterialLoader();
      return function createMaterial(m, texturePath, crossOrigin) {
        var textures = {};
        function loadTexture(path, repeat, offset, wrap, anisotropy) {
          var fullPath = texturePath + path;
          var loader = Loader.Handlers.get(fullPath);
          var texture;
          if (loader !== null) {
            texture = loader.load(fullPath);
          } else {
            textureLoader.setCrossOrigin(crossOrigin);
            texture = textureLoader.load(fullPath);
          }
          if (repeat !== void 0) {
            texture.repeat.fromArray(repeat);
            if (repeat[0] !== 1)
              texture.wrapS = RepeatWrapping;
            if (repeat[1] !== 1)
              texture.wrapT = RepeatWrapping;
          }
          if (offset !== void 0) {
            texture.offset.fromArray(offset);
          }
          if (wrap !== void 0) {
            if (wrap[0] === "repeat")
              texture.wrapS = RepeatWrapping;
            if (wrap[0] === "mirror")
              texture.wrapS = MirroredRepeatWrapping;
            if (wrap[1] === "repeat")
              texture.wrapT = RepeatWrapping;
            if (wrap[1] === "mirror")
              texture.wrapT = MirroredRepeatWrapping;
          }
          if (anisotropy !== void 0) {
            texture.anisotropy = anisotropy;
          }
          var uuid = _Math.generateUUID();
          textures[uuid] = texture;
          return uuid;
        }
        var json = {
          uuid: _Math.generateUUID(),
          type: "MeshLambertMaterial"
        };
        for (var name in m) {
          var value = m[name];
          switch (name) {
            case "DbgColor":
            case "DbgIndex":
            case "opticalDensity":
            case "illumination":
              break;
            case "DbgName":
              json.name = value;
              break;
            case "blending":
              json.blending = BlendingMode[value];
              break;
            case "colorAmbient":
            case "mapAmbient":
              console.warn("THREE.Loader.createMaterial:", name, "is no longer supported.");
              break;
            case "colorDiffuse":
              json.color = color.fromArray(value).getHex();
              break;
            case "colorSpecular":
              json.specular = color.fromArray(value).getHex();
              break;
            case "colorEmissive":
              json.emissive = color.fromArray(value).getHex();
              break;
            case "specularCoef":
              json.shininess = value;
              break;
            case "shading":
              if (value.toLowerCase() === "basic")
                json.type = "MeshBasicMaterial";
              if (value.toLowerCase() === "phong")
                json.type = "MeshPhongMaterial";
              if (value.toLowerCase() === "standard")
                json.type = "MeshStandardMaterial";
              break;
            case "mapDiffuse":
              json.map = loadTexture(value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy);
              break;
            case "mapDiffuseRepeat":
            case "mapDiffuseOffset":
            case "mapDiffuseWrap":
            case "mapDiffuseAnisotropy":
              break;
            case "mapEmissive":
              json.emissiveMap = loadTexture(value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy);
              break;
            case "mapEmissiveRepeat":
            case "mapEmissiveOffset":
            case "mapEmissiveWrap":
            case "mapEmissiveAnisotropy":
              break;
            case "mapLight":
              json.lightMap = loadTexture(value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy);
              break;
            case "mapLightRepeat":
            case "mapLightOffset":
            case "mapLightWrap":
            case "mapLightAnisotropy":
              break;
            case "mapAO":
              json.aoMap = loadTexture(value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy);
              break;
            case "mapAORepeat":
            case "mapAOOffset":
            case "mapAOWrap":
            case "mapAOAnisotropy":
              break;
            case "mapBump":
              json.bumpMap = loadTexture(value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy);
              break;
            case "mapBumpScale":
              json.bumpScale = value;
              break;
            case "mapBumpRepeat":
            case "mapBumpOffset":
            case "mapBumpWrap":
            case "mapBumpAnisotropy":
              break;
            case "mapNormal":
              json.normalMap = loadTexture(value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy);
              break;
            case "mapNormalFactor":
              json.normalScale = value;
              break;
            case "mapNormalRepeat":
            case "mapNormalOffset":
            case "mapNormalWrap":
            case "mapNormalAnisotropy":
              break;
            case "mapSpecular":
              json.specularMap = loadTexture(value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy);
              break;
            case "mapSpecularRepeat":
            case "mapSpecularOffset":
            case "mapSpecularWrap":
            case "mapSpecularAnisotropy":
              break;
            case "mapMetalness":
              json.metalnessMap = loadTexture(value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy);
              break;
            case "mapMetalnessRepeat":
            case "mapMetalnessOffset":
            case "mapMetalnessWrap":
            case "mapMetalnessAnisotropy":
              break;
            case "mapRoughness":
              json.roughnessMap = loadTexture(value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy);
              break;
            case "mapRoughnessRepeat":
            case "mapRoughnessOffset":
            case "mapRoughnessWrap":
            case "mapRoughnessAnisotropy":
              break;
            case "mapAlpha":
              json.alphaMap = loadTexture(value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy);
              break;
            case "mapAlphaRepeat":
            case "mapAlphaOffset":
            case "mapAlphaWrap":
            case "mapAlphaAnisotropy":
              break;
            case "flipSided":
              json.side = BackSide;
              break;
            case "doubleSided":
              json.side = DoubleSide;
              break;
            case "transparency":
              console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity");
              json.opacity = value;
              break;
            case "depthTest":
            case "depthWrite":
            case "colorWrite":
            case "opacity":
            case "reflectivity":
            case "transparent":
            case "visible":
            case "wireframe":
              json[name] = value;
              break;
            case "vertexColors":
              if (value === true)
                json.vertexColors = VertexColors;
              if (value === "face")
                json.vertexColors = FaceColors;
              break;
            default:
              console.error("THREE.Loader.createMaterial: Unsupported", name, value);
              break;
          }
        }
        if (json.type === "MeshBasicMaterial")
          delete json.emissive;
        if (json.type !== "MeshPhongMaterial")
          delete json.specular;
        if (json.opacity < 1)
          json.transparent = true;
        materialLoader.setTextures(textures);
        return materialLoader.parse(json);
      };
    }()
  });
  var context;
  var AudioContext = {
    getContext: function() {
      if (context === void 0) {
        context = new (window.AudioContext || window.webkitAudioContext)();
      }
      return context;
    },
    setContext: function(value) {
      context = value;
    }
  };
  function AudioLoader(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
  }
  Object.assign(AudioLoader.prototype, {
    load: function(url, onLoad, onProgress, onError) {
      var loader = new FileLoader(this.manager);
      loader.setResponseType("arraybuffer");
      loader.setPath(this.path);
      loader.load(url, function(buffer) {
        var bufferCopy = buffer.slice(0);
        var context2 = AudioContext.getContext();
        context2.decodeAudioData(bufferCopy, function(audioBuffer) {
          onLoad(audioBuffer);
        });
      }, onProgress, onError);
    },
    setPath: function(value) {
      this.path = value;
      return this;
    }
  });
  function StereoCamera() {
    this.type = "StereoCamera";
    this.aspect = 1;
    this.eyeSep = 0.064;
    this.cameraL = new PerspectiveCamera();
    this.cameraL.layers.enable(1);
    this.cameraL.matrixAutoUpdate = false;
    this.cameraR = new PerspectiveCamera();
    this.cameraR.layers.enable(2);
    this.cameraR.matrixAutoUpdate = false;
  }
  Object.assign(StereoCamera.prototype, {
    update: function() {
      var instance18, focus, fov, aspect, near, far, zoom, eyeSep;
      var eyeRight = new Matrix4();
      var eyeLeft = new Matrix4();
      return function update3(camera2) {
        var needsUpdate = instance18 !== this || focus !== camera2.focus || fov !== camera2.fov || aspect !== camera2.aspect * this.aspect || near !== camera2.near || far !== camera2.far || zoom !== camera2.zoom || eyeSep !== this.eyeSep;
        if (needsUpdate) {
          instance18 = this;
          focus = camera2.focus;
          fov = camera2.fov;
          aspect = camera2.aspect * this.aspect;
          near = camera2.near;
          far = camera2.far;
          zoom = camera2.zoom;
          var projectionMatrix = camera2.projectionMatrix.clone();
          eyeSep = this.eyeSep / 2;
          var eyeSepOnProjection = eyeSep * near / focus;
          var ymax = near * Math.tan(_Math.DEG2RAD * fov * 0.5) / zoom;
          var xmin, xmax;
          eyeLeft.elements[12] = -eyeSep;
          eyeRight.elements[12] = eyeSep;
          xmin = -ymax * aspect + eyeSepOnProjection;
          xmax = ymax * aspect + eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(projectionMatrix);
          xmin = -ymax * aspect - eyeSepOnProjection;
          xmax = ymax * aspect - eyeSepOnProjection;
          projectionMatrix.elements[0] = 2 * near / (xmax - xmin);
          projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera2.matrixWorld).multiply(eyeLeft);
        this.cameraR.matrixWorld.copy(camera2.matrixWorld).multiply(eyeRight);
      };
    }()
  });
  function CubeCamera(near, far, cubeResolution, options) {
    Object3D.call(this);
    this.type = "CubeCamera";
    var fov = 90, aspect = 1;
    var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.up.set(0, -1, 0);
    cameraPX.lookAt(new Vector3(1, 0, 0));
    this.add(cameraPX);
    var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.up.set(0, -1, 0);
    cameraNX.lookAt(new Vector3(-1, 0, 0));
    this.add(cameraNX);
    var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.up.set(0, 0, 1);
    cameraPY.lookAt(new Vector3(0, 1, 0));
    this.add(cameraPY);
    var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.up.set(0, 0, -1);
    cameraNY.lookAt(new Vector3(0, -1, 0));
    this.add(cameraNY);
    var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.up.set(0, -1, 0);
    cameraPZ.lookAt(new Vector3(0, 0, 1));
    this.add(cameraPZ);
    var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.up.set(0, -1, 0);
    cameraNZ.lookAt(new Vector3(0, 0, -1));
    this.add(cameraNZ);
    options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
    this.renderTarget = new WebGLRenderTargetCube(cubeResolution, cubeResolution, options);
    this.renderTarget.texture.name = "CubeCamera";
    this.update = function(renderer, scene2) {
      if (this.parent === null)
        this.updateMatrixWorld();
      var currentRenderTarget = renderer.getRenderTarget();
      var renderTarget = this.renderTarget;
      var generateMipmaps = renderTarget.texture.generateMipmaps;
      renderTarget.texture.generateMipmaps = false;
      renderer.setRenderTarget(renderTarget, 0);
      renderer.render(scene2, cameraPX);
      renderer.setRenderTarget(renderTarget, 1);
      renderer.render(scene2, cameraNX);
      renderer.setRenderTarget(renderTarget, 2);
      renderer.render(scene2, cameraPY);
      renderer.setRenderTarget(renderTarget, 3);
      renderer.render(scene2, cameraNY);
      renderer.setRenderTarget(renderTarget, 4);
      renderer.render(scene2, cameraPZ);
      renderTarget.texture.generateMipmaps = generateMipmaps;
      renderer.setRenderTarget(renderTarget, 5);
      renderer.render(scene2, cameraNZ);
      renderer.setRenderTarget(currentRenderTarget);
    };
    this.clear = function(renderer, color, depth, stencil) {
      var currentRenderTarget = renderer.getRenderTarget();
      var renderTarget = this.renderTarget;
      for (var i = 0; i < 6; i++) {
        renderer.setRenderTarget(renderTarget, i);
        renderer.clear(color, depth, stencil);
      }
      renderer.setRenderTarget(currentRenderTarget);
    };
  }
  CubeCamera.prototype = Object.create(Object3D.prototype);
  CubeCamera.prototype.constructor = CubeCamera;
  function Clock(autoStart) {
    this.autoStart = autoStart !== void 0 ? autoStart : true;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  Object.assign(Clock.prototype, {
    start: function() {
      this.startTime = (typeof performance === "undefined" ? Date : performance).now();
      this.oldTime = this.startTime;
      this.elapsedTime = 0;
      this.running = true;
    },
    stop: function() {
      this.getElapsedTime();
      this.running = false;
      this.autoStart = false;
    },
    getElapsedTime: function() {
      this.getDelta();
      return this.elapsedTime;
    },
    getDelta: function() {
      var diff = 0;
      if (this.autoStart && !this.running) {
        this.start();
        return 0;
      }
      if (this.running) {
        var newTime = (typeof performance === "undefined" ? Date : performance).now();
        diff = (newTime - this.oldTime) / 1e3;
        this.oldTime = newTime;
        this.elapsedTime += diff;
      }
      return diff;
    }
  });
  function AudioListener() {
    Object3D.call(this);
    this.type = "AudioListener";
    this.context = AudioContext.getContext();
    this.gain = this.context.createGain();
    this.gain.connect(this.context.destination);
    this.filter = null;
    this.timeDelta = 0;
  }
  AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: AudioListener,
    getInput: function() {
      return this.gain;
    },
    removeFilter: function() {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
        this.gain.connect(this.context.destination);
        this.filter = null;
      }
      return this;
    },
    getFilter: function() {
      return this.filter;
    },
    setFilter: function(value) {
      if (this.filter !== null) {
        this.gain.disconnect(this.filter);
        this.filter.disconnect(this.context.destination);
      } else {
        this.gain.disconnect(this.context.destination);
      }
      this.filter = value;
      this.gain.connect(this.filter);
      this.filter.connect(this.context.destination);
      return this;
    },
    getMasterVolume: function() {
      return this.gain.gain.value;
    },
    setMasterVolume: function(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    },
    updateMatrixWorld: function() {
      var position = new Vector3();
      var quaternion = new Quaternion();
      var scale3 = new Vector3();
      var orientation = new Vector3();
      var clock = new Clock();
      return function updateMatrixWorld(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        var listener = this.context.listener;
        var up = this.up;
        this.timeDelta = clock.getDelta();
        this.matrixWorld.decompose(position, quaternion, scale3);
        orientation.set(0, 0, -1).applyQuaternion(quaternion);
        if (listener.positionX) {
          var endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(position.x, endTime);
          listener.positionY.linearRampToValueAtTime(position.y, endTime);
          listener.positionZ.linearRampToValueAtTime(position.z, endTime);
          listener.forwardX.linearRampToValueAtTime(orientation.x, endTime);
          listener.forwardY.linearRampToValueAtTime(orientation.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(orientation.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(position.x, position.y, position.z);
          listener.setOrientation(orientation.x, orientation.y, orientation.z, up.x, up.y, up.z);
        }
      };
    }()
  });
  function Audio(listener) {
    Object3D.call(this);
    this.type = "Audio";
    this.listener = listener;
    this.context = listener.context;
    this.gain = this.context.createGain();
    this.gain.connect(listener.getInput());
    this.autoplay = false;
    this.buffer = null;
    this.detune = 0;
    this.loop = false;
    this.startTime = 0;
    this.offset = 0;
    this.playbackRate = 1;
    this.isPlaying = false;
    this.hasPlaybackControl = true;
    this.sourceType = "empty";
    this.filters = [];
  }
  Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
    constructor: Audio,
    getOutput: function() {
      return this.gain;
    },
    setNodeSource: function(audioNode) {
      this.hasPlaybackControl = false;
      this.sourceType = "audioNode";
      this.source = audioNode;
      this.connect();
      return this;
    },
    setMediaElementSource: function(mediaElement) {
      this.hasPlaybackControl = false;
      this.sourceType = "mediaNode";
      this.source = this.context.createMediaElementSource(mediaElement);
      this.connect();
      return this;
    },
    setBuffer: function(audioBuffer) {
      this.buffer = audioBuffer;
      this.sourceType = "buffer";
      if (this.autoplay)
        this.play();
      return this;
    },
    play: function() {
      if (this.isPlaying === true) {
        console.warn("THREE.Audio: Audio is already playing.");
        return;
      }
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      var source = this.context.createBufferSource();
      source.buffer = this.buffer;
      source.loop = this.loop;
      source.onended = this.onEnded.bind(this);
      this.startTime = this.context.currentTime;
      source.start(this.startTime, this.offset);
      this.isPlaying = true;
      this.source = source;
      this.setDetune(this.detune);
      this.setPlaybackRate(this.playbackRate);
      return this.connect();
    },
    pause: function() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      if (this.isPlaying === true) {
        this.source.stop();
        this.source.onended = null;
        this.offset += (this.context.currentTime - this.startTime) * this.playbackRate;
        this.isPlaying = false;
      }
      return this;
    },
    stop: function() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.source.stop();
      this.source.onended = null;
      this.offset = 0;
      this.isPlaying = false;
      return this;
    },
    connect: function() {
      if (this.filters.length > 0) {
        this.source.connect(this.filters[0]);
        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].connect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].connect(this.getOutput());
      } else {
        this.source.connect(this.getOutput());
      }
      return this;
    },
    disconnect: function() {
      if (this.filters.length > 0) {
        this.source.disconnect(this.filters[0]);
        for (var i = 1, l = this.filters.length; i < l; i++) {
          this.filters[i - 1].disconnect(this.filters[i]);
        }
        this.filters[this.filters.length - 1].disconnect(this.getOutput());
      } else {
        this.source.disconnect(this.getOutput());
      }
      return this;
    },
    getFilters: function() {
      return this.filters;
    },
    setFilters: function(value) {
      if (!value)
        value = [];
      if (this.isPlaying === true) {
        this.disconnect();
        this.filters = value;
        this.connect();
      } else {
        this.filters = value;
      }
      return this;
    },
    setDetune: function(value) {
      this.detune = value;
      if (this.source.detune === void 0)
        return;
      if (this.isPlaying === true) {
        this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
      }
      return this;
    },
    getDetune: function() {
      return this.detune;
    },
    getFilter: function() {
      return this.getFilters()[0];
    },
    setFilter: function(filter) {
      return this.setFilters(filter ? [filter] : []);
    },
    setPlaybackRate: function(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.playbackRate = value;
      if (this.isPlaying === true) {
        this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
      }
      return this;
    },
    getPlaybackRate: function() {
      return this.playbackRate;
    },
    onEnded: function() {
      this.isPlaying = false;
    },
    getLoop: function() {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return false;
      }
      return this.loop;
    },
    setLoop: function(value) {
      if (this.hasPlaybackControl === false) {
        console.warn("THREE.Audio: this Audio has no playback control.");
        return;
      }
      this.loop = value;
      if (this.isPlaying === true) {
        this.source.loop = this.loop;
      }
      return this;
    },
    getVolume: function() {
      return this.gain.gain.value;
    },
    setVolume: function(value) {
      this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
      return this;
    }
  });
  function PositionalAudio(listener) {
    Audio.call(this, listener);
    this.panner = this.context.createPanner();
    this.panner.connect(this.gain);
  }
  PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
    constructor: PositionalAudio,
    getOutput: function() {
      return this.panner;
    },
    getRefDistance: function() {
      return this.panner.refDistance;
    },
    setRefDistance: function(value) {
      this.panner.refDistance = value;
      return this;
    },
    getRolloffFactor: function() {
      return this.panner.rolloffFactor;
    },
    setRolloffFactor: function(value) {
      this.panner.rolloffFactor = value;
      return this;
    },
    getDistanceModel: function() {
      return this.panner.distanceModel;
    },
    setDistanceModel: function(value) {
      this.panner.distanceModel = value;
      return this;
    },
    getMaxDistance: function() {
      return this.panner.maxDistance;
    },
    setMaxDistance: function(value) {
      this.panner.maxDistance = value;
      return this;
    },
    setDirectionalCone: function(coneInnerAngle, coneOuterAngle, coneOuterGain) {
      this.panner.coneInnerAngle = coneInnerAngle;
      this.panner.coneOuterAngle = coneOuterAngle;
      this.panner.coneOuterGain = coneOuterGain;
      return this;
    },
    updateMatrixWorld: function() {
      var position = new Vector3();
      var quaternion = new Quaternion();
      var scale3 = new Vector3();
      var orientation = new Vector3();
      return function updateMatrixWorld(force) {
        Object3D.prototype.updateMatrixWorld.call(this, force);
        if (this.hasPlaybackControl === true && this.isPlaying === false)
          return;
        this.matrixWorld.decompose(position, quaternion, scale3);
        orientation.set(0, 0, 1).applyQuaternion(quaternion);
        var panner = this.panner;
        if (panner.positionX) {
          var endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(position.x, endTime);
          panner.positionY.linearRampToValueAtTime(position.y, endTime);
          panner.positionZ.linearRampToValueAtTime(position.z, endTime);
          panner.orientationX.linearRampToValueAtTime(orientation.x, endTime);
          panner.orientationY.linearRampToValueAtTime(orientation.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(orientation.z, endTime);
        } else {
          panner.setPosition(position.x, position.y, position.z);
          panner.setOrientation(orientation.x, orientation.y, orientation.z);
        }
      };
    }()
  });
  function AudioAnalyser(audio, fftSize) {
    this.analyser = audio.context.createAnalyser();
    this.analyser.fftSize = fftSize !== void 0 ? fftSize : 2048;
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    audio.getOutput().connect(this.analyser);
  }
  Object.assign(AudioAnalyser.prototype, {
    getFrequencyData: function() {
      this.analyser.getByteFrequencyData(this.data);
      return this.data;
    },
    getAverageFrequency: function() {
      var value = 0, data = this.getFrequencyData();
      for (var i = 0; i < data.length; i++) {
        value += data[i];
      }
      return value / data.length;
    }
  });
  function PropertyMixer(binding, typeName, valueSize) {
    this.binding = binding;
    this.valueSize = valueSize;
    var bufferType = Float64Array, mixFunction;
    switch (typeName) {
      case "quaternion":
        mixFunction = this._slerp;
        break;
      case "string":
      case "bool":
        bufferType = Array;
        mixFunction = this._select;
        break;
      default:
        mixFunction = this._lerp;
    }
    this.buffer = new bufferType(valueSize * 4);
    this._mixBufferRegion = mixFunction;
    this.cumulativeWeight = 0;
    this.useCount = 0;
    this.referenceCount = 0;
  }
  Object.assign(PropertyMixer.prototype, {
    accumulate: function(accuIndex, weight) {
      var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
      if (currentWeight === 0) {
        for (var i = 0; i !== stride; ++i) {
          buffer[offset + i] = buffer[i];
        }
        currentWeight = weight;
      } else {
        currentWeight += weight;
        var mix = weight / currentWeight;
        this._mixBufferRegion(buffer, offset, 0, mix, stride);
      }
      this.cumulativeWeight = currentWeight;
    },
    apply: function(accuIndex) {
      var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
      this.cumulativeWeight = 0;
      if (weight < 1) {
        var originalValueOffset = stride * 3;
        this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
      }
      for (var i = stride, e = stride + stride; i !== e; ++i) {
        if (buffer[i] !== buffer[i + stride]) {
          binding.setValue(buffer, offset);
          break;
        }
      }
    },
    saveOriginalState: function() {
      var binding = this.binding;
      var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
      binding.getValue(buffer, originalValueOffset);
      for (var i = stride, e = originalValueOffset; i !== e; ++i) {
        buffer[i] = buffer[originalValueOffset + i % stride];
      }
      this.cumulativeWeight = 0;
    },
    restoreOriginalState: function() {
      var originalValueOffset = this.valueSize * 3;
      this.binding.setValue(this.buffer, originalValueOffset);
    },
    _select: function(buffer, dstOffset, srcOffset, t, stride) {
      if (t >= 0.5) {
        for (var i = 0; i !== stride; ++i) {
          buffer[dstOffset + i] = buffer[srcOffset + i];
        }
      }
    },
    _slerp: function(buffer, dstOffset, srcOffset, t) {
      Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
    },
    _lerp: function(buffer, dstOffset, srcOffset, t, stride) {
      var s2 = 1 - t;
      for (var i = 0; i !== stride; ++i) {
        var j = dstOffset + i;
        buffer[j] = buffer[j] * s2 + buffer[srcOffset + i] * t;
      }
    }
  });
  var RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
  function Composite(targetGroup, path, optionalParsedPath) {
    var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  Object.assign(Composite.prototype, {
    getValue: function(array, offset) {
      this.bind();
      var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
      if (binding !== void 0)
        binding.getValue(array, offset);
    },
    setValue: function(array, offset) {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].setValue(array, offset);
      }
    },
    bind: function() {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].bind();
      }
    },
    unbind: function() {
      var bindings = this._bindings;
      for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
        bindings[i].unbind();
      }
    }
  });
  function PropertyBinding(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
    this.rootNode = rootNode;
  }
  Object.assign(PropertyBinding, {
    Composite,
    create: function(root, path, parsedPath) {
      if (!(root && root.isAnimationObjectGroup)) {
        return new PropertyBinding(root, path, parsedPath);
      } else {
        return new PropertyBinding.Composite(root, path, parsedPath);
      }
    },
    sanitizeNodeName: function() {
      var reservedRe = new RegExp("[" + RESERVED_CHARS_RE + "]", "g");
      return function sanitizeNodeName(name) {
        return name.replace(/\s/g, "_").replace(reservedRe, "");
      };
    }(),
    parseTrackName: function() {
      var wordChar = "[^" + RESERVED_CHARS_RE + "]";
      var wordCharOrDot = "[^" + RESERVED_CHARS_RE.replace("\\.", "") + "]";
      var directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", wordChar);
      var nodeRe = /(WCOD+)?/.source.replace("WCOD", wordCharOrDot);
      var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", wordChar);
      var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", wordChar);
      var trackRe = new RegExp("^" + directoryRe + nodeRe + objectRe + propertyRe + "$");
      var supportedObjectNames = ["material", "materials", "bones"];
      return function parseTrackName(trackName) {
        var matches = trackRe.exec(trackName);
        if (!matches) {
          throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
        }
        var results = {
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          propertyIndex: matches[6]
        };
        var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
        if (lastDot !== void 0 && lastDot !== -1) {
          var objectName = results.nodeName.substring(lastDot + 1);
          if (supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
        }
        return results;
      };
    }(),
    findNode: function(root, nodeName) {
      if (!nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
        return root;
      }
      if (root.skeleton) {
        var bone = root.skeleton.getBoneByName(nodeName);
        if (bone !== void 0) {
          return bone;
        }
      }
      if (root.children) {
        var searchNodeSubtree = function(children2) {
          for (var i = 0; i < children2.length; i++) {
            var childNode = children2[i];
            if (childNode.name === nodeName || childNode.uuid === nodeName) {
              return childNode;
            }
            var result = searchNodeSubtree(childNode.children);
            if (result)
              return result;
          }
          return null;
        };
        var subTreeNode = searchNodeSubtree(root.children);
        if (subTreeNode) {
          return subTreeNode;
        }
      }
      return null;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unavailable: function() {
    },
    _setValue_unavailable: function() {
    },
    BindingType: {
      Direct: 0,
      EntireArray: 1,
      ArrayElement: 2,
      HasFromToArray: 3
    },
    Versioning: {
      None: 0,
      NeedsUpdate: 1,
      MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [
      function getValue_direct(buffer, offset) {
        buffer[offset] = this.node[this.propertyName];
      },
      function getValue_array(buffer, offset) {
        var source = this.resolvedProperty;
        for (var i = 0, n = source.length; i !== n; ++i) {
          buffer[offset++] = source[i];
        }
      },
      function getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      },
      function getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }
    ],
    SetterByBindingTypeAndVersioning: [
      [
        function setValue_direct(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
        },
        function setValue_direct_setNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.targetObject[this.propertyName] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_array(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
        },
        function setValue_array_setNeedsUpdate(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.needsUpdate = true;
        },
        function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
          var dest = this.resolvedProperty;
          for (var i = 0, n = dest.length; i !== n; ++i) {
            dest[i] = buffer[offset++];
          }
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_arrayElement(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
        },
        function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.needsUpdate = true;
        },
        function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty[this.propertyIndex] = buffer[offset];
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ],
      [
        function setValue_fromArray(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
        },
        function setValue_fromArray_setNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.needsUpdate = true;
        },
        function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
          this.resolvedProperty.fromArray(buffer, offset);
          this.targetObject.matrixWorldNeedsUpdate = true;
        }
      ]
    ],
    getValue: function getValue_unbound(targetArray, offset) {
      this.bind();
      this.getValue(targetArray, offset);
    },
    setValue: function getValue_unbound2(sourceArray, offset) {
      this.bind();
      this.setValue(sourceArray, offset);
    },
    bind: function() {
      var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
      if (!targetObject) {
        targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
        this.node = targetObject;
      }
      this.getValue = this._getValue_unavailable;
      this.setValue = this._setValue_unavailable;
      if (!targetObject) {
        console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
        return;
      }
      if (objectName) {
        var objectIndex = parsedPath.objectIndex;
        switch (objectName) {
          case "materials":
            if (!targetObject.material) {
              console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
              return;
            }
            if (!targetObject.material.materials) {
              console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
              return;
            }
            targetObject = targetObject.material.materials;
            break;
          case "bones":
            if (!targetObject.skeleton) {
              console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
              return;
            }
            targetObject = targetObject.skeleton.bones;
            for (var i = 0; i < targetObject.length; i++) {
              if (targetObject[i].name === objectIndex) {
                objectIndex = i;
                break;
              }
            }
            break;
          default:
            if (targetObject[objectName] === void 0) {
              console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
              return;
            }
            targetObject = targetObject[objectName];
        }
        if (objectIndex !== void 0) {
          if (targetObject[objectIndex] === void 0) {
            console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
            return;
          }
          targetObject = targetObject[objectIndex];
        }
      }
      var nodeProperty = targetObject[propertyName];
      if (nodeProperty === void 0) {
        var nodeName = parsedPath.nodeName;
        console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
        return;
      }
      var versioning = this.Versioning.None;
      this.targetObject = targetObject;
      if (targetObject.needsUpdate !== void 0) {
        versioning = this.Versioning.NeedsUpdate;
      } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
        versioning = this.Versioning.MatrixWorldNeedsUpdate;
      }
      var bindingType = this.BindingType.Direct;
      if (propertyIndex !== void 0) {
        if (propertyName === "morphTargetInfluences") {
          if (!targetObject.geometry) {
            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
            return;
          }
          if (targetObject.geometry.isBufferGeometry) {
            if (!targetObject.geometry.morphAttributes) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
              return;
            }
            for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
              if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
                propertyIndex = i;
                break;
              }
            }
          } else {
            if (!targetObject.geometry.morphTargets) {
              console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
              return;
            }
            for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
              if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
                propertyIndex = i;
                break;
              }
            }
          }
        }
        bindingType = this.BindingType.ArrayElement;
        this.resolvedProperty = nodeProperty;
        this.propertyIndex = propertyIndex;
      } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
        bindingType = this.BindingType.HasFromToArray;
        this.resolvedProperty = nodeProperty;
      } else if (Array.isArray(nodeProperty)) {
        bindingType = this.BindingType.EntireArray;
        this.resolvedProperty = nodeProperty;
      } else {
        this.propertyName = propertyName;
      }
      this.getValue = this.GetterByBindingType[bindingType];
      this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
    },
    unbind: function() {
      this.node = null;
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
  });
  Object.assign(PropertyBinding.prototype, {
    _getValue_unbound: PropertyBinding.prototype.getValue,
    _setValue_unbound: PropertyBinding.prototype.setValue
  });
  function AnimationObjectGroup() {
    this.uuid = _Math.generateUUID();
    this._objects = Array.prototype.slice.call(arguments);
    this.nCachedObjects_ = 0;
    var indices = {};
    this._indicesByUUID = indices;
    for (var i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i;
    }
    this._paths = [];
    this._parsedPaths = [];
    this._bindings = [];
    this._bindingsIndicesByPath = {};
    var scope = this;
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length;
        },
        get inUse() {
          return this.total - scope.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return scope._bindings.length;
      }
    };
  }
  Object.assign(AnimationObjectGroup.prototype, {
    isAnimationObjectGroup: true,
    add: function() {
      var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths2 = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = void 0;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index === void 0) {
          index = nObjects++;
          indicesByUUID[uuid] = index;
          objects.push(object);
          for (var j = 0, m = nBindings; j !== m; ++j) {
            bindings[j].push(new PropertyBinding(object, paths2[j], parsedPaths[j]));
          }
        } else if (index < nCachedObjects) {
          knownObject = objects[index];
          var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
          indicesByUUID[lastCachedObject.uuid] = index;
          objects[index] = lastCachedObject;
          indicesByUUID[uuid] = firstActiveIndex;
          objects[firstActiveIndex] = object;
          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = lastCached;
            if (binding === void 0) {
              binding = new PropertyBinding(object, paths2[j], parsedPaths[j]);
            }
            bindingsForPath[firstActiveIndex] = binding;
          }
        } else if (objects[index] !== knownObject) {
          console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.");
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    remove: function() {
      var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0 && index >= nCachedObjects) {
          var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
          indicesByUUID[firstActiveObject.uuid] = index;
          objects[index] = firstActiveObject;
          indicesByUUID[uuid] = lastCachedIndex;
          objects[lastCachedIndex] = object;
          for (var j = 0, m = nBindings; j !== m; ++j) {
            var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
            bindingsForPath[index] = firstActive;
            bindingsForPath[lastCachedIndex] = binding;
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    uncache: function() {
      var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
      for (var i = 0, n = arguments.length; i !== n; ++i) {
        var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
        if (index !== void 0) {
          delete indicesByUUID[uuid];
          if (index < nCachedObjects) {
            var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[lastObject.uuid] = firstActiveIndex;
            objects[firstActiveIndex] = lastObject;
            objects.pop();
            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
              bindingsForPath[index] = lastCached;
              bindingsForPath[firstActiveIndex] = last;
              bindingsForPath.pop();
            }
          } else {
            var lastIndex = --nObjects, lastObject = objects[lastIndex];
            indicesByUUID[lastObject.uuid] = index;
            objects[index] = lastObject;
            objects.pop();
            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j];
              bindingsForPath[index] = bindingsForPath[lastIndex];
              bindingsForPath.pop();
            }
          }
        }
      }
      this.nCachedObjects_ = nCachedObjects;
    },
    subscribe_: function(path, parsedPath) {
      var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
      if (index !== void 0)
        return bindings[index];
      var paths2 = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
      index = bindings.length;
      indicesByPath[path] = index;
      paths2.push(path);
      parsedPaths.push(parsedPath);
      bindings.push(bindingsForPath);
      for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
        var object = objects[i];
        bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
      }
      return bindingsForPath;
    },
    unsubscribe_: function(path) {
      var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
      if (index !== void 0) {
        var paths2 = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
        indicesByPath[lastBindingsPath] = index;
        bindings[index] = lastBindings;
        bindings.pop();
        parsedPaths[index] = parsedPaths[lastBindingsIndex];
        parsedPaths.pop();
        paths2[index] = paths2[lastBindingsIndex];
        paths2.pop();
      }
    }
  });
  function AnimationAction(mixer, clip, localRoot) {
    this._mixer = mixer;
    this._clip = clip;
    this._localRoot = localRoot || null;
    var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
    var interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
    for (var i = 0; i !== nTracks; ++i) {
      var interpolant = tracks[i].createInterpolant(null);
      interpolants[i] = interpolant;
      interpolant.settings = interpolantSettings;
    }
    this._interpolantSettings = interpolantSettings;
    this._interpolants = interpolants;
    this._propertyBindings = new Array(nTracks);
    this._cacheIndex = null;
    this._byClipCacheIndex = null;
    this._timeScaleInterpolant = null;
    this._weightInterpolant = null;
    this.loop = LoopRepeat;
    this._loopCount = -1;
    this._startTime = null;
    this.time = 0;
    this.timeScale = 1;
    this._effectiveTimeScale = 1;
    this.weight = 1;
    this._effectiveWeight = 1;
    this.repetitions = Infinity;
    this.paused = false;
    this.enabled = true;
    this.clampWhenFinished = false;
    this.zeroSlopeAtStart = true;
    this.zeroSlopeAtEnd = true;
  }
  Object.assign(AnimationAction.prototype, {
    play: function() {
      this._mixer._activateAction(this);
      return this;
    },
    stop: function() {
      this._mixer._deactivateAction(this);
      return this.reset();
    },
    reset: function() {
      this.paused = false;
      this.enabled = true;
      this.time = 0;
      this._loopCount = -1;
      this._startTime = null;
      return this.stopFading().stopWarping();
    },
    isRunning: function() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
    },
    isScheduled: function() {
      return this._mixer._isActiveAction(this);
    },
    startAt: function(time2) {
      this._startTime = time2;
      return this;
    },
    setLoop: function(mode, repetitions) {
      this.loop = mode;
      this.repetitions = repetitions;
      return this;
    },
    setEffectiveWeight: function(weight) {
      this.weight = weight;
      this._effectiveWeight = this.enabled ? weight : 0;
      return this.stopFading();
    },
    getEffectiveWeight: function() {
      return this._effectiveWeight;
    },
    fadeIn: function(duration) {
      return this._scheduleFading(duration, 0, 1);
    },
    fadeOut: function(duration) {
      return this._scheduleFading(duration, 1, 0);
    },
    crossFadeFrom: function(fadeOutAction, duration, warp) {
      fadeOutAction.fadeOut(duration);
      this.fadeIn(duration);
      if (warp) {
        var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
        fadeOutAction.warp(1, startEndRatio, duration);
        this.warp(endStartRatio, 1, duration);
      }
      return this;
    },
    crossFadeTo: function(fadeInAction, duration, warp) {
      return fadeInAction.crossFadeFrom(this, duration, warp);
    },
    stopFading: function() {
      var weightInterpolant = this._weightInterpolant;
      if (weightInterpolant !== null) {
        this._weightInterpolant = null;
        this._mixer._takeBackControlInterpolant(weightInterpolant);
      }
      return this;
    },
    setEffectiveTimeScale: function(timeScale) {
      this.timeScale = timeScale;
      this._effectiveTimeScale = this.paused ? 0 : timeScale;
      return this.stopWarping();
    },
    getEffectiveTimeScale: function() {
      return this._effectiveTimeScale;
    },
    setDuration: function(duration) {
      this.timeScale = this._clip.duration / duration;
      return this.stopWarping();
    },
    syncWith: function(action) {
      this.time = action.time;
      this.timeScale = action.timeScale;
      return this.stopWarping();
    },
    halt: function(duration) {
      return this.warp(this._effectiveTimeScale, 0, duration);
    },
    warp: function(startTimeScale, endTimeScale, duration) {
      var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._timeScaleInterpolant = interpolant;
      }
      var times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now;
      times[1] = now + duration;
      values[0] = startTimeScale / timeScale;
      values[1] = endTimeScale / timeScale;
      return this;
    },
    stopWarping: function() {
      var timeScaleInterpolant = this._timeScaleInterpolant;
      if (timeScaleInterpolant !== null) {
        this._timeScaleInterpolant = null;
        this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
      }
      return this;
    },
    getMixer: function() {
      return this._mixer;
    },
    getClip: function() {
      return this._clip;
    },
    getRoot: function() {
      return this._localRoot || this._mixer._root;
    },
    _update: function(time2, deltaTime, timeDirection, accuIndex) {
      if (!this.enabled) {
        this._updateWeight(time2);
        return;
      }
      var startTime = this._startTime;
      if (startTime !== null) {
        var timeRunning = (time2 - startTime) * timeDirection;
        if (timeRunning < 0 || timeDirection === 0) {
          return;
        }
        this._startTime = null;
        deltaTime = timeDirection * timeRunning;
      }
      deltaTime *= this._updateTimeScale(time2);
      var clipTime = this._updateTime(deltaTime);
      var weight = this._updateWeight(time2);
      if (weight > 0) {
        var interpolants = this._interpolants;
        var propertyMixers = this._propertyBindings;
        for (var j = 0, m = interpolants.length; j !== m; ++j) {
          interpolants[j].evaluate(clipTime);
          propertyMixers[j].accumulate(accuIndex, weight);
        }
      }
    },
    _updateWeight: function(time2) {
      var weight = 0;
      if (this.enabled) {
        weight = this.weight;
        var interpolant = this._weightInterpolant;
        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time2)[0];
          weight *= interpolantValue;
          if (time2 > interpolant.parameterPositions[1]) {
            this.stopFading();
            if (interpolantValue === 0) {
              this.enabled = false;
            }
          }
        }
      }
      this._effectiveWeight = weight;
      return weight;
    },
    _updateTimeScale: function(time2) {
      var timeScale = 0;
      if (!this.paused) {
        timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;
        if (interpolant !== null) {
          var interpolantValue = interpolant.evaluate(time2)[0];
          timeScale *= interpolantValue;
          if (time2 > interpolant.parameterPositions[1]) {
            this.stopWarping();
            if (timeScale === 0) {
              this.paused = true;
            } else {
              this.timeScale = timeScale;
            }
          }
        }
      }
      this._effectiveTimeScale = timeScale;
      return timeScale;
    },
    _updateTime: function(deltaTime) {
      var time2 = this.time + deltaTime;
      var duration = this._clip.duration;
      var loop = this.loop;
      var loopCount = this._loopCount;
      var pingPong = loop === LoopPingPong;
      if (deltaTime === 0) {
        if (loopCount === -1)
          return time2;
        return pingPong && (loopCount & 1) === 1 ? duration - time2 : time2;
      }
      if (loop === LoopOnce) {
        if (loopCount === -1) {
          this._loopCount = 0;
          this._setEndings(true, true, false);
        }
        handle_stop: {
          if (time2 >= duration) {
            time2 = duration;
          } else if (time2 < 0) {
            time2 = 0;
          } else
            break handle_stop;
          if (this.clampWhenFinished)
            this.paused = true;
          else
            this.enabled = false;
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: deltaTime < 0 ? -1 : 1
          });
        }
      } else {
        if (loopCount === -1) {
          if (deltaTime >= 0) {
            loopCount = 0;
            this._setEndings(true, this.repetitions === 0, pingPong);
          } else {
            this._setEndings(this.repetitions === 0, true, pingPong);
          }
        }
        if (time2 >= duration || time2 < 0) {
          var loopDelta = Math.floor(time2 / duration);
          time2 -= duration * loopDelta;
          loopCount += Math.abs(loopDelta);
          var pending = this.repetitions - loopCount;
          if (pending <= 0) {
            if (this.clampWhenFinished)
              this.paused = true;
            else
              this.enabled = false;
            time2 = deltaTime > 0 ? duration : 0;
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: deltaTime > 0 ? 1 : -1
            });
          } else {
            if (pending === 1) {
              var atStart = deltaTime < 0;
              this._setEndings(atStart, !atStart, pingPong);
            } else {
              this._setEndings(false, false, pingPong);
            }
            this._loopCount = loopCount;
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta
            });
          }
        }
        if (pingPong && (loopCount & 1) === 1) {
          this.time = time2;
          return duration - time2;
        }
      }
      this.time = time2;
      return time2;
    },
    _setEndings: function(atStart, atEnd, pingPong) {
      var settings = this._interpolantSettings;
      if (pingPong) {
        settings.endingStart = ZeroSlopeEnding;
        settings.endingEnd = ZeroSlopeEnding;
      } else {
        if (atStart) {
          settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingStart = WrapAroundEnding;
        }
        if (atEnd) {
          settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
        } else {
          settings.endingEnd = WrapAroundEnding;
        }
      }
    },
    _scheduleFading: function(duration, weightNow, weightThen) {
      var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
      if (interpolant === null) {
        interpolant = mixer._lendControlInterpolant();
        this._weightInterpolant = interpolant;
      }
      var times = interpolant.parameterPositions, values = interpolant.sampleValues;
      times[0] = now;
      values[0] = weightNow;
      times[1] = now + duration;
      values[1] = weightThen;
      return this;
    }
  });
  function AnimationMixer(root) {
    this._root = root;
    this._initMemoryManager();
    this._accuIndex = 0;
    this.time = 0;
    this.timeScale = 1;
  }
  AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
    constructor: AnimationMixer,
    _bindAction: function(action, prototypeAction) {
      var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
      if (bindingsByName === void 0) {
        bindingsByName = {};
        bindingsByRoot[rootUuid] = bindingsByName;
      }
      for (var i = 0; i !== nTracks; ++i) {
        var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
        if (binding !== void 0) {
          bindings[i] = binding;
        } else {
          binding = bindings[i];
          if (binding !== void 0) {
            if (binding._cacheIndex === null) {
              ++binding.referenceCount;
              this._addInactiveBinding(binding, rootUuid, trackName);
            }
            continue;
          }
          var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
          binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
          ++binding.referenceCount;
          this._addInactiveBinding(binding, rootUuid, trackName);
          bindings[i] = binding;
        }
        interpolants[i].resultBuffer = binding.buffer;
      }
    },
    _activateAction: function(action) {
      if (!this._isActiveAction(action)) {
        if (action._cacheIndex === null) {
          var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
          this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
          this._addInactiveAction(action, clipUuid, rootUuid);
        }
        var bindings = action._propertyBindings;
        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];
          if (binding.useCount++ === 0) {
            this._lendBinding(binding);
            binding.saveOriginalState();
          }
        }
        this._lendAction(action);
      }
    },
    _deactivateAction: function(action) {
      if (this._isActiveAction(action)) {
        var bindings = action._propertyBindings;
        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];
          if (--binding.useCount === 0) {
            binding.restoreOriginalState();
            this._takeBackBinding(binding);
          }
        }
        this._takeBackAction(action);
      }
    },
    _initMemoryManager: function() {
      this._actions = [];
      this._nActiveActions = 0;
      this._actionsByClip = {};
      this._bindings = [];
      this._nActiveBindings = 0;
      this._bindingsByRootAndName = {};
      this._controlInterpolants = [];
      this._nActiveControlInterpolants = 0;
      var scope = this;
      this.stats = {
        actions: {
          get total() {
            return scope._actions.length;
          },
          get inUse() {
            return scope._nActiveActions;
          }
        },
        bindings: {
          get total() {
            return scope._bindings.length;
          },
          get inUse() {
            return scope._nActiveBindings;
          }
        },
        controlInterpolants: {
          get total() {
            return scope._controlInterpolants.length;
          },
          get inUse() {
            return scope._nActiveControlInterpolants;
          }
        }
      };
    },
    _isActiveAction: function(action) {
      var index = action._cacheIndex;
      return index !== null && index < this._nActiveActions;
    },
    _addInactiveAction: function(action, clipUuid, rootUuid) {
      var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip === void 0) {
        actionsForClip = {
          knownActions: [action],
          actionByRoot: {}
        };
        action._byClipCacheIndex = 0;
        actionsByClip[clipUuid] = actionsForClip;
      } else {
        var knownActions = actionsForClip.knownActions;
        action._byClipCacheIndex = knownActions.length;
        knownActions.push(action);
      }
      action._cacheIndex = actions.length;
      actions.push(action);
      actionsForClip.actionByRoot[rootUuid] = action;
    },
    _removeInactiveAction: function(action) {
      var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
      lastInactiveAction._cacheIndex = cacheIndex;
      actions[cacheIndex] = lastInactiveAction;
      actions.pop();
      action._cacheIndex = null;
      var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
      lastKnownAction._byClipCacheIndex = byClipCacheIndex;
      knownActionsForClip[byClipCacheIndex] = lastKnownAction;
      knownActionsForClip.pop();
      action._byClipCacheIndex = null;
      var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
      delete actionByRoot[rootUuid];
      if (knownActionsForClip.length === 0) {
        delete actionsByClip[clipUuid];
      }
      this._removeInactiveBindingsForAction(action);
    },
    _removeInactiveBindingsForAction: function(action) {
      var bindings = action._propertyBindings;
      for (var i = 0, n = bindings.length; i !== n; ++i) {
        var binding = bindings[i];
        if (--binding.referenceCount === 0) {
          this._removeInactiveBinding(binding);
        }
      }
    },
    _lendAction: function(action) {
      var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
      action._cacheIndex = lastActiveIndex;
      actions[lastActiveIndex] = action;
      firstInactiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = firstInactiveAction;
    },
    _takeBackAction: function(action) {
      var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
      action._cacheIndex = firstInactiveIndex;
      actions[firstInactiveIndex] = action;
      lastActiveAction._cacheIndex = prevIndex;
      actions[prevIndex] = lastActiveAction;
    },
    _addInactiveBinding: function(binding, rootUuid, trackName) {
      var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
      if (bindingByName === void 0) {
        bindingByName = {};
        bindingsByRoot[rootUuid] = bindingByName;
      }
      bindingByName[trackName] = binding;
      binding._cacheIndex = bindings.length;
      bindings.push(binding);
    },
    _removeInactiveBinding: function(binding) {
      var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
      lastInactiveBinding._cacheIndex = cacheIndex;
      bindings[cacheIndex] = lastInactiveBinding;
      bindings.pop();
      delete bindingByName[trackName];
      remove_empty_map: {
        for (var _ in bindingByName)
          break remove_empty_map;
        delete bindingsByRoot[rootUuid];
      }
    },
    _lendBinding: function(binding) {
      var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
      binding._cacheIndex = lastActiveIndex;
      bindings[lastActiveIndex] = binding;
      firstInactiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = firstInactiveBinding;
    },
    _takeBackBinding: function(binding) {
      var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
      binding._cacheIndex = firstInactiveIndex;
      bindings[firstInactiveIndex] = binding;
      lastActiveBinding._cacheIndex = prevIndex;
      bindings[prevIndex] = lastActiveBinding;
    },
    _lendControlInterpolant: function() {
      var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
      if (interpolant === void 0) {
        interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
        interpolant.__cacheIndex = lastActiveIndex;
        interpolants[lastActiveIndex] = interpolant;
      }
      return interpolant;
    },
    _takeBackControlInterpolant: function(interpolant) {
      var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
      interpolant.__cacheIndex = firstInactiveIndex;
      interpolants[firstInactiveIndex] = interpolant;
      lastActiveInterpolant.__cacheIndex = prevIndex;
      interpolants[prevIndex] = lastActiveInterpolant;
    },
    _controlInterpolantsResultBuffer: new Float32Array(1),
    clipAction: function(clip, optionalRoot) {
      var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
      if (actionsForClip !== void 0) {
        var existingAction = actionsForClip.actionByRoot[rootUuid];
        if (existingAction !== void 0) {
          return existingAction;
        }
        prototypeAction = actionsForClip.knownActions[0];
        if (clipObject === null)
          clipObject = prototypeAction._clip;
      }
      if (clipObject === null)
        return null;
      var newAction = new AnimationAction(this, clipObject, optionalRoot);
      this._bindAction(newAction, prototypeAction);
      this._addInactiveAction(newAction, clipUuid, rootUuid);
      return newAction;
    },
    existingAction: function(clip, optionalRoot) {
      var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        return actionsForClip.actionByRoot[rootUuid] || null;
      }
      return null;
    },
    stopAllAction: function() {
      var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
      this._nActiveActions = 0;
      this._nActiveBindings = 0;
      for (var i = 0; i !== nActions; ++i) {
        actions[i].reset();
      }
      for (var i = 0; i !== nBindings; ++i) {
        bindings[i].useCount = 0;
      }
      return this;
    },
    update: function(deltaTime) {
      deltaTime *= this.timeScale;
      var actions = this._actions, nActions = this._nActiveActions, time2 = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
      for (var i = 0; i !== nActions; ++i) {
        var action = actions[i];
        action._update(time2, deltaTime, timeDirection, accuIndex);
      }
      var bindings = this._bindings, nBindings = this._nActiveBindings;
      for (var i = 0; i !== nBindings; ++i) {
        bindings[i].apply(accuIndex);
      }
      return this;
    },
    getRoot: function() {
      return this._root;
    },
    uncacheClip: function(clip) {
      var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
      if (actionsForClip !== void 0) {
        var actionsToRemove = actionsForClip.knownActions;
        for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
          var action = actionsToRemove[i];
          this._deactivateAction(action);
          var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
          action._cacheIndex = null;
          action._byClipCacheIndex = null;
          lastInactiveAction._cacheIndex = cacheIndex;
          actions[cacheIndex] = lastInactiveAction;
          actions.pop();
          this._removeInactiveBindingsForAction(action);
        }
        delete actionsByClip[clipUuid];
      }
    },
    uncacheRoot: function(root) {
      var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
      for (var clipUuid in actionsByClip) {
        var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
        if (action !== void 0) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
      var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
      if (bindingByName !== void 0) {
        for (var trackName in bindingByName) {
          var binding = bindingByName[trackName];
          binding.restoreOriginalState();
          this._removeInactiveBinding(binding);
        }
      }
    },
    uncacheAction: function(clip, optionalRoot) {
      var action = this.existingAction(clip, optionalRoot);
      if (action !== null) {
        this._deactivateAction(action);
        this._removeInactiveAction(action);
      }
    }
  });
  function Uniform(value) {
    if (typeof value === "string") {
      console.warn("THREE.Uniform: Type parameter is no longer needed.");
      value = arguments[1];
    }
    this.value = value;
  }
  Uniform.prototype.clone = function() {
    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  };
  function InstancedBufferGeometry() {
    BufferGeometry.call(this);
    this.type = "InstancedBufferGeometry";
    this.maxInstancedCount = void 0;
  }
  InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
    constructor: InstancedBufferGeometry,
    isInstancedBufferGeometry: true,
    copy: function(source) {
      BufferGeometry.prototype.copy.call(this, source);
      this.maxInstancedCount = source.maxInstancedCount;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
    InterleavedBuffer.call(this, array, stride);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
    constructor: InstancedInterleavedBuffer,
    isInstancedInterleavedBuffer: true,
    copy: function(source) {
      InterleavedBuffer.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  });
  function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
    if (typeof normalized === "number") {
      meshPerAttribute = normalized;
      normalized = false;
      console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
    }
    BufferAttribute.call(this, array, itemSize, normalized);
    this.meshPerAttribute = meshPerAttribute || 1;
  }
  InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
    constructor: InstancedBufferAttribute,
    isInstancedBufferAttribute: true,
    copy: function(source) {
      BufferAttribute.prototype.copy.call(this, source);
      this.meshPerAttribute = source.meshPerAttribute;
      return this;
    }
  });
  function Raycaster(origin, direction, near, far) {
    this.ray = new Ray(origin, direction);
    this.near = near || 0;
    this.far = far || Infinity;
    this.params = {
      Mesh: {},
      Line: {},
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {}
    };
    Object.defineProperties(this.params, {
      PointCloud: {
        get: function() {
          console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
          return this.Points;
        }
      }
    });
  }
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersectObject(object, raycaster, intersects2, recursive) {
    if (object.visible === false)
      return;
    object.raycast(raycaster, intersects2);
    if (recursive === true) {
      var children2 = object.children;
      for (var i = 0, l = children2.length; i < l; i++) {
        intersectObject(children2[i], raycaster, intersects2, true);
      }
    }
  }
  Object.assign(Raycaster.prototype, {
    linePrecision: 1,
    set: function(origin, direction) {
      this.ray.set(origin, direction);
    },
    setFromCamera: function(coords, camera2) {
      if (camera2 && camera2.isPerspectiveCamera) {
        this.ray.origin.setFromMatrixPosition(camera2.matrixWorld);
        this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera2).sub(this.ray.origin).normalize();
      } else if (camera2 && camera2.isOrthographicCamera) {
        this.ray.origin.set(coords.x, coords.y, (camera2.near + camera2.far) / (camera2.near - camera2.far)).unproject(camera2);
        this.ray.direction.set(0, 0, -1).transformDirection(camera2.matrixWorld);
      } else {
        console.error("THREE.Raycaster: Unsupported camera type.");
      }
    },
    intersectObject: function(object, recursive, optionalTarget) {
      var intersects2 = optionalTarget || [];
      intersectObject(object, this, intersects2, recursive);
      intersects2.sort(ascSort);
      return intersects2;
    },
    intersectObjects: function(objects, recursive, optionalTarget) {
      var intersects2 = optionalTarget || [];
      if (Array.isArray(objects) === false) {
        console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
        return intersects2;
      }
      for (var i = 0, l = objects.length; i < l; i++) {
        intersectObject(objects[i], this, intersects2, recursive);
      }
      intersects2.sort(ascSort);
      return intersects2;
    }
  });
  function Spherical(radius, phi, theta) {
    this.radius = radius !== void 0 ? radius : 1;
    this.phi = phi !== void 0 ? phi : 0;
    this.theta = theta !== void 0 ? theta : 0;
    return this;
  }
  Object.assign(Spherical.prototype, {
    set: function(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    },
    makeSafe: function() {
      var EPS = 1e-6;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    },
    setFromVector3: function(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);
      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(_Math.clamp(y / this.radius, -1, 1));
      }
      return this;
    }
  });
  function Cylindrical(radius, theta, y) {
    this.radius = radius !== void 0 ? radius : 1;
    this.theta = theta !== void 0 ? theta : 0;
    this.y = y !== void 0 ? y : 0;
    return this;
  }
  Object.assign(Cylindrical.prototype, {
    set: function(radius, theta, y) {
      this.radius = radius;
      this.theta = theta;
      this.y = y;
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(other) {
      this.radius = other.radius;
      this.theta = other.theta;
      this.y = other.y;
      return this;
    },
    setFromVector3: function(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    },
    setFromCartesianCoords: function(x, y, z) {
      this.radius = Math.sqrt(x * x + z * z);
      this.theta = Math.atan2(x, z);
      this.y = y;
      return this;
    }
  });
  function Box2(min, max) {
    this.min = min !== void 0 ? min : new Vector2(Infinity, Infinity);
    this.max = max !== void 0 ? max : new Vector2(-Infinity, -Infinity);
  }
  Object.assign(Box2.prototype, {
    set: function(min, max) {
      this.min.copy(min);
      this.max.copy(max);
      return this;
    },
    setFromPoints: function(points) {
      this.makeEmpty();
      for (var i = 0, il = points.length; i < il; i++) {
        this.expandByPoint(points[i]);
      }
      return this;
    },
    setFromCenterAndSize: function() {
      var v1 = new Vector2();
      return function setFromCenterAndSize(center, size2) {
        var halfSize = v1.copy(size2).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      };
    }(),
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(box) {
      this.min.copy(box.min);
      this.max.copy(box.max);
      return this;
    },
    makeEmpty: function() {
      this.min.x = this.min.y = Infinity;
      this.max.x = this.max.y = -Infinity;
      return this;
    },
    isEmpty: function() {
      return this.max.x < this.min.x || this.max.y < this.min.y;
    },
    getCenter: function(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getCenter() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
    },
    getSize: function(target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getSize() target is now required");
        target = new Vector2();
      }
      return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
    },
    expandByPoint: function(point) {
      this.min.min(point);
      this.max.max(point);
      return this;
    },
    expandByVector: function(vector) {
      this.min.sub(vector);
      this.max.add(vector);
      return this;
    },
    expandByScalar: function(scalar) {
      this.min.addScalar(-scalar);
      this.max.addScalar(scalar);
      return this;
    },
    containsPoint: function(point) {
      return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
    },
    containsBox: function(box) {
      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
    },
    getParameter: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .getParameter() target is now required");
        target = new Vector2();
      }
      return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
    },
    intersectsBox: function(box) {
      return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
    },
    clampPoint: function(point, target) {
      if (target === void 0) {
        console.warn("THREE.Box2: .clampPoint() target is now required");
        target = new Vector2();
      }
      return target.copy(point).clamp(this.min, this.max);
    },
    distanceToPoint: function() {
      var v1 = new Vector2();
      return function distanceToPoint(point) {
        var clampedPoint = v1.copy(point).clamp(this.min, this.max);
        return clampedPoint.sub(point).length();
      };
    }(),
    intersect: function(box) {
      this.min.max(box.min);
      this.max.min(box.max);
      return this;
    },
    union: function(box) {
      this.min.min(box.min);
      this.max.max(box.max);
      return this;
    },
    translate: function(offset) {
      this.min.add(offset);
      this.max.add(offset);
      return this;
    },
    equals: function(box) {
      return box.min.equals(this.min) && box.max.equals(this.max);
    }
  });
  function Line3(start2, end2) {
    this.start = start2 !== void 0 ? start2 : new Vector3();
    this.end = end2 !== void 0 ? end2 : new Vector3();
  }
  Object.assign(Line3.prototype, {
    set: function(start2, end2) {
      this.start.copy(start2);
      this.end.copy(end2);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    },
    copy: function(line) {
      this.start.copy(line.start);
      this.end.copy(line.end);
      return this;
    },
    getCenter: function(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .getCenter() target is now required");
        target = new Vector3();
      }
      return target.addVectors(this.start, this.end).multiplyScalar(0.5);
    },
    delta: function(target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .delta() target is now required");
        target = new Vector3();
      }
      return target.subVectors(this.end, this.start);
    },
    distanceSq: function() {
      return this.start.distanceToSquared(this.end);
    },
    distance: function() {
      return this.start.distanceTo(this.end);
    },
    at: function(t, target) {
      if (target === void 0) {
        console.warn("THREE.Line3: .at() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    },
    closestPointToPointParameter: function() {
      var startP = new Vector3();
      var startEnd = new Vector3();
      return function closestPointToPointParameter(point, clampToLine) {
        startP.subVectors(point, this.start);
        startEnd.subVectors(this.end, this.start);
        var startEnd2 = startEnd.dot(startEnd);
        var startEnd_startP = startEnd.dot(startP);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = _Math.clamp(t, 0, 1);
        }
        return t;
      };
    }(),
    closestPointToPoint: function(point, clampToLine, target) {
      var t = this.closestPointToPointParameter(point, clampToLine);
      if (target === void 0) {
        console.warn("THREE.Line3: .closestPointToPoint() target is now required");
        target = new Vector3();
      }
      return this.delta(target).multiplyScalar(t).add(this.start);
    },
    applyMatrix4: function(matrix) {
      this.start.applyMatrix4(matrix);
      this.end.applyMatrix4(matrix);
      return this;
    },
    equals: function(line) {
      return line.start.equals(this.start) && line.end.equals(this.end);
    }
  });
  function ImmediateRenderObject(material) {
    Object3D.call(this);
    this.material = material;
    this.render = function() {
    };
  }
  ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
  ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
  ImmediateRenderObject.prototype.isImmediateRenderObject = true;
  function VertexNormalsHelper(object, size2, hex, linewidth) {
    this.object = object;
    this.size = size2 !== void 0 ? size2 : 1;
    var color = hex !== void 0 ? hex : 16711680;
    var width2 = linewidth !== void 0 ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      nNormals = objGeometry.faces.length * 3;
    } else if (objGeometry && objGeometry.isBufferGeometry) {
      nNormals = objGeometry.attributes.normal.count;
    }
    var geometry2 = new BufferGeometry();
    var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
    geometry2.addAttribute("position", positions);
    LineSegments.call(this, geometry2, new LineBasicMaterial({ color, linewidth: width2 }));
    this.matrixAutoUpdate = false;
    this.update();
  }
  VertexNormalsHelper.prototype = Object.create(LineSegments.prototype);
  VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
  VertexNormalsHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update3() {
      var keys = ["a", "b", "c"];
      this.object.updateMatrixWorld(true);
      normalMatrix.getNormalMatrix(this.object.matrixWorld);
      var matrixWorld = this.object.matrixWorld;
      var position = this.geometry.attributes.position;
      var objGeometry = this.object.geometry;
      if (objGeometry && objGeometry.isGeometry) {
        var vertices = objGeometry.vertices;
        var faces = objGeometry.faces;
        var idx = 0;
        for (var i = 0, l = faces.length; i < l; i++) {
          var face = faces[i];
          for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
            var vertex = vertices[face[keys[j]]];
            var normal = face.vertexNormals[j];
            v1.copy(vertex).applyMatrix4(matrixWorld);
            v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
            position.setXYZ(idx, v1.x, v1.y, v1.z);
            idx = idx + 1;
            position.setXYZ(idx, v2.x, v2.y, v2.z);
            idx = idx + 1;
          }
        }
      } else if (objGeometry && objGeometry.isBufferGeometry) {
        var objPos = objGeometry.attributes.position;
        var objNorm = objGeometry.attributes.normal;
        var idx = 0;
        for (var j = 0, jl = objPos.count; j < jl; j++) {
          v1.set(objPos.getX(j), objPos.getY(j), objPos.getZ(j)).applyMatrix4(matrixWorld);
          v2.set(objNorm.getX(j), objNorm.getY(j), objNorm.getZ(j));
          v2.applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
          position.setXYZ(idx, v1.x, v1.y, v1.z);
          idx = idx + 1;
          position.setXYZ(idx, v2.x, v2.y, v2.z);
          idx = idx + 1;
        }
      }
      position.needsUpdate = true;
    };
  }();
  function SpotLightHelper(light2, color) {
    Object3D.call(this);
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry2 = new BufferGeometry();
    var positions = [
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      0,
      -1,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      1,
      0,
      0,
      0,
      0,
      -1,
      1
    ];
    for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
      var p1 = i / l * Math.PI * 2;
      var p2 = j / l * Math.PI * 2;
      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
    }
    geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
    var material = new LineBasicMaterial({ fog: false });
    this.cone = new LineSegments(geometry2, material);
    this.add(this.cone);
    this.update();
  }
  SpotLightHelper.prototype = Object.create(Object3D.prototype);
  SpotLightHelper.prototype.constructor = SpotLightHelper;
  SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose();
  };
  SpotLightHelper.prototype.update = function() {
    var vector = new Vector3();
    return function update3() {
      this.light.updateMatrixWorld();
      var coneLength = this.light.distance ? this.light.distance : 1e3;
      var coneWidth = coneLength * Math.tan(this.light.angle);
      this.cone.scale.set(coneWidth, coneWidth, coneLength);
      vector.setFromMatrixPosition(this.light.target.matrixWorld);
      this.cone.lookAt(vector);
      if (this.color !== void 0) {
        this.cone.material.color.set(this.color);
      } else {
        this.cone.material.color.copy(this.light.color);
      }
    };
  }();
  function getBoneList(object) {
    var boneList = [];
    if (object && object.isBone) {
      boneList.push(object);
    }
    for (var i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  function SkeletonHelper(object) {
    var bones2 = getBoneList(object);
    var geometry2 = new BufferGeometry();
    var vertices = [];
    var colors = [];
    var color1 = new Color(0, 0, 1);
    var color2 = new Color(0, 1, 0);
    for (var i = 0; i < bones2.length; i++) {
      var bone = bones2[i];
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0);
        vertices.push(0, 0, 0);
        colors.push(color1.r, color1.g, color1.b);
        colors.push(color2.r, color2.g, color2.b);
      }
    }
    geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({ vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true });
    LineSegments.call(this, geometry2, material);
    this.root = object;
    this.bones = bones2;
    this.matrix = object.matrixWorld;
    this.matrixAutoUpdate = false;
  }
  SkeletonHelper.prototype = Object.create(LineSegments.prototype);
  SkeletonHelper.prototype.constructor = SkeletonHelper;
  SkeletonHelper.prototype.updateMatrixWorld = function() {
    var vector = new Vector3();
    var boneMatrix = new Matrix4();
    var matrixWorldInv = new Matrix4();
    return function updateMatrixWorld(force) {
      var bones2 = this.bones;
      var geometry2 = this.geometry;
      var position = geometry2.getAttribute("position");
      matrixWorldInv.getInverse(this.root.matrixWorld);
      for (var i = 0, j = 0; i < bones2.length; i++) {
        var bone = bones2[i];
        if (bone.parent && bone.parent.isBone) {
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.matrixWorld);
          vector.setFromMatrixPosition(boneMatrix);
          position.setXYZ(j, vector.x, vector.y, vector.z);
          boneMatrix.multiplyMatrices(matrixWorldInv, bone.parent.matrixWorld);
          vector.setFromMatrixPosition(boneMatrix);
          position.setXYZ(j + 1, vector.x, vector.y, vector.z);
          j += 2;
        }
      }
      geometry2.getAttribute("position").needsUpdate = true;
      Object3D.prototype.updateMatrixWorld.call(this, force);
    };
  }();
  function PointLightHelper(light2, sphereSize, color) {
    this.light = light2;
    this.light.updateMatrixWorld();
    this.color = color;
    var geometry2 = new SphereBufferGeometry(sphereSize, 4, 2);
    var material = new MeshBasicMaterial({ wireframe: true, fog: false });
    Mesh.call(this, geometry2, material);
    this.matrix = this.light.matrixWorld;
    this.matrixAutoUpdate = false;
    this.update();
  }
  PointLightHelper.prototype = Object.create(Mesh.prototype);
  PointLightHelper.prototype.constructor = PointLightHelper;
  PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
  };
  PointLightHelper.prototype.update = function() {
    if (this.color !== void 0) {
      this.material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color);
    }
  };
  function RectAreaLightHelper(light2, color) {
    this.type = "RectAreaLightHelper";
    this.light = light2;
    this.color = color;
    var positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry2.computeBoundingSphere();
    var material = new LineBasicMaterial({ fog: false });
    Line.call(this, geometry2, material);
    var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
    var geometry22 = new BufferGeometry();
    geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry22.computeBoundingSphere();
    this.add(new Mesh(geometry22, new MeshBasicMaterial({ side: BackSide, fog: false })));
    this.update();
  }
  RectAreaLightHelper.prototype = Object.create(Line.prototype);
  RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
  RectAreaLightHelper.prototype.update = function() {
    this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1);
    if (this.color !== void 0) {
      this.material.color.set(this.color);
      this.children[0].material.color.set(this.color);
    } else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      var c = this.material.color;
      var max = Math.max(c.r, c.g, c.b);
      if (max > 1)
        c.multiplyScalar(1 / max);
      this.children[0].material.color.copy(this.material.color);
    }
  };
  RectAreaLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose();
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  function HemisphereLightHelper(light2, size2, color) {
    Object3D.call(this);
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    var geometry2 = new OctahedronBufferGeometry(size2);
    geometry2.rotateY(Math.PI * 0.5);
    this.material = new MeshBasicMaterial({ wireframe: true, fog: false });
    if (this.color === void 0)
      this.material.vertexColors = VertexColors;
    var position = geometry2.getAttribute("position");
    var colors = new Float32Array(position.count * 3);
    geometry2.addAttribute("color", new BufferAttribute(colors, 3));
    this.add(new Mesh(geometry2, this.material));
    this.update();
  }
  HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
  HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
  HemisphereLightHelper.prototype.dispose = function() {
    this.children[0].geometry.dispose();
    this.children[0].material.dispose();
  };
  HemisphereLightHelper.prototype.update = function() {
    var vector = new Vector3();
    var color1 = new Color();
    var color2 = new Color();
    return function update3() {
      var mesh = this.children[0];
      if (this.color !== void 0) {
        this.material.color.set(this.color);
      } else {
        var colors = mesh.geometry.getAttribute("color");
        color1.copy(this.light.color);
        color2.copy(this.light.groundColor);
        for (var i = 0, l = colors.count; i < l; i++) {
          var color = i < l / 2 ? color1 : color2;
          colors.setXYZ(i, color.r, color.g, color.b);
        }
        colors.needsUpdate = true;
      }
      mesh.lookAt(vector.setFromMatrixPosition(this.light.matrixWorld).negate());
    };
  }();
  function GridHelper(size2, divisions, color1, color2) {
    size2 = size2 || 10;
    divisions = divisions || 10;
    color1 = new Color(color1 !== void 0 ? color1 : 4473924);
    color2 = new Color(color2 !== void 0 ? color2 : 8947848);
    var center = divisions / 2;
    var step = size2 / divisions;
    var halfSize = size2 / 2;
    var vertices = [], colors = [];
    for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k);
      vertices.push(k, 0, -halfSize, k, 0, halfSize);
      var color = i === center ? color1 : color2;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
      color.toArray(colors, j);
      j += 3;
    }
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({ vertexColors: VertexColors });
    LineSegments.call(this, geometry2, material);
  }
  GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
    constructor: GridHelper,
    copy: function(source) {
      LineSegments.prototype.copy.call(this, source);
      this.geometry.copy(source.geometry);
      this.material.copy(source.material);
      return this;
    },
    clone: function() {
      return new this.constructor().copy(this);
    }
  });
  function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
    radius = radius || 10;
    radials = radials || 16;
    circles = circles || 8;
    divisions = divisions || 64;
    color1 = new Color(color1 !== void 0 ? color1 : 4473924);
    color2 = new Color(color2 !== void 0 ? color2 : 8947848);
    var vertices = [];
    var colors = [];
    var x, z;
    var v, i, j, r, color;
    for (i = 0; i <= radials; i++) {
      v = i / radials * (Math.PI * 2);
      x = Math.sin(v) * radius;
      z = Math.cos(v) * radius;
      vertices.push(0, 0, 0);
      vertices.push(x, 0, z);
      color = i & 1 ? color1 : color2;
      colors.push(color.r, color.g, color.b);
      colors.push(color.r, color.g, color.b);
    }
    for (i = 0; i <= circles; i++) {
      color = i & 1 ? color1 : color2;
      r = radius - radius / circles * i;
      for (j = 0; j < divisions; j++) {
        v = j / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
        v = (j + 1) / divisions * (Math.PI * 2);
        x = Math.sin(v) * r;
        z = Math.cos(v) * r;
        vertices.push(x, 0, z);
        colors.push(color.r, color.g, color.b);
      }
    }
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({ vertexColors: VertexColors });
    LineSegments.call(this, geometry2, material);
  }
  PolarGridHelper.prototype = Object.create(LineSegments.prototype);
  PolarGridHelper.prototype.constructor = PolarGridHelper;
  function PositionalAudioHelper(audio, range, divisionsInnerAngle, divisionsOuterAngle) {
    this.audio = audio;
    this.range = range || 1;
    this.divisionsInnerAngle = divisionsInnerAngle || 16;
    this.divisionsOuterAngle = divisionsOuterAngle || 2;
    var geometry2 = new BufferGeometry();
    var divisions = this.divisionsInnerAngle + this.divisionsOuterAngle * 2;
    var positions = new Float32Array((divisions * 3 + 3) * 3);
    geometry2.addAttribute("position", new BufferAttribute(positions, 3));
    var materialInnerAngle = new LineBasicMaterial({ color: 65280 });
    var materialOuterAngle = new LineBasicMaterial({ color: 16776960 });
    Line.call(this, geometry2, [materialOuterAngle, materialInnerAngle]);
    this.update();
  }
  PositionalAudioHelper.prototype = Object.create(Line.prototype);
  PositionalAudioHelper.prototype.constructor = PositionalAudioHelper;
  PositionalAudioHelper.prototype.update = function() {
    var audio = this.audio;
    var range = this.range;
    var divisionsInnerAngle = this.divisionsInnerAngle;
    var divisionsOuterAngle = this.divisionsOuterAngle;
    var coneInnerAngle = _Math.degToRad(audio.panner.coneInnerAngle);
    var coneOuterAngle = _Math.degToRad(audio.panner.coneOuterAngle);
    var halfConeInnerAngle = coneInnerAngle / 2;
    var halfConeOuterAngle = coneOuterAngle / 2;
    var start2 = 0;
    var count2 = 0;
    var i, stride;
    var geometry2 = this.geometry;
    var positionAttribute = geometry2.attributes.position;
    geometry2.clearGroups();
    function generateSegment(from, to, divisions, materialIndex) {
      var step = (to - from) / divisions;
      positionAttribute.setXYZ(start2, 0, 0, 0);
      count2++;
      for (i = from; i < to; i += step) {
        stride = start2 + count2;
        positionAttribute.setXYZ(stride, Math.sin(i) * range, 0, Math.cos(i) * range);
        positionAttribute.setXYZ(stride + 1, Math.sin(Math.min(i + step, to)) * range, 0, Math.cos(Math.min(i + step, to)) * range);
        positionAttribute.setXYZ(stride + 2, 0, 0, 0);
        count2 += 3;
      }
      geometry2.addGroup(start2, count2, materialIndex);
      start2 += count2;
      count2 = 0;
    }
    generateSegment(-halfConeOuterAngle, -halfConeInnerAngle, divisionsOuterAngle, 0);
    generateSegment(-halfConeInnerAngle, halfConeInnerAngle, divisionsInnerAngle, 1);
    generateSegment(halfConeInnerAngle, halfConeOuterAngle, divisionsOuterAngle, 0);
    positionAttribute.needsUpdate = true;
    if (coneInnerAngle === coneOuterAngle)
      this.material[0].visible = false;
  };
  PositionalAudioHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material[0].dispose();
    this.material[1].dispose();
  };
  function FaceNormalsHelper(object, size2, hex, linewidth) {
    this.object = object;
    this.size = size2 !== void 0 ? size2 : 1;
    var color = hex !== void 0 ? hex : 16776960;
    var width2 = linewidth !== void 0 ? linewidth : 1;
    var nNormals = 0;
    var objGeometry = this.object.geometry;
    if (objGeometry && objGeometry.isGeometry) {
      nNormals = objGeometry.faces.length;
    } else {
      console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
    }
    var geometry2 = new BufferGeometry();
    var positions = new Float32BufferAttribute(nNormals * 2 * 3, 3);
    geometry2.addAttribute("position", positions);
    LineSegments.call(this, geometry2, new LineBasicMaterial({ color, linewidth: width2 }));
    this.matrixAutoUpdate = false;
    this.update();
  }
  FaceNormalsHelper.prototype = Object.create(LineSegments.prototype);
  FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
  FaceNormalsHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var normalMatrix = new Matrix3();
    return function update3() {
      this.object.updateMatrixWorld(true);
      normalMatrix.getNormalMatrix(this.object.matrixWorld);
      var matrixWorld = this.object.matrixWorld;
      var position = this.geometry.attributes.position;
      var objGeometry = this.object.geometry;
      var vertices = objGeometry.vertices;
      var faces = objGeometry.faces;
      var idx = 0;
      for (var i = 0, l = faces.length; i < l; i++) {
        var face = faces[i];
        var normal = face.normal;
        v1.copy(vertices[face.a]).add(vertices[face.b]).add(vertices[face.c]).divideScalar(3).applyMatrix4(matrixWorld);
        v2.copy(normal).applyMatrix3(normalMatrix).normalize().multiplyScalar(this.size).add(v1);
        position.setXYZ(idx, v1.x, v1.y, v1.z);
        idx = idx + 1;
        position.setXYZ(idx, v2.x, v2.y, v2.z);
        idx = idx + 1;
      }
      position.needsUpdate = true;
    };
  }();
  function DirectionalLightHelper(light2, size2, color) {
    Object3D.call(this);
    this.light = light2;
    this.light.updateMatrixWorld();
    this.matrix = light2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.color = color;
    if (size2 === void 0)
      size2 = 1;
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute([
      -size2,
      size2,
      0,
      size2,
      size2,
      0,
      size2,
      -size2,
      0,
      -size2,
      -size2,
      0,
      -size2,
      size2,
      0
    ], 3));
    var material = new LineBasicMaterial({ fog: false });
    this.lightPlane = new Line(geometry2, material);
    this.add(this.lightPlane);
    geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
    this.targetLine = new Line(geometry2, material);
    this.add(this.targetLine);
    this.update();
  }
  DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
  DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
  DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose();
  };
  DirectionalLightHelper.prototype.update = function() {
    var v1 = new Vector3();
    var v2 = new Vector3();
    var v32 = new Vector3();
    return function update3() {
      v1.setFromMatrixPosition(this.light.matrixWorld);
      v2.setFromMatrixPosition(this.light.target.matrixWorld);
      v32.subVectors(v2, v1);
      this.lightPlane.lookAt(v2);
      if (this.color !== void 0) {
        this.lightPlane.material.color.set(this.color);
        this.targetLine.material.color.set(this.color);
      } else {
        this.lightPlane.material.color.copy(this.light.color);
        this.targetLine.material.color.copy(this.light.color);
      }
      this.targetLine.lookAt(v2);
      this.targetLine.scale.z = v32.length();
    };
  }();
  function CameraHelper(camera2) {
    var geometry2 = new BufferGeometry();
    var material = new LineBasicMaterial({ color: 16777215, vertexColors: FaceColors });
    var vertices = [];
    var colors = [];
    var pointMap = {};
    var colorFrustum = new Color(16755200);
    var colorCone = new Color(16711680);
    var colorUp = new Color(43775);
    var colorTarget = new Color(16777215);
    var colorCross = new Color(3355443);
    addLine("n1", "n2", colorFrustum);
    addLine("n2", "n4", colorFrustum);
    addLine("n4", "n3", colorFrustum);
    addLine("n3", "n1", colorFrustum);
    addLine("f1", "f2", colorFrustum);
    addLine("f2", "f4", colorFrustum);
    addLine("f4", "f3", colorFrustum);
    addLine("f3", "f1", colorFrustum);
    addLine("n1", "f1", colorFrustum);
    addLine("n2", "f2", colorFrustum);
    addLine("n3", "f3", colorFrustum);
    addLine("n4", "f4", colorFrustum);
    addLine("p", "n1", colorCone);
    addLine("p", "n2", colorCone);
    addLine("p", "n3", colorCone);
    addLine("p", "n4", colorCone);
    addLine("u1", "u2", colorUp);
    addLine("u2", "u3", colorUp);
    addLine("u3", "u1", colorUp);
    addLine("c", "t", colorTarget);
    addLine("p", "c", colorCross);
    addLine("cn1", "cn2", colorCross);
    addLine("cn3", "cn4", colorCross);
    addLine("cf1", "cf2", colorCross);
    addLine("cf3", "cf4", colorCross);
    function addLine(a, b, color) {
      addPoint(a, color);
      addPoint(b, color);
    }
    function addPoint(id, color) {
      vertices.push(0, 0, 0);
      colors.push(color.r, color.g, color.b);
      if (pointMap[id] === void 0) {
        pointMap[id] = [];
      }
      pointMap[id].push(vertices.length / 3 - 1);
    }
    geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
    LineSegments.call(this, geometry2, material);
    this.camera = camera2;
    if (this.camera.updateProjectionMatrix)
      this.camera.updateProjectionMatrix();
    this.matrix = camera2.matrixWorld;
    this.matrixAutoUpdate = false;
    this.pointMap = pointMap;
    this.update();
  }
  CameraHelper.prototype = Object.create(LineSegments.prototype);
  CameraHelper.prototype.constructor = CameraHelper;
  CameraHelper.prototype.update = function() {
    var geometry2, pointMap;
    var vector = new Vector3();
    var camera2 = new Camera2();
    function setPoint(point, x, y, z) {
      vector.set(x, y, z).unproject(camera2);
      var points = pointMap[point];
      if (points !== void 0) {
        var position = geometry2.getAttribute("position");
        for (var i = 0, l = points.length; i < l; i++) {
          position.setXYZ(points[i], vector.x, vector.y, vector.z);
        }
      }
    }
    return function update3() {
      geometry2 = this.geometry;
      pointMap = this.pointMap;
      var w = 1, h = 1;
      camera2.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
      setPoint("c", 0, 0, -1);
      setPoint("t", 0, 0, 1);
      setPoint("n1", -w, -h, -1);
      setPoint("n2", w, -h, -1);
      setPoint("n3", -w, h, -1);
      setPoint("n4", w, h, -1);
      setPoint("f1", -w, -h, 1);
      setPoint("f2", w, -h, 1);
      setPoint("f3", -w, h, 1);
      setPoint("f4", w, h, 1);
      setPoint("u1", w * 0.7, h * 1.1, -1);
      setPoint("u2", -w * 0.7, h * 1.1, -1);
      setPoint("u3", 0, h * 2, -1);
      setPoint("cf1", -w, 0, 1);
      setPoint("cf2", w, 0, 1);
      setPoint("cf3", 0, -h, 1);
      setPoint("cf4", 0, h, 1);
      setPoint("cn1", -w, 0, -1);
      setPoint("cn2", w, 0, -1);
      setPoint("cn3", 0, -h, -1);
      setPoint("cn4", 0, h, -1);
      geometry2.getAttribute("position").needsUpdate = true;
    };
  }();
  function BoxHelper(object, color) {
    this.object = object;
    if (color === void 0)
      color = 16776960;
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = new Float32Array(8 * 3);
    var geometry2 = new BufferGeometry();
    geometry2.setIndex(new BufferAttribute(indices, 1));
    geometry2.addAttribute("position", new BufferAttribute(positions, 3));
    LineSegments.call(this, geometry2, new LineBasicMaterial({ color }));
    this.matrixAutoUpdate = false;
    this.update();
  }
  BoxHelper.prototype = Object.create(LineSegments.prototype);
  BoxHelper.prototype.constructor = BoxHelper;
  BoxHelper.prototype.update = function() {
    var box = new Box3();
    return function update3(object) {
      if (object !== void 0) {
        console.warn("THREE.BoxHelper: .update() has no longer arguments.");
      }
      if (this.object !== void 0) {
        box.setFromObject(this.object);
      }
      if (box.isEmpty())
        return;
      var min = box.min;
      var max = box.max;
      var position = this.geometry.attributes.position;
      var array = position.array;
      array[0] = max.x;
      array[1] = max.y;
      array[2] = max.z;
      array[3] = min.x;
      array[4] = max.y;
      array[5] = max.z;
      array[6] = min.x;
      array[7] = min.y;
      array[8] = max.z;
      array[9] = max.x;
      array[10] = min.y;
      array[11] = max.z;
      array[12] = max.x;
      array[13] = max.y;
      array[14] = min.z;
      array[15] = min.x;
      array[16] = max.y;
      array[17] = min.z;
      array[18] = min.x;
      array[19] = min.y;
      array[20] = min.z;
      array[21] = max.x;
      array[22] = min.y;
      array[23] = min.z;
      position.needsUpdate = true;
      this.geometry.computeBoundingSphere();
    };
  }();
  BoxHelper.prototype.setFromObject = function(object) {
    this.object = object;
    this.update();
    return this;
  };
  BoxHelper.prototype.copy = function(source) {
    LineSegments.prototype.copy.call(this, source);
    this.object = source.object;
    return this;
  };
  BoxHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  function Box3Helper(box, hex) {
    this.type = "Box3Helper";
    this.box = box;
    var color = hex !== void 0 ? hex : 16776960;
    var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
    var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
    var geometry2 = new BufferGeometry();
    geometry2.setIndex(new BufferAttribute(indices, 1));
    geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
    LineSegments.call(this, geometry2, new LineBasicMaterial({ color }));
    this.geometry.computeBoundingSphere();
  }
  Box3Helper.prototype = Object.create(LineSegments.prototype);
  Box3Helper.prototype.constructor = Box3Helper;
  Box3Helper.prototype.updateMatrixWorld = function(force) {
    var box = this.box;
    if (box.isEmpty())
      return;
    box.getCenter(this.position);
    box.getSize(this.scale);
    this.scale.multiplyScalar(0.5);
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };
  function PlaneHelper(plane, size2, hex) {
    this.type = "PlaneHelper";
    this.plane = plane;
    this.size = size2 === void 0 ? 1 : size2;
    var color = hex !== void 0 ? hex : 16776960;
    var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(positions, 3));
    geometry2.computeBoundingSphere();
    Line.call(this, geometry2, new LineBasicMaterial({ color }));
    var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
    var geometry22 = new BufferGeometry();
    geometry22.addAttribute("position", new Float32BufferAttribute(positions2, 3));
    geometry22.computeBoundingSphere();
    this.add(new Mesh(geometry22, new MeshBasicMaterial({ color, opacity: 0.2, transparent: true, depthWrite: false })));
  }
  PlaneHelper.prototype = Object.create(Line.prototype);
  PlaneHelper.prototype.constructor = PlaneHelper;
  PlaneHelper.prototype.updateMatrixWorld = function(force) {
    var scale3 = -this.plane.constant;
    if (Math.abs(scale3) < 1e-8)
      scale3 = 1e-8;
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale3);
    this.children[0].material.side = scale3 < 0 ? BackSide : FrontSide;
    this.lookAt(this.plane.normal);
    Object3D.prototype.updateMatrixWorld.call(this, force);
  };
  var lineGeometry;
  var coneGeometry;
  function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
    Object3D.call(this);
    if (dir === void 0)
      dir = new Vector3(0, 0, 1);
    if (origin === void 0)
      origin = new Vector3(0, 0, 0);
    if (length === void 0)
      length = 1;
    if (color === void 0)
      color = 16776960;
    if (headLength === void 0)
      headLength = 0.2 * length;
    if (headWidth === void 0)
      headWidth = 0.2 * headLength;
    if (lineGeometry === void 0) {
      lineGeometry = new BufferGeometry();
      lineGeometry.addAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
      coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
      coneGeometry.translate(0, -0.5, 0);
    }
    this.position.copy(origin);
    this.line = new Line(lineGeometry, new LineBasicMaterial({ color }));
    this.line.matrixAutoUpdate = false;
    this.add(this.line);
    this.cone = new Mesh(coneGeometry, new MeshBasicMaterial({ color }));
    this.cone.matrixAutoUpdate = false;
    this.add(this.cone);
    this.setDirection(dir);
    this.setLength(length, headLength, headWidth);
  }
  ArrowHelper.prototype = Object.create(Object3D.prototype);
  ArrowHelper.prototype.constructor = ArrowHelper;
  ArrowHelper.prototype.setDirection = function() {
    var axis = new Vector3();
    var radians;
    return function setDirection(dir) {
      if (dir.y > 0.99999) {
        this.quaternion.set(0, 0, 0, 1);
      } else if (dir.y < -0.99999) {
        this.quaternion.set(1, 0, 0, 0);
      } else {
        axis.set(dir.z, 0, -dir.x).normalize();
        radians = Math.acos(dir.y);
        this.quaternion.setFromAxisAngle(axis, radians);
      }
    };
  }();
  ArrowHelper.prototype.setLength = function(length, headLength, headWidth) {
    if (headLength === void 0)
      headLength = 0.2 * length;
    if (headWidth === void 0)
      headWidth = 0.2 * headLength;
    this.line.scale.set(1, Math.max(0, length - headLength), 1);
    this.line.updateMatrix();
    this.cone.scale.set(headWidth, headLength, headWidth);
    this.cone.position.y = length;
    this.cone.updateMatrix();
  };
  ArrowHelper.prototype.setColor = function(color) {
    this.line.material.color.copy(color);
    this.cone.material.color.copy(color);
  };
  ArrowHelper.prototype.copy = function(source) {
    Object3D.prototype.copy.call(this, source, false);
    this.line.copy(source.line);
    this.cone.copy(source.cone);
    return this;
  };
  ArrowHelper.prototype.clone = function() {
    return new this.constructor().copy(this);
  };
  function AxesHelper(size2) {
    size2 = size2 || 1;
    var vertices = [
      0,
      0,
      0,
      size2,
      0,
      0,
      0,
      0,
      0,
      0,
      size2,
      0,
      0,
      0,
      0,
      0,
      0,
      size2
    ];
    var colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    var geometry2 = new BufferGeometry();
    geometry2.addAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry2.addAttribute("color", new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({ vertexColors: VertexColors });
    LineSegments.call(this, geometry2, material);
  }
  AxesHelper.prototype = Object.create(LineSegments.prototype);
  AxesHelper.prototype.constructor = AxesHelper;
  Curve.create = function(construct, getPoint) {
    console.log("THREE.Curve.create() has been deprecated");
    construct.prototype = Object.create(Curve.prototype);
    construct.prototype.constructor = construct;
    construct.prototype.getPoint = getPoint;
    return construct;
  };
  Object.assign(CurvePath.prototype, {
    createPointsGeometry: function(divisions) {
      console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      var pts = this.getPoints(divisions);
      return this.createGeometry(pts);
    },
    createSpacedPointsGeometry: function(divisions) {
      console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      var pts = this.getSpacedPoints(divisions);
      return this.createGeometry(pts);
    },
    createGeometry: function(points) {
      console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
      var geometry2 = new Geometry();
      for (var i = 0, l = points.length; i < l; i++) {
        var point = points[i];
        geometry2.vertices.push(new Vector3(point.x, point.y, point.z || 0));
      }
      return geometry2;
    }
  });
  Object.assign(Path.prototype, {
    fromPoints: function(points) {
      console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
      this.setFromPoints(points);
    }
  });
  function ClosedSplineCurve3(points) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
    this.closed = true;
  }
  ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
  function SplineCurve3(points) {
    console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
  }
  SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
  function Spline(points) {
    console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
    CatmullRomCurve3.call(this, points);
    this.type = "catmullrom";
  }
  Spline.prototype = Object.create(CatmullRomCurve3.prototype);
  Object.assign(Spline.prototype, {
    initFromArray: function() {
      console.error("THREE.Spline: .initFromArray() has been removed.");
    },
    getControlPointsArray: function() {
      console.error("THREE.Spline: .getControlPointsArray() has been removed.");
    },
    reparametrizeByArcLength: function() {
      console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
    }
  });
  GridHelper.prototype.setColors = function() {
    console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
  };
  SkeletonHelper.prototype.update = function() {
    console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
  };
  Object.assign(Loader.prototype, {
    extractUrlBase: function(url) {
      console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
      return LoaderUtils.extractUrlBase(url);
    }
  });
  Object.assign(ObjectLoader.prototype, {
    setTexturePath: function(value) {
      console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
      return this.setResourcePath(value);
    }
  });
  Object.assign(Box2.prototype, {
    center: function(optionalTarget) {
      console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    },
    empty: function() {
      console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(box) {
      console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    size: function(optionalTarget) {
      console.warn("THREE.Box2: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    }
  });
  Object.assign(Box3.prototype, {
    center: function(optionalTarget) {
      console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
      return this.getCenter(optionalTarget);
    },
    empty: function() {
      console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
      return this.isEmpty();
    },
    isIntersectionBox: function(box) {
      console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    isIntersectionSphere: function(sphere) {
      console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    },
    size: function(optionalTarget) {
      console.warn("THREE.Box3: .size() has been renamed to .getSize().");
      return this.getSize(optionalTarget);
    }
  });
  Line3.prototype.center = function(optionalTarget) {
    console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
    return this.getCenter(optionalTarget);
  };
  Object.assign(_Math, {
    random16: function() {
      console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
      return Math.random();
    },
    nearestPowerOfTwo: function(value) {
      console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
      return _Math.floorPowerOfTwo(value);
    },
    nextPowerOfTwo: function(value) {
      console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
      return _Math.ceilPowerOfTwo(value);
    }
  });
  Object.assign(Matrix3.prototype, {
    flattenToArrayOffset: function(array, offset) {
      console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    multiplyVector3: function(vector) {
      console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
      return vector.applyMatrix3(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
    },
    applyToBuffer: function(buffer) {
      console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
      return this.applyToBufferAttribute(buffer);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
    }
  });
  Object.assign(Matrix4.prototype, {
    extractPosition: function(m) {
      console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
      return this.copyPosition(m);
    },
    flattenToArrayOffset: function(array, offset) {
      console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
      return this.toArray(array, offset);
    },
    getPosition: function() {
      var v1;
      return function getPosition() {
        if (v1 === void 0)
          v1 = new Vector3();
        console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
        return v1.setFromMatrixColumn(this, 3);
      };
    }(),
    setRotationFromQuaternion: function(q2) {
      console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
      return this.makeRotationFromQuaternion(q2);
    },
    multiplyToArray: function() {
      console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
    },
    multiplyVector3: function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    multiplyVector4: function(vector) {
      console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    multiplyVector3Array: function() {
      console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
    },
    rotateAxis: function(v) {
      console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
      v.transformDirection(this);
    },
    crossVector: function(vector) {
      console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
      return vector.applyMatrix4(this);
    },
    translate: function() {
      console.error("THREE.Matrix4: .translate() has been removed.");
    },
    rotateX: function() {
      console.error("THREE.Matrix4: .rotateX() has been removed.");
    },
    rotateY: function() {
      console.error("THREE.Matrix4: .rotateY() has been removed.");
    },
    rotateZ: function() {
      console.error("THREE.Matrix4: .rotateZ() has been removed.");
    },
    rotateByAxis: function() {
      console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
    },
    applyToBuffer: function(buffer) {
      console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
      return this.applyToBufferAttribute(buffer);
    },
    applyToVector3Array: function() {
      console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
    },
    makeFrustum: function(left, right, bottom, top, near, far) {
      console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
      return this.makePerspective(left, right, top, bottom, near, far);
    }
  });
  Plane.prototype.isIntersectionLine = function(line) {
    console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
    return this.intersectsLine(line);
  };
  Quaternion.prototype.multiplyVector3 = function(vector) {
    console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
    return vector.applyQuaternion(this);
  };
  Object.assign(Ray.prototype, {
    isIntersectionBox: function(box) {
      console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
      return this.intersectsBox(box);
    },
    isIntersectionPlane: function(plane) {
      console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
      return this.intersectsPlane(plane);
    },
    isIntersectionSphere: function(sphere) {
      console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
      return this.intersectsSphere(sphere);
    }
  });
  Object.assign(Triangle.prototype, {
    area: function() {
      console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
      return this.getArea();
    },
    barycoordFromPoint: function(point, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return this.getBarycoord(point, target);
    },
    midpoint: function(target) {
      console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
      return this.getMidpoint(target);
    },
    normal: function(target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return this.getNormal(target);
    },
    plane: function(target) {
      console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
      return this.getPlane(target);
    }
  });
  Object.assign(Triangle, {
    barycoordFromPoint: function(point, a, b, c, target) {
      console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
      return Triangle.getBarycoord(point, a, b, c, target);
    },
    normal: function(a, b, c, target) {
      console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
      return Triangle.getNormal(a, b, c, target);
    }
  });
  Object.assign(Shape.prototype, {
    extractAllPoints: function(divisions) {
      console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
      return this.extractPoints(divisions);
    },
    extrude: function(options) {
      console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
      return new ExtrudeGeometry(this, options);
    },
    makeGeometry: function(options) {
      console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
      return new ShapeGeometry(this, options);
    }
  });
  Object.assign(Vector2.prototype, {
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
      console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Vector3.prototype, {
    setEulerFromRotationMatrix: function() {
      console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
    },
    setEulerFromQuaternion: function() {
      console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
    },
    getPositionFromMatrix: function(m) {
      console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
      return this.setFromMatrixPosition(m);
    },
    getScaleFromMatrix: function(m) {
      console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
      return this.setFromMatrixScale(m);
    },
    getColumnFromMatrix: function(index, matrix) {
      console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
      return this.setFromMatrixColumn(matrix, index);
    },
    applyProjection: function(m) {
      console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
      return this.applyMatrix4(m);
    },
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    distanceToManhattan: function(v) {
      console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
      return this.manhattanDistanceTo(v);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Vector4.prototype, {
    fromAttribute: function(attribute, index, offset) {
      console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
      return this.fromBufferAttribute(attribute, index, offset);
    },
    lengthManhattan: function() {
      console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
      return this.manhattanLength();
    }
  });
  Object.assign(Geometry.prototype, {
    computeTangents: function() {
      console.error("THREE.Geometry: .computeTangents() has been removed.");
    },
    computeLineDistances: function() {
      console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
    }
  });
  Object.assign(Object3D.prototype, {
    getChildByName: function(name) {
      console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
      return this.getObjectByName(name);
    },
    renderDepth: function() {
      console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
    },
    translate: function(distance, axis) {
      console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
      return this.translateOnAxis(axis, distance);
    },
    getWorldRotation: function() {
      console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
    }
  });
  Object.defineProperties(Object3D.prototype, {
    eulerOrder: {
      get: function() {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        return this.rotation.order;
      },
      set: function(value) {
        console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
        this.rotation.order = value;
      }
    },
    useQuaternion: {
      get: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      },
      set: function() {
        console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
      }
    }
  });
  Object.defineProperties(LOD.prototype, {
    objects: {
      get: function() {
        console.warn("THREE.LOD: .objects has been renamed to .levels.");
        return this.levels;
      }
    }
  });
  Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
    get: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    },
    set: function() {
      console.warn("THREE.Skeleton: useVertexTexture has been removed.");
    }
  });
  SkinnedMesh.prototype.initBones = function() {
    console.error("THREE.SkinnedMesh: initBones() has been removed.");
  };
  Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
    get: function() {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      return this.arcLengthDivisions;
    },
    set: function(value) {
      console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
      this.arcLengthDivisions = value;
    }
  });
  PerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {
    console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
    if (filmGauge !== void 0)
      this.filmGauge = filmGauge;
    this.setFocalLength(focalLength);
  };
  Object.defineProperties(Light.prototype, {
    onlyShadow: {
      set: function() {
        console.warn("THREE.Light: .onlyShadow has been removed.");
      }
    },
    shadowCameraFov: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
        this.shadow.camera.fov = value;
      }
    },
    shadowCameraLeft: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
        this.shadow.camera.left = value;
      }
    },
    shadowCameraRight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
        this.shadow.camera.right = value;
      }
    },
    shadowCameraTop: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
        this.shadow.camera.top = value;
      }
    },
    shadowCameraBottom: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
        this.shadow.camera.bottom = value;
      }
    },
    shadowCameraNear: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
        this.shadow.camera.near = value;
      }
    },
    shadowCameraFar: {
      set: function(value) {
        console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
        this.shadow.camera.far = value;
      }
    },
    shadowCameraVisible: {
      set: function() {
        console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
      }
    },
    shadowBias: {
      set: function(value) {
        console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
        this.shadow.bias = value;
      }
    },
    shadowDarkness: {
      set: function() {
        console.warn("THREE.Light: .shadowDarkness has been removed.");
      }
    },
    shadowMapWidth: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
        this.shadow.mapSize.width = value;
      }
    },
    shadowMapHeight: {
      set: function(value) {
        console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
        this.shadow.mapSize.height = value;
      }
    }
  });
  Object.defineProperties(BufferAttribute.prototype, {
    length: {
      get: function() {
        console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
        return this.array.length;
      }
    },
    copyIndicesArray: function() {
      console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
    }
  });
  Object.assign(BufferGeometry.prototype, {
    addIndex: function(index) {
      console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
      this.setIndex(index);
    },
    addDrawCall: function(start2, count2, indexOffset) {
      if (indexOffset !== void 0) {
        console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
      }
      console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
      this.addGroup(start2, count2);
    },
    clearDrawCalls: function() {
      console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
      this.clearGroups();
    },
    computeTangents: function() {
      console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
    },
    computeOffsets: function() {
      console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
    }
  });
  Object.defineProperties(BufferGeometry.prototype, {
    drawcalls: {
      get: function() {
        console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
        return this.groups;
      }
    },
    offsets: {
      get: function() {
        console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
        return this.groups;
      }
    }
  });
  Object.assign(ExtrudeBufferGeometry.prototype, {
    getArrays: function() {
      console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
    },
    addShapeList: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
    },
    addShape: function() {
      console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
    }
  });
  Object.defineProperties(Uniform.prototype, {
    dynamic: {
      set: function() {
        console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
      }
    },
    onUpdate: {
      value: function() {
        console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
        return this;
      }
    }
  });
  Object.defineProperties(Material.prototype, {
    wrapAround: {
      get: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .wrapAround has been removed.");
      }
    },
    overdraw: {
      get: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      },
      set: function() {
        console.warn("THREE.Material: .overdraw has been removed.");
      }
    },
    wrapRGB: {
      get: function() {
        console.warn("THREE.Material: .wrapRGB has been removed.");
        return new Color();
      }
    },
    shading: {
      get: function() {
        console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
      },
      set: function(value) {
        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
        this.flatShading = value === FlatShading;
      }
    }
  });
  Object.defineProperties(MeshPhongMaterial.prototype, {
    metal: {
      get: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
        return false;
      },
      set: function() {
        console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
      }
    }
  });
  Object.defineProperties(ShaderMaterial.prototype, {
    derivatives: {
      get: function() {
        console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        return this.extensions.derivatives;
      },
      set: function(value) {
        console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
        this.extensions.derivatives = value;
      }
    }
  });
  Object.assign(WebGLRenderer.prototype, {
    clearTarget: function(renderTarget, color, depth, stencil) {
      console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
      this.setRenderTarget(renderTarget);
      this.clear(color, depth, stencil);
    },
    animate: function(callback) {
      console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
      this.setAnimationLoop(callback);
    },
    getCurrentRenderTarget: function() {
      console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
      return this.getRenderTarget();
    },
    getMaxAnisotropy: function() {
      console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
      return this.capabilities.getMaxAnisotropy();
    },
    getPrecision: function() {
      console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
      return this.capabilities.precision;
    },
    resetGLState: function() {
      console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
      return this.state.reset();
    },
    supportsFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
      return this.extensions.get("OES_texture_float");
    },
    supportsHalfFloatTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
      return this.extensions.get("OES_texture_half_float");
    },
    supportsStandardDerivatives: function() {
      console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
      return this.extensions.get("OES_standard_derivatives");
    },
    supportsCompressedTextureS3TC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
      return this.extensions.get("WEBGL_compressed_texture_s3tc");
    },
    supportsCompressedTexturePVRTC: function() {
      console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
      return this.extensions.get("WEBGL_compressed_texture_pvrtc");
    },
    supportsBlendMinMax: function() {
      console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
      return this.extensions.get("EXT_blend_minmax");
    },
    supportsVertexTextures: function() {
      console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
      return this.capabilities.vertexTextures;
    },
    supportsInstancedArrays: function() {
      console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
      return this.extensions.get("ANGLE_instanced_arrays");
    },
    enableScissorTest: function(boolean) {
      console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
      this.setScissorTest(boolean);
    },
    initMaterial: function() {
      console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
    },
    addPrePlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
    },
    addPostPlugin: function() {
      console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
    },
    updateShadowMap: function() {
      console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
    },
    setFaceCulling: function() {
      console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
    },
    allocTextureUnit: function() {
      console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
    },
    setTexture: function() {
      console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
    },
    setTexture2D: function() {
      console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
    },
    setTextureCube: function() {
      console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
    }
  });
  Object.defineProperties(WebGLRenderer.prototype, {
    shadowMapEnabled: {
      get: function() {
        return this.shadowMap.enabled;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
        this.shadowMap.enabled = value;
      }
    },
    shadowMapType: {
      get: function() {
        return this.shadowMap.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
        this.shadowMap.type = value;
      }
    },
    shadowMapCullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLShadowMap.prototype, {
    cullFace: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
      }
    },
    renderReverseSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
      }
    },
    renderSingleSided: {
      get: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
        return void 0;
      },
      set: function() {
        console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
      }
    }
  });
  Object.defineProperties(WebGLRenderTargetCube.prototype, {
    activeCubeFace: {
      set: function() {
        console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().");
      }
    },
    activeMipMapLevel: {
      set: function() {
        console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().");
      }
    }
  });
  Object.defineProperties(WebGLRenderTarget.prototype, {
    wrapS: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        return this.texture.wrapS;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
        this.texture.wrapS = value;
      }
    },
    wrapT: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        return this.texture.wrapT;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
        this.texture.wrapT = value;
      }
    },
    magFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        return this.texture.magFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
        this.texture.magFilter = value;
      }
    },
    minFilter: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        return this.texture.minFilter;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
        this.texture.minFilter = value;
      }
    },
    anisotropy: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        return this.texture.anisotropy;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
        this.texture.anisotropy = value;
      }
    },
    offset: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        return this.texture.offset;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
        this.texture.offset = value;
      }
    },
    repeat: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        return this.texture.repeat;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
        this.texture.repeat = value;
      }
    },
    format: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        return this.texture.format;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
        this.texture.format = value;
      }
    },
    type: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        return this.texture.type;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
        this.texture.type = value;
      }
    },
    generateMipmaps: {
      get: function() {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        return this.texture.generateMipmaps;
      },
      set: function(value) {
        console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
        this.texture.generateMipmaps = value;
      }
    }
  });
  Object.defineProperties(WebVRManager.prototype, {
    standing: {
      set: function() {
        console.warn("THREE.WebVRManager: .standing has been removed.");
      }
    },
    userHeight: {
      set: function() {
        console.warn("THREE.WebVRManager: .userHeight has been removed.");
      }
    }
  });
  Audio.prototype.load = function(file) {
    console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
    var scope = this;
    var audioLoader = new AudioLoader();
    audioLoader.load(file, function(buffer) {
      scope.setBuffer(buffer);
    });
    return this;
  };
  AudioAnalyser.prototype.getData = function() {
    console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
    return this.getFrequencyData();
  };
  CubeCamera.prototype.updateCubeMap = function(renderer, scene2) {
    console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
    return this.update(renderer, scene2);
  };
  ImageUtils.crossOrigin = void 0;
  ImageUtils.loadTexture = function(url, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
    var loader = new TextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(url, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {
    console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
    var loader = new CubeTextureLoader();
    loader.setCrossOrigin(this.crossOrigin);
    var texture = loader.load(urls, onLoad, void 0, onError);
    if (mapping)
      texture.mapping = mapping;
    return texture;
  };
  ImageUtils.loadCompressedTexture = function() {
    console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
  };
  ImageUtils.loadCompressedTextureCube = function() {
    console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
  };

  // src/component/character-camera.ts
  var pos = new Vector3();
  var quat3 = new Quaternion();
  var scale = new Vector3();
  AFRAME.registerComponent("character-camera", {
    init() {
      camera.set(this.el.object3D);
      camera_el.set(this);
      currentVRM.on(($vrm) => {
        if (!$vrm)
          return;
        this.hideHead();
        $vrm.firstPerson.firstPersonBone.add(this.el.object3D);
      });
    },
    showHead() {
      const { layers } = this.el.object3D.children[0];
      this.data.head = true;
      layers.disable(currentVRM.$.firstPerson.firstPersonOnlyLayer);
      layers.enable(currentVRM.$.firstPerson.thirdPersonOnlyLayer);
    },
    hideHead() {
      const { layers } = this.el.object3D.children[0];
      this.data.head = false;
      layers.enable(currentVRM.$.firstPerson.firstPersonOnlyLayer);
      layers.disable(currentVRM.$.firstPerson.thirdPersonOnlyLayer);
    },
    remove() {
      if (currentVRM.$) {
        currentVRM.$?.firstPerson.firstPersonBone.remove(this.el.object3D);
      }
      this.cancel();
    },
    tick(_, dt) {
      if (!currentVRM.$)
        return;
      if (toggle_selfie.$ !== this.selfie) {
        if (toggle_selfie.$) {
          this.showHead();
          this.el.object3D.position.set(0, 0.1, -0.75);
          this.el.object3D.lookAt(0, 5, 0);
        } else {
          this.el.object3D.position.set(0, 0, 0);
          this.el.object3D.quaternion.identity();
          this.hideHead();
        }
        this.selfie = toggle_selfie.$;
      }
    }
  });

  // src/component/copy.ts
  var vec33 = new AFRAME.THREE.Vector3();
  var quat4 = new AFRAME.THREE.Quaternion();
  var scale2 = new AFRAME.THREE.Vector3();
  AFRAME.registerComponent("copy", {
    schema: {
      target: { type: "selector" },
      position: { type: "bool", default: true },
      quaternion: { type: "bool", defualt: true },
      scale: { type: "bool", default: false }
    },
    tick() {
      if (!this.data.target)
        return;
      const o3d = this.el.object3D;
      const o_o3d = this.data.target.object3D;
      o_o3d.updateMatrixWorld();
      o_o3d.matrixWorld.decompose(vec33, quat4, scale2);
      if (this.data.position) {
        o3d.position.copy(vec33);
      }
      if (this.data.quaternion) {
        o3d.quaternion.copy(quat4);
      }
    }
  });

  // src/component/look.ts
  var registerComponent = AFRAME.registerComponent;
  var THREE2 = AFRAME.THREE;
  var utils = AFRAME.utils;
  var PI_2 = Math.PI / 2;
  registerComponent("look", {
    dependencies: ["position", "rotation"],
    schema: {
      enabled: { default: true },
      magicWindowTrackingEnabled: { default: true },
      pointerLockEnabled: { default: false },
      reverseMouseDrag: { default: false },
      reverseTouchDrag: { default: false },
      touchEnabled: { default: true },
      mouseEnabled: { default: true }
    },
    init: function() {
      this.deltaYaw = 0;
      this.previousHMDPosition = new THREE2.Vector3();
      this.hmdQuaternion = new THREE2.Quaternion();
      this.magicWindowAbsoluteEuler = new THREE2.Euler();
      this.magicWindowDeltaEuler = new THREE2.Euler();
      this.position = new THREE2.Vector3();
      this.magicWindowObject = new THREE2.Object3D();
      this.rotation = {};
      this.deltaRotation = {};
      this.savedPose = null;
      this.pointerLocked = false;
      this.setupMouseControls();
      this.bindMethods();
      this.previousMouseEvent = {};
      this.setupMagicWindowControls();
      this.savedPose = {
        position: new THREE2.Vector3(),
        rotation: new THREE2.Euler()
      };
      if (this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) {
        this.onEnterVR();
      }
    },
    setupMagicWindowControls: function() {
      var magicWindowControls;
      var data = this.data;
      if (utils.device.isMobile() || utils.device.isMobileDeviceRequestingDesktopSite()) {
        magicWindowControls = this.magicWindowControls = new THREE2.DeviceOrientationControls(this.magicWindowObject);
        if (typeof DeviceOrientationEvent !== "undefined" && DeviceOrientationEvent.requestPermission) {
          magicWindowControls.enabled = false;
          if (this.el.sceneEl.components["device-orientation-permission-ui"].permissionGranted) {
            magicWindowControls.enabled = data.magicWindowTrackingEnabled;
          } else {
            this.el.sceneEl.addEventListener("deviceorientationpermissiongranted", function() {
              magicWindowControls.enabled = data.magicWindowTrackingEnabled;
            });
          }
        }
      }
    },
    update: function(oldData) {
      var data = this.data;
      if (data.enabled !== oldData.enabled) {
        this.updateGrabCursor(data.enabled);
      }
      if (oldData && !data.magicWindowTrackingEnabled && oldData.magicWindowTrackingEnabled) {
        this.magicWindowAbsoluteEuler.set(0, 0, 0);
        this.magicWindowDeltaEuler.set(0, 0, 0);
      }
      if (this.magicWindowControls) {
        this.magicWindowControls.enabled = data.magicWindowTrackingEnabled;
      }
      if (oldData && !data.pointerLockEnabled !== oldData.pointerLockEnabled) {
        this.removeEventListeners();
        this.addEventListeners();
        if (this.pointerLocked) {
          this.exitPointerLock();
        }
      }
    },
    tick: function(t) {
      var data = this.data;
      if (!data.enabled) {
        return;
      }
      this.updateOrientation();
    },
    play: function() {
      this.addEventListeners();
    },
    pause: function() {
      this.removeEventListeners();
      if (this.pointerLocked) {
        this.exitPointerLock();
      }
    },
    remove: function() {
      this.removeEventListeners();
      if (this.pointerLocked) {
        this.exitPointerLock();
      }
    },
    bindMethods: function() {
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseMove = this.onMouseMove.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.onTouchStart = this.onTouchStart.bind(this);
      this.onTouchMove = this.onTouchMove.bind(this);
      this.onTouchEnd = this.onTouchEnd.bind(this);
      this.onEnterVR = this.onEnterVR.bind(this);
      this.onExitVR = this.onExitVR.bind(this);
      this.onPointerLockChange = this.onPointerLockChange.bind(this);
      this.onPointerLockError = this.onPointerLockError.bind(this);
    },
    setupMouseControls: function() {
      this.mouseDown = false;
      this.pitchObject = new THREE2.Object3D();
      this.yawObject = new THREE2.Object3D();
      this.yawObject.position.y = 10;
      this.yawObject.add(this.pitchObject);
    },
    addEventListeners: function() {
      var sceneEl = this.el.sceneEl;
      var canvasEl = sceneEl.canvas;
      if (!canvasEl) {
        sceneEl.addEventListener("render-target-loaded", this.addEventListeners.bind(this));
        return;
      }
      canvasEl.addEventListener("mousedown", this.onMouseDown, false);
      window.addEventListener("mousemove", this.onMouseMove, false);
      window.addEventListener("mouseup", this.onMouseUp, false);
      canvasEl.addEventListener("touchstart", this.onTouchStart);
      window.addEventListener("touchmove", this.onTouchMove);
      window.addEventListener("touchend", this.onTouchEnd);
      sceneEl.addEventListener("enter-vr", this.onEnterVR);
      sceneEl.addEventListener("exit-vr", this.onExitVR);
      if (this.data.pointerLockEnabled) {
        document.addEventListener("pointerlockchange", this.onPointerLockChange, false);
        document.addEventListener("mozpointerlockchange", this.onPointerLockChange, false);
        document.addEventListener("pointerlockerror", this.onPointerLockError, false);
      }
    },
    removeEventListeners: function() {
      var sceneEl = this.el.sceneEl;
      var canvasEl = sceneEl && sceneEl.canvas;
      if (!canvasEl) {
        return;
      }
      canvasEl.removeEventListener("mousedown", this.onMouseDown);
      window.removeEventListener("mousemove", this.onMouseMove);
      window.removeEventListener("mouseup", this.onMouseUp);
      canvasEl.removeEventListener("touchstart", this.onTouchStart);
      window.removeEventListener("touchmove", this.onTouchMove);
      window.removeEventListener("touchend", this.onTouchEnd);
      sceneEl.removeEventListener("enter-vr", this.onEnterVR);
      sceneEl.removeEventListener("exit-vr", this.onExitVR);
      document.removeEventListener("pointerlockchange", this.onPointerLockChange, false);
      document.removeEventListener("mozpointerlockchange", this.onPointerLockChange, false);
      document.removeEventListener("pointerlockerror", this.onPointerLockError, false);
    },
    updateOrientation: function() {
      var object3D = this.el.object3D;
      var pitchObject = this.pitchObject;
      var yawObject = this.yawObject;
      var sceneEl = this.el.sceneEl;
      if ((sceneEl.is("vr-mode") || sceneEl.is("ar-mode")) && sceneEl.checkHeadsetConnected()) {
        return;
      }
      this.updateMagicWindowOrientation();
      object3D.rotation.x = this.magicWindowDeltaEuler.x + pitchObject.rotation.x;
      object3D.rotation.y = this.magicWindowDeltaEuler.y + yawObject.rotation.y;
      object3D.rotation.z = this.magicWindowDeltaEuler.z;
    },
    updateMagicWindowOrientation: function() {
      var magicWindowAbsoluteEuler = this.magicWindowAbsoluteEuler;
      var magicWindowDeltaEuler = this.magicWindowDeltaEuler;
      if (this.magicWindowControls && this.magicWindowControls.enabled) {
        this.magicWindowControls.update();
        magicWindowAbsoluteEuler.setFromQuaternion(this.magicWindowObject.quaternion, "YXZ");
        if (!this.previousMagicWindowYaw && magicWindowAbsoluteEuler.y !== 0) {
          this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y;
        }
        if (this.previousMagicWindowYaw) {
          magicWindowDeltaEuler.x = magicWindowAbsoluteEuler.x;
          magicWindowDeltaEuler.y += magicWindowAbsoluteEuler.y - this.previousMagicWindowYaw;
          magicWindowDeltaEuler.z = magicWindowAbsoluteEuler.z;
          this.previousMagicWindowYaw = magicWindowAbsoluteEuler.y;
        }
      }
    },
    onMouseMove: function(evt) {
      var direction;
      var movementX;
      var movementY;
      var pitchObject = this.pitchObject;
      var previousMouseEvent = this.previousMouseEvent;
      var yawObject = this.yawObject;
      if (!this.data.enabled || !this.mouseDown && !this.pointerLocked) {
        return;
      }
      if (this.pointerLocked) {
        movementX = evt.movementX || evt.mozMovementX || 0;
        movementY = evt.movementY || evt.mozMovementY || 0;
      } else {
        movementX = evt.screenX - previousMouseEvent.screenX;
        movementY = evt.screenY - previousMouseEvent.screenY;
      }
      this.previousMouseEvent.screenX = evt.screenX;
      this.previousMouseEvent.screenY = evt.screenY;
      direction = this.data.reverseMouseDrag ? 1 : -1;
      yawObject.rotation.y += movementX * 2e-3 * direction;
      pitchObject.rotation.x += movementY * 2e-3 * direction;
      pitchObject.rotation.x = Math.max(-PI_2 / 3, Math.min(PI_2 / 3, pitchObject.rotation.x));
    },
    onMouseDown: function(evt) {
      var sceneEl = this.el.sceneEl;
      if (!this.data.enabled || !this.data.mouseEnabled || (sceneEl.is("vr-mode") || sceneEl.is("ar-mode")) && sceneEl.checkHeadsetConnected()) {
        return;
      }
      if (evt.button !== 0) {
        return;
      }
      var canvasEl = sceneEl && sceneEl.canvas;
      this.mouseDown = true;
      this.previousMouseEvent.screenX = evt.screenX;
      this.previousMouseEvent.screenY = evt.screenY;
      this.showGrabbingCursor();
      if (this.data.pointerLockEnabled && !this.pointerLocked) {
        if (canvasEl.requestPointerLock) {
          canvasEl.requestPointerLock();
        } else if (canvasEl.mozRequestPointerLock) {
          canvasEl.mozRequestPointerLock();
        }
      }
    },
    showGrabbingCursor: function() {
      this.el.sceneEl.canvas.style.cursor = "grabbing";
    },
    hideGrabbingCursor: function() {
      this.el.sceneEl.canvas.style.cursor = "";
    },
    onMouseUp: function() {
      this.mouseDown = false;
      this.hideGrabbingCursor();
    },
    onTouchStart: function(evt) {
      if (evt.touches.length !== 1 || !this.data.touchEnabled || this.el.sceneEl.is("vr-mode") || this.el.sceneEl.is("ar-mode")) {
        return;
      }
      this.touchStart = {
        x: evt.touches[0].pageX,
        y: evt.touches[0].pageY
      };
      this.touchStarted = true;
    },
    onTouchMove: function(evt) {
      var direction;
      var canvas = this.el.sceneEl.canvas;
      var deltaY;
      var yawObject = this.yawObject;
      if (!this.touchStarted || !this.data.touchEnabled) {
        return;
      }
      deltaY = 2 * Math.PI * (evt.touches[0].pageX - this.touchStart.x) / canvas.clientWidth;
      direction = this.data.reverseTouchDrag ? 1 : -1;
      yawObject.rotation.y -= deltaY * 0.5 * direction;
      this.touchStart = {
        x: evt.touches[0].pageX,
        y: evt.touches[0].pageY
      };
    },
    onTouchEnd: function() {
      this.touchStarted = false;
    },
    onEnterVR: function() {
      var sceneEl = this.el.sceneEl;
      if (!sceneEl.checkHeadsetConnected()) {
        return;
      }
      this.saveCameraPose();
      this.el.object3D.position.set(0, 0, 0);
      this.el.object3D.rotation.set(0, 0, 0);
      if (sceneEl.hasWebXR) {
        this.el.object3D.matrixAutoUpdate = false;
        this.el.object3D.updateMatrix();
      }
    },
    onExitVR: function() {
      if (!this.el.sceneEl.checkHeadsetConnected()) {
        return;
      }
      this.restoreCameraPose();
      this.previousHMDPosition.set(0, 0, 0);
      this.el.object3D.matrixAutoUpdate = true;
    },
    onPointerLockChange: function() {
      this.pointerLocked = !!(document.pointerLockElement || document.mozPointerLockElement);
    },
    onPointerLockError: function() {
      this.pointerLocked = false;
    },
    exitPointerLock: function() {
      document.exitPointerLock();
      this.pointerLocked = false;
    },
    updateGrabCursor: function(enabled) {
      var sceneEl = this.el.sceneEl;
      function enableGrabCursor() {
        sceneEl.canvas.classList.add("a-grab-cursor");
      }
      function disableGrabCursor() {
        sceneEl.canvas.classList.remove("a-grab-cursor");
      }
      if (!sceneEl.canvas) {
        if (enabled) {
          sceneEl.addEventListener("render-target-loaded", enableGrabCursor);
        } else {
          sceneEl.addEventListener("render-target-loaded", disableGrabCursor);
        }
        return;
      }
      if (enabled) {
        enableGrabCursor();
        return;
      }
      disableGrabCursor();
    },
    saveCameraPose: function() {
      var el = this.el;
      this.savedPose.position.copy(el.object3D.position);
      this.savedPose.rotation.copy(el.object3D.rotation);
      this.hasSavedPose = true;
    },
    restoreCameraPose: function() {
      var el = this.el;
      var savedPose = this.savedPose;
      if (!this.hasSavedPose) {
        return;
      }
      el.object3D.position.copy(savedPose.position);
      el.object3D.rotation.copy(savedPose.rotation);
      this.hasSavedPose = false;
    }
  });

  // src/camera.svelte
  function create_if_block(ctx) {
    let a_entity;
    let a_entity_material_value;
    let mounted;
    let dispose;
    return {
      c() {
        a_entity = element("a-entity");
        set_custom_element_data(a_entity, "geometry", "");
        set_custom_element_data(a_entity, "material", a_entity_material_value = "wireframe: true; opacity: 0.05s;color: #0F0; shader: flat;transparent: true; visible: " + ctx[3] + " };");
        set_custom_element_data(a_entity, "scale", "0.1 0.1 20");
        set_custom_element_data(a_entity, "position", "0 0 -1");
        set_custom_element_data(a_entity, "ammo-body", "type: kinematic;disableCollision: true;emitCollisionEvents: true;collisionFilterMask: 3;");
        set_custom_element_data(a_entity, "ammo-shape", "type: box; halfExtents: 0.05 0.05 6;offset: 0 0 -9.5");
      },
      m(target, anchor) {
        insert(target, a_entity, anchor);
        if (!mounted) {
          dispose = [
            listen(a_entity, "collidestart", ctx[4]),
            listen(a_entity, "collideend", ctx[5])
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 8 && a_entity_material_value !== (a_entity_material_value = "wireframe: true; opacity: 0.05s;color: #0F0; shader: flat;transparent: true; visible: " + ctx2[3] + " };")) {
          set_custom_element_data(a_entity, "material", a_entity_material_value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(a_entity);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_fragment4(ctx) {
    let a_mixin;
    let t0;
    let a_camera;
    let a_entity0;
    let a_entity0_visible_value;
    let t1;
    let t2;
    let a_entity1;
    let if_block = ctx[3] && create_if_block(ctx);
    return {
      c() {
        a_mixin = element("a-mixin");
        t0 = space();
        a_camera = element("a-camera");
        a_entity0 = element("a-entity");
        t1 = space();
        if (if_block)
          if_block.c();
        t2 = space();
        a_entity1 = element("a-entity");
        set_custom_element_data(a_mixin, "id", "bbs");
        set_custom_element_data(a_mixin, "geometry", "");
        set_custom_element_data(a_mixin, "material", " opacity: 0.15; color: #00ff00; transparent: true; shader: flat;");
        set_custom_element_data(a_mixin, "text", "font: ./Roboto-msdf.json; value: targeting info");
        set_custom_element_data(a_entity0, "geometry", "primitive: box; width: 0.4; height: 0.4; depth: 0.1");
        set_custom_element_data(a_entity0, "material", "shader: flat; transparent: true; opacity: 0.5; color: #006ace");
        set_custom_element_data(a_entity0, "position", "0 -0.2 -0.5");
        set_custom_element_data(a_entity0, "rotation", "-40 0 0");
        set_custom_element_data(a_entity0, "visible", a_entity0_visible_value = ctx[1] || ctx[2]);
        set_custom_element_data(a_camera, "active", "");
        set_custom_element_data(a_camera, "fov", "85");
        set_custom_element_data(a_camera, "id", "camera");
        set_custom_element_data(a_camera, "character-camera", "");
        set_custom_element_data(a_camera, "far", "50000");
        set_custom_element_data(a_camera, "position", "0 4 0");
        set_custom_element_data(a_camera, "wasd-controls", "enabled: false;");
        set_custom_element_data(a_camera, "look", "enabled: true;pointerLockEnabled: true; magicWindowTrackingEnabled: false; reverseTouchDrag: true;");
        set_custom_element_data(a_camera, "look-controls", "enabled: false;");
        set_custom_element_data(a_entity1, "geometry", "");
        set_custom_element_data(a_entity1, "material", "color: blue; opacity: 0.15; shader: flat; visible: false;");
        set_custom_element_data(a_entity1, "position", "0 0 -1");
        set_custom_element_data(a_entity1, "pool__targeting", "mixin: bbs; size: 10");
      },
      m(target, anchor) {
        insert(target, a_mixin, anchor);
        insert(target, t0, anchor);
        insert(target, a_camera, anchor);
        append(a_camera, a_entity0);
        append(a_camera, t1);
        if (if_block)
          if_block.m(a_camera, null);
        insert(target, t2, anchor);
        insert(target, a_entity1, anchor);
        ctx[6](a_entity1);
      },
      p(ctx2, [dirty]) {
        if (dirty & 6 && a_entity0_visible_value !== (a_entity0_visible_value = ctx2[1] || ctx2[2])) {
          set_custom_element_data(a_entity0, "visible", a_entity0_visible_value);
        }
        if (ctx2[3]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block(ctx2);
            if_block.c();
            if_block.m(a_camera, null);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_mixin);
        if (detaching)
          detach(t0);
        if (detaching)
          detach(a_camera);
        if (if_block)
          if_block.d();
        if (detaching)
          detach(t2);
        if (detaching)
          detach(a_entity1);
        ctx[6](null);
      }
    };
  }
  function instance3($$self, $$props, $$invalidate) {
    let $open_loading;
    let $open_help;
    let $open_targeting;
    component_subscribe($$self, open_loading, ($$value) => $$invalidate(1, $open_loading = $$value));
    component_subscribe($$self, open_help, ($$value) => $$invalidate(2, $open_help = $$value));
    component_subscribe($$self, open_targeting, ($$value) => $$invalidate(3, $open_targeting = $$value));
    let el;
    open_targeting.on(($t) => {
      if (!$t)
        return;
    });
    const ents = {};
    const box = new AFRAME.THREE.Box3();
    open_targeting.on((t) => {
      if (!t) {
        Object.values(ents).forEach((e) => {
          el.components.pool__targeting.returnEntity(e);
          delete ents[e.object3D.uuid];
        });
      }
    });
    function collidestart(e) {
      const who = e.detail.targetEl;
      if (who.id === "ground")
        return;
      const keys = Object.keys(ents);
      if (keys.length >= 10) {
        const key = keys[Math.floor(Math.random() * keys.length)];
        el.components.pool__targeting.returnEntity(ents[key]);
        delete ents[key];
      }
      const ent = el.components.pool__targeting.requestEntity();
      ent.play();
      ents[who.object3D.uuid] = ent;
      box.setFromObject(who.object3D);
      box.getSize(ent.object3D.scale);
      box.getCenter(ent.object3D.position);
    }
    function collideend(e) {
      const who = e.detail.targetEl;
      if (!ents[who.object3D.uuid])
        return;
      el.components.pool__targeting.returnEntity(ents[who.object3D.uuid]);
      delete ents[who.object3D.uuid];
    }
    function a_entity1_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        el = $$value;
        $$invalidate(0, el);
      });
    }
    return [
      el,
      $open_loading,
      $open_help,
      $open_targeting,
      collidestart,
      collideend,
      a_entity1_binding
    ];
  }
  var Camera3 = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance3, create_fragment4, safe_not_equal, {});
    }
  };
  var camera_default = Camera3;

  // src/ui/heard.svelte
  function create_fragment5(ctx) {
    let div;
    let input;
    let div_class_value;
    return {
      c() {
        div = element("div");
        input = element("input");
        attr(input, "type", "text");
        attr(input, "class", "entry svelte-rqoyr3");
        input.readOnly = true;
        attr(div, "class", div_class_value = "lofi " + (ctx[1] ? "mobile" : "") + " svelte-rqoyr3");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, input);
        ctx[2](input);
      },
      p(ctx2, [dirty]) {
        if (dirty & 2 && div_class_value !== (div_class_value = "lofi " + (ctx2[1] ? "mobile" : "") + " svelte-rqoyr3")) {
          attr(div, "class", div_class_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        ctx[2](null);
      }
    };
  }
  function instance4($$self, $$props, $$invalidate) {
    let $ismobile;
    component_subscribe($$self, ismobile, ($$value) => $$invalidate(1, $ismobile = $$value));
    let text2;
    talk.on(() => {
      if (!text2 || !talk.$)
        return;
      $$invalidate(0, text2.value = talk.$, text2);
    });
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        text2 = $$value;
        $$invalidate(0, text2);
      });
    }
    return [text2, $ismobile, input_binding];
  }
  var Heard = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance4, create_fragment5, safe_not_equal, {});
    }
  };
  var heard_default = Heard;

  // src/shader/floaty.vert
  var floaty_default = "// time uniform\nvec4 Floaty(in vec4 v) {\n    float t = time * 0.00005 + v.x*v.y*v.z / 100.;\n    float dst = 100.;\n    v.x += sin(t) * dst + cos(t * 2.) * dst;\n    v.y += cos(t) * dst/100. ;\n    v.z += sin(t) * dst+ sin(t * 2.) * dst;\n    return v;\n}";

  // src/component/floaty.ts
  var main = `
vec4 mvPosition = vec4(transformed, 1.0);

mvPosition = modelViewMatrix * Floaty(mvPosition);
mvPosition = projectionMatrix * mvPosition;
gl_Position = mvPosition;
`;
  AFRAME.registerComponent("floaty", {
    init() {
      this.setup = this.setup.bind(this);
      this.setup();
      this.el.addEventListener("model-loaded", this.setup);
    },
    remove() {
      this.el.removeEventListener("model-loaded", this.setup);
    },
    setup() {
      this.el.object3D.traverse((c) => {
        if (c.material) {
          const prev = c.material.onBeforeCompile;
          c.material.onBeforeCompile = (shader) => {
            if (!shader.uniforms.time) {
              shader.uniforms.time = time.$;
              shader.vertexShader = shader.vertexShader.replace("#include <common>", [
                "#include <common>",
                "uniform float time;",
                floaty_default
              ].join("\n")).replace("#include <project_vertex>", main);
            } else {
              shader.vertexShader = shader.vertexShader.replace("#include <common>", [
                "#include <common>",
                floaty_default
              ].join("\n")).replace("(mvPosition);", "(Floaty(mvPosition));");
            }
            if (prev) {
              prev(shader);
            }
          };
          c.material.needsUpdate = true;
        }
      });
    }
  });

  // src/shader/windy.vert
  var windy_default = "vec4 Windy(in vec4 v) {\n    float t = -time * 0.0005 + v.x*v.y*v.z*100.;\n    float dst = 0.025;\n    v.x += sin(t) * dst;\n    v.y += cos(t) * dst/10.;\n    v.z += sin(t) * dst;\n    return v; \n}";

  // src/component/windy.ts
  var main2 = `
vec4 mvPosition = vec4(transformed, 1.0);

mvPosition = modelViewMatrix * Windy(mvPosition);
mvPosition = projectionMatrix * mvPosition;
gl_Position = mvPosition;
`;
  AFRAME.registerComponent("windy", {
    init() {
      this.setup = this.setup.bind(this);
      this.setup();
      this.el.addEventListener("model-loaded", this.setup);
    },
    remove() {
      this.el.removeEventListener("model-loaded", this.setup);
    },
    setup() {
      this.el.object3D.traverse((c) => {
        if (c.material) {
          const prev = c.material.onBeforeCompile;
          c.material.onBeforeCompile = (shader) => {
            if (!shader.uniforms.time) {
              shader.uniforms.time = time.$;
              shader.vertexShader = shader.vertexShader.replace("#include <common>", [
                "#include <common>",
                "uniform float time;",
                windy_default
              ].join("\n")).replace("#include <project_vertex>", main2);
            } else {
              shader.vertexShader = shader.vertexShader.replace("#include <common>", [
                "#include <common>",
                windy_default
              ].join("\n")).replace("(mvPosition);", "(Windy(mvPosition));");
            }
            if (prev) {
              prev(shader);
            }
          };
          c.material.needsUpdate = true;
        }
      });
    }
  });

  // src/component/ai.ts
  AFRAME.registerComponent("ai", {
    schema: {
      type: { type: "string", default: "random" }
    },
    init() {
      this.tick = AFRAME.utils.throttleTick(this.tick, 250, this);
    },
    tick() {
      if (this[this.data.type])
        this[this.data.type]();
    },
    random() {
      if (!this.el.body || guest.$)
        return;
      const speed = 250;
      const x = (Math.random() - 0.5) * speed, y = (Math.random() - 0.5) * speed, z = (Math.random() - 0.5) * speed;
      const force = new Ammo.btVector3(x, y, z);
      this.el.body.applyForce(force);
      const torq = new Ammo.btVector3(x * 0.2, y * 0.2, z * 0.2);
      this.el.body.applyTorque(torq);
      this.el.body.activate();
      Ammo.destroy(force);
      Ammo.destroy(torq);
    }
  });

  // src/node/forest.svelte
  function create_fragment6(ctx) {
    let a_mixin0;
    let t0;
    let a_mixin1;
    let t1;
    let a_mixin2;
    let t2;
    let a_mixin3;
    let t3;
    let a_mixin4;
    let t4;
    let a_mixin5;
    let t5;
    let a_mixin6;
    let a_mixin6_ring_value;
    let t6;
    let a_entity0;
    let t7;
    let a_mixin7;
    let t8;
    let a_entity1;
    let t9;
    let a_entity2;
    let t10;
    let a_mixin8;
    let t11;
    let a_entity3;
    let t12;
    let a_entity4;
    let t13;
    let a_entity5;
    let t14;
    let a_entity6;
    let t15;
    let a_mixin9;
    let t16;
    let a_mixin10;
    let t17;
    let a_mixin11;
    let t18;
    let a_mixin12;
    let t19;
    let a_entity7;
    let t20;
    let a_entity8;
    let t21;
    let a_entity9;
    let t22;
    let a_entity10;
    let t23;
    let a_mixin13;
    let t24;
    let a_entity11;
    let t25;
    let a_mixin14;
    let t26;
    let a_entity12;
    let t27;
    let a_mixin15;
    let t28;
    let a_entity13;
    let a_mixin7_levels = [
      { id: "tree" },
      { class: "climbable" },
      { shadow: "receive: false" },
      { windy: "" },
      { "gltf-model": "./glb/tree.glb" },
      { scatter: ctx[1] },
      {
        vary: "property: scale; range: 4 2 4 8 10 8"
      },
      ctx[2],
      { host: "" }
    ];
    let a_mixin7_data = {};
    for (let i = 0; i < a_mixin7_levels.length; i += 1) {
      a_mixin7_data = assign(a_mixin7_data, a_mixin7_levels[i]);
    }
    let a_mixin13_levels = [
      { id: "trunk" },
      ctx[3],
      { "gltf-model": "./glb/trunk.glb" },
      { vary: trunkVary },
      { scatter: ctx[1] }
    ];
    let a_mixin13_data = {};
    for (let i = 0; i < a_mixin13_levels.length; i += 1) {
      a_mixin13_data = assign(a_mixin13_data, a_mixin13_levels[i]);
    }
    let a_mixin14_levels = [
      { id: "trunkLong" },
      ctx[3],
      { "gltf-model": "./glb/trunkLong.glb" },
      { vary: trunkVary },
      { scatter: ctx[1] }
    ];
    let a_mixin14_data = {};
    for (let i = 0; i < a_mixin14_levels.length; i += 1) {
      a_mixin14_data = assign(a_mixin14_data, a_mixin14_levels[i]);
    }
    let a_mixin15_levels = [
      { id: "pillarObelisk" },
      { "gltf-model": "./glb/pillarObelisk.glb" },
      ctx[3],
      { vary: trunkVary },
      { scatter: ctx[1] }
    ];
    let a_mixin15_data = {};
    for (let i = 0; i < a_mixin15_levels.length; i += 1) {
      a_mixin15_data = assign(a_mixin15_data, a_mixin15_levels[i]);
    }
    return {
      c() {
        a_mixin0 = element("a-mixin");
        t0 = space();
        a_mixin1 = element("a-mixin");
        t1 = space();
        a_mixin2 = element("a-mixin");
        t2 = space();
        a_mixin3 = element("a-mixin");
        t3 = space();
        a_mixin4 = element("a-mixin");
        t4 = space();
        a_mixin5 = element("a-mixin");
        t5 = space();
        a_mixin6 = element("a-mixin");
        t6 = space();
        a_entity0 = element("a-entity");
        t7 = space();
        a_mixin7 = element("a-mixin");
        t8 = space();
        a_entity1 = element("a-entity");
        t9 = space();
        a_entity2 = element("a-entity");
        t10 = space();
        a_mixin8 = element("a-mixin");
        t11 = space();
        a_entity3 = element("a-entity");
        t12 = space();
        a_entity4 = element("a-entity");
        t13 = space();
        a_entity5 = element("a-entity");
        t14 = space();
        a_entity6 = element("a-entity");
        t15 = space();
        a_mixin9 = element("a-mixin");
        t16 = space();
        a_mixin10 = element("a-mixin");
        t17 = space();
        a_mixin11 = element("a-mixin");
        t18 = space();
        a_mixin12 = element("a-mixin");
        t19 = space();
        a_entity7 = element("a-entity");
        t20 = space();
        a_entity8 = element("a-entity");
        t21 = space();
        a_entity9 = element("a-entity");
        t22 = space();
        a_entity10 = element("a-entity");
        t23 = space();
        a_mixin13 = element("a-mixin");
        t24 = space();
        a_entity11 = element("a-entity");
        t25 = space();
        a_mixin14 = element("a-mixin");
        t26 = space();
        a_entity12 = element("a-entity");
        t27 = space();
        a_mixin15 = element("a-mixin");
        t28 = space();
        a_entity13 = element("a-entity");
        set_custom_element_data(a_mixin0, "id", "smolitem");
        set_custom_element_data(a_mixin0, "ammo-body", "type: static; mass: 0;collisionFilterGroup: 2;");
        set_custom_element_data(a_mixin0, "ammo-shape", "type: sphere; fit: manual; sphereRadius: 1;");
        set_custom_element_data(a_mixin1, "id", "smolfix");
        set_custom_element_data(a_mixin1, "ammo-shape", "offset: -1.85 0 0.85;");
        set_custom_element_data(a_mixin2, "id", "flowers");
        set_custom_element_data(a_mixin2, "mixin", "smolitem smolfix");
        set_custom_element_data(a_mixin2, "shadow", "");
        set_custom_element_data(a_mixin2, "gltf-model", "./glb/flowers.glb");
        set_custom_element_data(a_mixin2, "windy", "");
        set_custom_element_data(a_mixin2, "scatter", ctx[1]);
        set_custom_element_data(a_mixin2, "vary", vary);
        set_custom_element_data(a_mixin2, "host", "flowers");
        set_custom_element_data(a_mixin3, "id", "mushroom");
        set_custom_element_data(a_mixin3, "mixin", "smolitem smolfix");
        set_custom_element_data(a_mixin3, "shadow", "");
        set_custom_element_data(a_mixin3, "gltf-model", "./glb/mushrooms.glb");
        set_custom_element_data(a_mixin3, "windy", "");
        set_custom_element_data(a_mixin3, "scatter", ctx[1]);
        set_custom_element_data(a_mixin3, "vary", vary);
        set_custom_element_data(a_mixin3, "host", "mushroom");
        set_custom_element_data(a_mixin4, "id", "flowersLow");
        set_custom_element_data(a_mixin4, "mixin", "smolitem smolfix");
        set_custom_element_data(a_mixin4, "shadow", "");
        set_custom_element_data(a_mixin4, "gltf-model", "./glb/flowersLow.glb");
        set_custom_element_data(a_mixin4, "windy", "");
        set_custom_element_data(a_mixin4, "scatter", ctx[1]);
        set_custom_element_data(a_mixin4, "vary", vary);
        set_custom_element_data(a_mixin4, "host", "flowersLow");
        set_custom_element_data(a_mixin5, "id", "rock");
        set_custom_element_data(a_mixin5, "shadow", "");
        set_custom_element_data(a_mixin5, "vary", "property: scale; range: 0.5 0.25 0.5 2 1 2");
        set_custom_element_data(a_mixin5, "scatter", ctx[1]);
        set_custom_element_data(a_mixin5, "gltf-model", "./glb/rockB.glb");
        set_custom_element_data(a_mixin5, "ammo-body", "type: static; mass: 0");
        set_custom_element_data(a_mixin5, "host", "");
        set_custom_element_data(a_mixin5, "ammo-shape", "type: sphere; fit: manual; sphereRadius: 1.5 ");
        set_custom_element_data(a_mixin6, "id", "mountains");
        set_custom_element_data(a_mixin6, "shadow", "");
        set_custom_element_data(a_mixin6, "host", "");
        set_custom_element_data(a_mixin6, "gltf-model", "./glb/rockC.glb");
        set_custom_element_data(a_mixin6, "ring", a_mixin6_ring_value = "radius: " + ctx[0] * 0.7 + "; count: 50");
        set_custom_element_data(a_mixin6, "ammo-body", "type: static; mass: 0;");
        set_custom_element_data(a_mixin6, "vary", "property: scale; range: 12 2 12 15 20 15");
        set_custom_element_data(a_mixin6, "ammo-shape", "type: box;fit: manual; halfExtents:15 7.5 15; offset: 0 7.5 0");
        set_custom_element_data(a_entity0, "pool__mountains", "mixin: mountains; size: 50");
        set_custom_element_data(a_entity0, "activate__mountains", "");
        set_attributes(a_mixin7, a_mixin7_data);
        set_custom_element_data(a_entity1, "pool__tree", "mixin: tree; size: 150");
        set_custom_element_data(a_entity1, "activate__tree", "");
        set_custom_element_data(a_entity2, "pool__mushroom", "mixin: mushroom; size: 20");
        set_custom_element_data(a_entity2, "activate__mushroom", "");
        set_custom_element_data(a_mixin8, "id", "grass");
        set_custom_element_data(a_mixin8, "windy", "");
        set_custom_element_data(a_mixin8, "mixin", "smolitem");
        set_custom_element_data(a_mixin8, "gltf-model", "./glb/grass.glb");
        set_custom_element_data(a_mixin8, "shadow", "");
        set_custom_element_data(a_mixin8, "scatter", ctx[1]);
        set_custom_element_data(a_mixin8, "host", "grass");
        set_custom_element_data(a_mixin8, "vary", "property: scale; range: 1 0.5 1 1.5 1.5 1.5");
        set_custom_element_data(a_entity3, "pool__grass", "mixin: grass; size: 50");
        set_custom_element_data(a_entity3, "activate__grass", "");
        set_custom_element_data(a_entity4, "pool__rock", "mixin: rock; size: 50");
        set_custom_element_data(a_entity4, "activate__rock", "");
        set_custom_element_data(a_entity5, "pool__flowers", "mixin: flowers; size: 50");
        set_custom_element_data(a_entity5, "activate__flowers", "");
        set_custom_element_data(a_entity6, "pool__flowerslow", "mixin: flowersLow; size: 50");
        set_custom_element_data(a_entity6, "activate__flowerslow", "");
        set_custom_element_data(a_mixin9, "id", "animal");
        set_custom_element_data(a_mixin9, "gltf-model", "./char/Horse.glb");
        set_custom_element_data(a_mixin9, "ammo-body", "type: dynamic; mass: 1; linearDamping: 0.5; angularDamping: 0.98;angularFactor: 0 1 0;");
        set_custom_element_data(a_mixin9, "scale", "0.35 0.35 0.35");
        set_custom_element_data(a_mixin9, "ammo-shape", "type: capsule; fit: manual; halfExtents: 0.6 0.4 0.2; cylinderAxis: z; offset: 0 0.5 0");
        set_custom_element_data(a_mixin9, "shadow", "cast: true; receive: false;");
        set_custom_element_data(a_mixin9, "ai", "type: random;");
        set_custom_element_data(a_mixin9, "motion-events", "");
        set_custom_element_data(a_mixin9, "gltf-events", "");
        set_custom_element_data(a_mixin9, "animate", "property:scale; from: 1 1 1; to: 1.1 1.1 1.1; dir: alternate; loop: true;");
        set_custom_element_data(a_mixin9, "material", "shader: flat;");
        set_custom_element_data(a_mixin9, "host", "horse");
        set_custom_element_data(a_mixin9, "scatter", ctx[1]);
        set_custom_element_data(a_mixin10, "id", "sheep");
        set_custom_element_data(a_mixin10, "host", "sheep");
        set_custom_element_data(a_mixin10, "gltf-model", "./char/Sheep.glb");
        set_custom_element_data(a_mixin11, "id", "cow");
        set_custom_element_data(a_mixin11, "host", "cow");
        set_custom_element_data(a_mixin11, "gltf-model", "./char/Cow.glb");
        set_custom_element_data(a_mixin12, "id", "frog");
        set_custom_element_data(a_mixin12, "host", "frog");
        set_custom_element_data(a_mixin12, "gltf-model", "./char/easy_Frog.glb");
        set_custom_element_data(a_mixin12, "color", "white");
        set_custom_element_data(a_entity7, "pool__horse", "mixin: animal; size: 5;");
        set_custom_element_data(a_entity7, "activate__horse", "");
        set_custom_element_data(a_entity8, "pool__sheep", "mixin: animal sheep; size: 5;");
        set_custom_element_data(a_entity8, "activate__sheep", "");
        set_custom_element_data(a_entity9, "pool__animal", "mixin: animal cow; size: 5;");
        set_custom_element_data(a_entity9, "activate__animal", "");
        set_custom_element_data(a_entity10, "pool__animal", "mixin: animal frog; size: 5;");
        set_custom_element_data(a_entity10, "activate__animal", "");
        set_attributes(a_mixin13, a_mixin13_data);
        set_custom_element_data(a_entity11, "pool__trunk", "mixin: trunk; size: 20");
        set_custom_element_data(a_entity11, "activate__trunk", "");
        set_attributes(a_mixin14, a_mixin14_data);
        set_custom_element_data(a_entity12, "pool__trunklong", "mixin: trunkLong; size: 20");
        set_custom_element_data(a_entity12, "activate__trunklong", "");
        set_attributes(a_mixin15, a_mixin15_data);
        set_custom_element_data(a_entity13, "pool__pillarobelisk", "mixin: pillarObelisk; size: 5");
        set_custom_element_data(a_entity13, "activate__pillarobelisk", "");
      },
      m(target, anchor) {
        insert(target, a_mixin0, anchor);
        insert(target, t0, anchor);
        insert(target, a_mixin1, anchor);
        insert(target, t1, anchor);
        insert(target, a_mixin2, anchor);
        insert(target, t2, anchor);
        insert(target, a_mixin3, anchor);
        insert(target, t3, anchor);
        insert(target, a_mixin4, anchor);
        insert(target, t4, anchor);
        insert(target, a_mixin5, anchor);
        insert(target, t5, anchor);
        insert(target, a_mixin6, anchor);
        insert(target, t6, anchor);
        insert(target, a_entity0, anchor);
        insert(target, t7, anchor);
        insert(target, a_mixin7, anchor);
        insert(target, t8, anchor);
        insert(target, a_entity1, anchor);
        insert(target, t9, anchor);
        insert(target, a_entity2, anchor);
        insert(target, t10, anchor);
        insert(target, a_mixin8, anchor);
        insert(target, t11, anchor);
        insert(target, a_entity3, anchor);
        insert(target, t12, anchor);
        insert(target, a_entity4, anchor);
        insert(target, t13, anchor);
        insert(target, a_entity5, anchor);
        insert(target, t14, anchor);
        insert(target, a_entity6, anchor);
        insert(target, t15, anchor);
        insert(target, a_mixin9, anchor);
        insert(target, t16, anchor);
        insert(target, a_mixin10, anchor);
        insert(target, t17, anchor);
        insert(target, a_mixin11, anchor);
        insert(target, t18, anchor);
        insert(target, a_mixin12, anchor);
        insert(target, t19, anchor);
        insert(target, a_entity7, anchor);
        insert(target, t20, anchor);
        insert(target, a_entity8, anchor);
        insert(target, t21, anchor);
        insert(target, a_entity9, anchor);
        insert(target, t22, anchor);
        insert(target, a_entity10, anchor);
        insert(target, t23, anchor);
        insert(target, a_mixin13, anchor);
        insert(target, t24, anchor);
        insert(target, a_entity11, anchor);
        insert(target, t25, anchor);
        insert(target, a_mixin14, anchor);
        insert(target, t26, anchor);
        insert(target, a_entity12, anchor);
        insert(target, t27, anchor);
        insert(target, a_mixin15, anchor);
        insert(target, t28, anchor);
        insert(target, a_entity13, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & 1 && a_mixin6_ring_value !== (a_mixin6_ring_value = "radius: " + ctx2[0] * 0.7 + "; count: 50")) {
          set_custom_element_data(a_mixin6, "ring", a_mixin6_ring_value);
        }
        set_attributes(a_mixin7, a_mixin7_data = get_spread_update(a_mixin7_levels, [
          { id: "tree" },
          { class: "climbable" },
          { shadow: "receive: false" },
          { windy: "" },
          { "gltf-model": "./glb/tree.glb" },
          { scatter: ctx2[1] },
          {
            vary: "property: scale; range: 4 2 4 8 10 8"
          },
          ctx2[2],
          { host: "" }
        ]));
        set_attributes(a_mixin13, a_mixin13_data = get_spread_update(a_mixin13_levels, [
          { id: "trunk" },
          ctx2[3],
          { "gltf-model": "./glb/trunk.glb" },
          { vary: trunkVary },
          { scatter: ctx2[1] }
        ]));
        set_attributes(a_mixin14, a_mixin14_data = get_spread_update(a_mixin14_levels, [
          { id: "trunkLong" },
          ctx2[3],
          { "gltf-model": "./glb/trunkLong.glb" },
          { vary: trunkVary },
          { scatter: ctx2[1] }
        ]));
        set_attributes(a_mixin15, a_mixin15_data = get_spread_update(a_mixin15_levels, [
          { id: "pillarObelisk" },
          { "gltf-model": "./glb/pillarObelisk.glb" },
          ctx2[3],
          { vary: trunkVary },
          { scatter: ctx2[1] }
        ]));
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_mixin0);
        if (detaching)
          detach(t0);
        if (detaching)
          detach(a_mixin1);
        if (detaching)
          detach(t1);
        if (detaching)
          detach(a_mixin2);
        if (detaching)
          detach(t2);
        if (detaching)
          detach(a_mixin3);
        if (detaching)
          detach(t3);
        if (detaching)
          detach(a_mixin4);
        if (detaching)
          detach(t4);
        if (detaching)
          detach(a_mixin5);
        if (detaching)
          detach(t5);
        if (detaching)
          detach(a_mixin6);
        if (detaching)
          detach(t6);
        if (detaching)
          detach(a_entity0);
        if (detaching)
          detach(t7);
        if (detaching)
          detach(a_mixin7);
        if (detaching)
          detach(t8);
        if (detaching)
          detach(a_entity1);
        if (detaching)
          detach(t9);
        if (detaching)
          detach(a_entity2);
        if (detaching)
          detach(t10);
        if (detaching)
          detach(a_mixin8);
        if (detaching)
          detach(t11);
        if (detaching)
          detach(a_entity3);
        if (detaching)
          detach(t12);
        if (detaching)
          detach(a_entity4);
        if (detaching)
          detach(t13);
        if (detaching)
          detach(a_entity5);
        if (detaching)
          detach(t14);
        if (detaching)
          detach(a_entity6);
        if (detaching)
          detach(t15);
        if (detaching)
          detach(a_mixin9);
        if (detaching)
          detach(t16);
        if (detaching)
          detach(a_mixin10);
        if (detaching)
          detach(t17);
        if (detaching)
          detach(a_mixin11);
        if (detaching)
          detach(t18);
        if (detaching)
          detach(a_mixin12);
        if (detaching)
          detach(t19);
        if (detaching)
          detach(a_entity7);
        if (detaching)
          detach(t20);
        if (detaching)
          detach(a_entity8);
        if (detaching)
          detach(t21);
        if (detaching)
          detach(a_entity9);
        if (detaching)
          detach(t22);
        if (detaching)
          detach(a_entity10);
        if (detaching)
          detach(t23);
        if (detaching)
          detach(a_mixin13);
        if (detaching)
          detach(t24);
        if (detaching)
          detach(a_entity11);
        if (detaching)
          detach(t25);
        if (detaching)
          detach(a_mixin14);
        if (detaching)
          detach(t26);
        if (detaching)
          detach(a_entity12);
        if (detaching)
          detach(t27);
        if (detaching)
          detach(a_mixin15);
        if (detaching)
          detach(t28);
        if (detaching)
          detach(a_entity13);
      }
    };
  }
  var vary = "property: scale; range: 1.5 1.25 1.5 3 2 3";
  var trunkVary = "property:scale; range: 2 1 2 5 2 5";
  function instance5($$self, $$props, $$invalidate) {
    let { groundSize = 100 } = $$props;
    const scatter = [-groundSize / 2, 0, -groundSize / 2, groundSize / 2, 0, groundSize / 2].join(" ");
    const boxBlocker = {
      "ammo-body": "type: static; mass: 0;",
      "ammo-shape": "type: box; fit: manual; halfExtents: 1 2.5 1; offset: 0 2.5 0"
    };
    const smolBoxBlocker = {
      "ammo-body": "type: static; mass: 0;",
      "ammo-shape": "type: box; fit: manual; halfExtents: 0.5 0.5 0.5; offset: 0 0 0"
    };
    $$self.$$set = ($$props2) => {
      if ("groundSize" in $$props2)
        $$invalidate(0, groundSize = $$props2.groundSize);
    };
    return [groundSize, scatter, boxBlocker, smolBoxBlocker];
  }
  var Forest = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance5, create_fragment6, safe_not_equal, { groundSize: 0 });
    }
  };
  var forest_default = Forest;

  // src/ui/live.svelte
  function create_fragment7(ctx) {
    let div;
    let div_class_value;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        attr(div, "class", div_class_value = "action " + (ctx[0] ? "live" : "") + " " + (ctx[1] ? "mobile" : "") + " svelte-67wfs3");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        if (!mounted) {
          dispose = listen(div, "click", ctx[2]);
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 3 && div_class_value !== (div_class_value = "action " + (ctx2[0] ? "live" : "") + " " + (ctx2[1] ? "mobile" : "") + " svelte-67wfs3")) {
          attr(div, "class", div_class_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div);
        mounted = false;
        dispose();
      }
    };
  }
  function instance6($$self, $$props, $$invalidate) {
    let $open_live;
    let $ismobile;
    component_subscribe($$self, open_live, ($$value) => $$invalidate(0, $open_live = $$value));
    component_subscribe($$self, ismobile, ($$value) => $$invalidate(1, $ismobile = $$value));
    const click_handler = () => {
      open_live.set(!open_live.$);
    };
    return [$open_live, $ismobile, click_handler];
  }
  var Live = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance6, create_fragment7, safe_not_equal, {});
    }
  };
  var live_default = Live;

  // src/node/debug.svelte
  var Debug = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, null, safe_not_equal, {});
    }
  };
  var debug_default = Debug;

  // src/component/grid.ts
  AFRAME.registerComponent("grid", {
    schema: {
      width: { type: "number", default: 1 },
      length: { type: "number", default: 1 },
      spacing: { type: "number", default: 1 },
      fill: { type: "bool", default: false }
    },
    init() {
      const d = this.el.object3D.parent.userData;
      if (this.data.fill) {
        const i = (d.ringDex === void 0 ? d.ringDex = 0 : d.ringDex++) % (this.data.width * this.data.length);
        this.el.object3D.position.set(i % this.data.width - this.data.width / 2, 0, Math.floor(i / this.data.width) - this.data.length / 2).multiplyScalar(this.data.spacing);
      } else {
        const i = (d.ringDex === void 0 ? d.ringDex = 0 : d.ringDex++) % (this.data.width * 2 + this.data.length * 2);
        this.el.object3D.position.set(i % (this.data.width * 2) - this.data.width, 0, Math.floor(i / (this.data.width * 2)) - this.data.length).multiplyScalar(this.data.spacing);
      }
    }
  });

  // src/node/house.svelte
  function create_fragment8(ctx) {
    let a_mixin0;
    let t0;
    let a_mixin1;
    let t1;
    let a_entity0;
    let a_entity0_location_value;
    let t2;
    let a_entity1;
    let t3;
    let a_entity2;
    let t4;
    let a_entity3;
    let t5;
    let a_entity4;
    let t6;
    let a_entity5;
    let t7;
    let a_entity6;
    let t8;
    let a_entity7;
    let t9;
    let a_entity8;
    let t10;
    let a_entity9;
    let t11;
    let a_entity10;
    let t12;
    let a_entity11;
    let t13;
    let a_entity12;
    let t14;
    let a_entity13;
    let t15;
    let a_entity14;
    let t16;
    let a_entity15;
    let mounted;
    let dispose;
    return {
      c() {
        a_mixin0 = element("a-mixin");
        t0 = space();
        a_mixin1 = element("a-mixin");
        t1 = space();
        a_entity0 = element("a-entity");
        t2 = space();
        a_entity1 = element("a-entity");
        t3 = space();
        a_entity2 = element("a-entity");
        t4 = space();
        a_entity3 = element("a-entity");
        t5 = space();
        a_entity4 = element("a-entity");
        t6 = space();
        a_entity5 = element("a-entity");
        t7 = space();
        a_entity6 = element("a-entity");
        t8 = space();
        a_entity7 = element("a-entity");
        t9 = space();
        a_entity8 = element("a-entity");
        t10 = space();
        a_entity9 = element("a-entity");
        t11 = space();
        a_entity10 = element("a-entity");
        t12 = space();
        a_entity11 = element("a-entity");
        t13 = space();
        a_entity12 = element("a-entity");
        t14 = space();
        a_entity13 = element("a-entity");
        t15 = space();
        a_entity14 = element("a-entity");
        t16 = space();
        a_entity15 = element("a-entity");
        set_custom_element_data(a_mixin0, "id", "wall");
        set_custom_element_data(a_mixin0, "ammo-body", "type: static; mass: 0; ");
        set_custom_element_data(a_mixin0, "ammo-shape", "type: box; fit: manual; half-extents: 5 4 1; offset: 0 0.5 0.5;");
        set_custom_element_data(a_mixin0, "geometry", "");
        set_custom_element_data(a_mixin0, "scale", "10 4 10");
        set_custom_element_data(a_mixin0, "shadow", "receive: false");
        set_custom_element_data(a_mixin1, "id", "fence");
        set_custom_element_data(a_mixin1, "scale", "15 2 1");
        set_custom_element_data(a_mixin1, "shadow", "");
        set_custom_element_data(a_mixin1, "ammo-body", "type: static; mass: 0; ");
        set_custom_element_data(a_mixin1, "ammo-shape", "type: box; fit: manual; half-extents: 7 0.5 0.5; offset: 0 0.5 0.5;");
        set_custom_element_data(a_entity0, "id", "ground");
        set_custom_element_data(a_entity0, "geometry", "");
        set_custom_element_data(a_entity0, "material", "color: #281b0d;");
        set_custom_element_data(a_entity0, "ammo-body", "type: static; mass: 0; ");
        set_custom_element_data(a_entity0, "ammo-shape", "type: box; fit: manual; half-extents: 20 0.1 20; ");
        set_custom_element_data(a_entity0, "shadow", "");
        set_custom_element_data(a_entity0, "scale", "20 0.1 20");
        set_custom_element_data(a_entity0, "position", "0 0 0");
        set_custom_element_data(a_entity0, "location", a_entity0_location_value = "name: \u{1F6D6}; box:" + -20 + " 0 " + -20 + " " + 20 + " 30 " + 20);
        set_custom_element_data(a_entity1, "mixin", "wall");
        set_custom_element_data(a_entity1, "gltf-model", "./glb/cabinWindow.glb");
        set_custom_element_data(a_entity1, "position", "0 0 -5");
        set_custom_element_data(a_entity2, "mixin", "wall");
        set_custom_element_data(a_entity2, "gltf-model", "./glb/cabinWindow.glb");
        set_custom_element_data(a_entity2, "position", "0 0 5");
        set_custom_element_data(a_entity3, "mixin", "wall");
        set_custom_element_data(a_entity3, "gltf-model", "./glb/cabinDoor.glb");
        set_custom_element_data(a_entity3, "rotation", "0 90 0");
        set_custom_element_data(a_entity3, "position", "-5 0 0");
        set_custom_element_data(a_entity3, "ammo-shape", "type: box; fit: manual; half-extents: 2 4 1; offset: -4 0.5 0.5;");
        set_custom_element_data(a_entity4, "mixin", "wall");
        set_custom_element_data(a_entity4, "rotation", "0 90 0");
        set_custom_element_data(a_entity4, "position", "-5 0 0");
        set_custom_element_data(a_entity4, "material", "visible: false;");
        set_custom_element_data(a_entity4, "ammo-shape", "type: box; fit: manual; half-extents: 2 4 1; offset: 4 0.5 0.5;");
        set_custom_element_data(a_entity5, "mixin", "wall");
        set_custom_element_data(a_entity5, "gltf-model", "./glb/cabinWindow.glb");
        set_custom_element_data(a_entity5, "rotation", "0 90 0");
        set_custom_element_data(a_entity5, "position", "5 0 0");
        set_custom_element_data(a_entity6, "gltf-model", "./glb/fence.glb");
        set_custom_element_data(a_entity6, "mixin", "fence");
        set_custom_element_data(a_entity6, "position", "0 0 9");
        set_custom_element_data(a_entity7, "gltf-model", "./glb/fence.glb");
        set_custom_element_data(a_entity7, "mixin", "fence");
        set_custom_element_data(a_entity7, "position", "0 0 -9");
        set_custom_element_data(a_entity8, "shadow", "");
        set_custom_element_data(a_entity8, "gltf-model", "./glb/cabinWindow.glb");
        set_custom_element_data(a_entity8, "scale", "10 2 10");
        set_custom_element_data(a_entity8, "rotation", "0 90 0");
        set_custom_element_data(a_entity8, "position", "-5 4 0");
        set_custom_element_data(a_entity9, "mixin", "fence");
        set_custom_element_data(a_entity9, "gltf-model", "./glb/fence.glb");
        set_custom_element_data(a_entity9, "scale", "4 2 4");
        set_custom_element_data(a_entity9, "rotation", "0 90 0");
        set_custom_element_data(a_entity9, "position", "-12 0 -4");
        set_custom_element_data(a_entity9, "ammo-shape", "type: box; fit: manual; half-extents: 2 0.5 0.5; offset: 0 0.5 1.5;");
        set_custom_element_data(a_entity10, "mixin", "fence");
        set_custom_element_data(a_entity10, "gltf-model", "./glb/fence.glb");
        set_custom_element_data(a_entity10, "scale", "4 2 4");
        set_custom_element_data(a_entity10, "rotation", "0 90 0");
        set_custom_element_data(a_entity10, "position", "-12 0 4");
        set_custom_element_data(a_entity10, "ammo-shape", "type: box; fit: manual; half-extents: 2 0.5 0.5; offset: 0 0.5 1.5;");
        set_custom_element_data(a_entity11, "shadow", "");
        set_custom_element_data(a_entity11, "gltf-model", "./glb/cabinWindow.glb");
        set_custom_element_data(a_entity11, "scale", "10 2 10");
        set_custom_element_data(a_entity11, "rotation", "0 90 0");
        set_custom_element_data(a_entity11, "position", "5 4 0");
        set_custom_element_data(a_entity12, "mixin", "fence");
        set_custom_element_data(a_entity12, "gltf-model", "./glb/fence.glb");
        set_custom_element_data(a_entity12, "rotation", "0 90 0");
        set_custom_element_data(a_entity12, "position", "9 0 0");
        set_custom_element_data(a_entity13, "shadow", "receive: false");
        set_custom_element_data(a_entity13, "gltf-model", "./glb/cabinRoofCenter.glb");
        set_custom_element_data(a_entity13, "scale", "10 4 10");
        set_custom_element_data(a_entity13, "rotation", "0 90 0");
        set_custom_element_data(a_entity13, "position", "0 3.5 0");
        set_custom_element_data(a_entity14, "shadow", "");
        set_custom_element_data(a_entity14, "gltf-model", "./glb/cabinFloor.glb");
        set_custom_element_data(a_entity14, "scale", "10 4 10");
        set_custom_element_data(a_entity14, "rotation", "0 0 0");
        set_custom_element_data(a_entity14, "position", "0 0.01 0");
        set_custom_element_data(a_entity15, "light", "type: point; distance: 12");
      },
      m(target, anchor) {
        insert(target, a_mixin0, anchor);
        insert(target, t0, anchor);
        insert(target, a_mixin1, anchor);
        insert(target, t1, anchor);
        insert(target, a_entity0, anchor);
        insert(target, t2, anchor);
        insert(target, a_entity1, anchor);
        insert(target, t3, anchor);
        insert(target, a_entity2, anchor);
        insert(target, t4, anchor);
        insert(target, a_entity3, anchor);
        insert(target, t5, anchor);
        insert(target, a_entity4, anchor);
        insert(target, t6, anchor);
        insert(target, a_entity5, anchor);
        insert(target, t7, anchor);
        insert(target, a_entity6, anchor);
        insert(target, t8, anchor);
        insert(target, a_entity7, anchor);
        insert(target, t9, anchor);
        insert(target, a_entity8, anchor);
        insert(target, t10, anchor);
        insert(target, a_entity9, anchor);
        insert(target, t11, anchor);
        insert(target, a_entity10, anchor);
        insert(target, t12, anchor);
        insert(target, a_entity11, anchor);
        insert(target, t13, anchor);
        insert(target, a_entity12, anchor);
        insert(target, t14, anchor);
        insert(target, a_entity13, anchor);
        insert(target, t15, anchor);
        insert(target, a_entity14, anchor);
        insert(target, t16, anchor);
        insert(target, a_entity15, anchor);
        if (!mounted) {
          dispose = listen(a_entity0, "collide", ctx[0]);
          mounted = true;
        }
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_mixin0);
        if (detaching)
          detach(t0);
        if (detaching)
          detach(a_mixin1);
        if (detaching)
          detach(t1);
        if (detaching)
          detach(a_entity0);
        if (detaching)
          detach(t2);
        if (detaching)
          detach(a_entity1);
        if (detaching)
          detach(t3);
        if (detaching)
          detach(a_entity2);
        if (detaching)
          detach(t4);
        if (detaching)
          detach(a_entity3);
        if (detaching)
          detach(t5);
        if (detaching)
          detach(a_entity4);
        if (detaching)
          detach(t6);
        if (detaching)
          detach(a_entity5);
        if (detaching)
          detach(t7);
        if (detaching)
          detach(a_entity6);
        if (detaching)
          detach(t8);
        if (detaching)
          detach(a_entity7);
        if (detaching)
          detach(t9);
        if (detaching)
          detach(a_entity8);
        if (detaching)
          detach(t10);
        if (detaching)
          detach(a_entity9);
        if (detaching)
          detach(t11);
        if (detaching)
          detach(a_entity10);
        if (detaching)
          detach(t12);
        if (detaching)
          detach(a_entity11);
        if (detaching)
          detach(t13);
        if (detaching)
          detach(a_entity12);
        if (detaching)
          detach(t14);
        if (detaching)
          detach(a_entity13);
        if (detaching)
          detach(t15);
        if (detaching)
          detach(a_entity14);
        if (detaching)
          detach(t16);
        if (detaching)
          detach(a_entity15);
        mounted = false;
        dispose();
      }
    };
  }
  function instance7($$self) {
    const collide_handler = (e) => {
      console.log(e);
    };
    return [collide_handler];
  }
  var House = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance7, create_fragment8, safe_not_equal, {});
    }
  };
  var house_default = House;

  // src/ui/netdata.svelte
  function create_if_block2(ctx) {
    let div;
    let t;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        t = text(ctx[1]);
        attr(div, "class", "netdata svelte-1beqevp");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t);
        if (!mounted) {
          dispose = listen(div, "click", ctx[2]);
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 2)
          set_data(t, ctx2[1]);
      },
      d(detaching) {
        if (detaching)
          detach(div);
        mounted = false;
        dispose();
      }
    };
  }
  function create_fragment9(ctx) {
    let if_block_anchor;
    let if_block = ctx[0] && ctx[1] && create_if_block2(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (ctx2[0] && ctx2[1]) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block2(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function instance8($$self, $$props, $$invalidate) {
    let $open_hostid;
    let $room;
    component_subscribe($$self, open_hostid, ($$value) => $$invalidate(0, $open_hostid = $$value));
    component_subscribe($$self, room, ($$value) => $$invalidate(1, $room = $$value));
    const click_handler = () => {
      const p2 = `${location.protocol}//${location.host}/?go&join=${$room}`;
      navigator.clipboard.writeText(p2);
    };
    return [$open_hostid, $room, click_handler];
  }
  var Netdata = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance8, create_fragment9, safe_not_equal, {});
    }
  };
  var netdata_default = Netdata;

  // src/shader/space.ts
  var spacefrag = `
varying vec2 vUv;
uniform vec3 color;
uniform float timeMsec; // A-Frame time in milliseconds.

#define iterations 17
#define formuparam 0.53

#define volsteps 20
#define stepsize 0.1

#define zoom   0.800
#define tile   0.850
#define speed  0.010 

#define brightness 0.0015
#define darkmatter 0.300
#define distfading 0.730
#define saturation 0.850

void main() {
  //get coords and direction

  vec3 dir=vec3(vUv*zoom,1.);
  float time=timeMsec*speed+.25;

  //volumetric rendering
  float s=0.1,fade=1.;
  vec3 v=vec3(0.);
  for (int r=0; r<volsteps; r++) {
      vec3 p=s*dir*.5;
      p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold
      float pa,a=pa=0.;
      for (int i=0; i<iterations; i++) { 
          p=abs(p)/dot(p,p)-formuparam; // the magic formula
          a+=abs(length(p)-pa); // absolute sum of average change
          pa=length(p);
      }
      float dm=max(0.,darkmatter-a*a*.001); //dark matter
      a*=a*a; // add contrast
      if (r>6) fade*=1.-dm; // dark matter, don't render near
      //v+=vec3(dm,dm*.5,0.);
      v+=fade;
      v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance
      fade*=distfading; // distance fading
      s+=stepsize;
  }
  v=mix(vec3(length(v)),v,saturation); //color adjust
  float r = v.r;
  v.r = v.b;
  v.b = r;

  gl_FragColor = vec4(v*.01,1.);	
}

`;
  var spaceVert = `
varying vec2 vUv;

void main() {
  vUv = uv;
  
  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
  AFRAME.registerShader("space", {
    schema: {},
    fragmentShader: spacefrag,
    vertexShader: spaceVert
  });

  // src/node/environmental.svelte
  function create_fragment10(ctx) {
    let a_plane;
    let a_plane_width_value;
    let a_plane_height_value;
    let a_plane_location_value;
    let t0;
    let a_entity0;
    let a_sphere;
    let a_entity0_position_value;
    let a_entity0_light_value;
    let t1;
    let a_entity1;
    let a_entity1_position_value;
    let a_entity1_light_value;
    let t2;
    let a_entity2;
    let t3;
    let a_mixin0;
    let t4;
    let a_entity3;
    let a_entity3_position_value;
    let a_entity3_animation_value;
    let a_entity3_animation__scale_value;
    let t5;
    let a_entity4;
    let t6;
    let a_mixin1;
    let a_mixin1_vary_value;
    let t7;
    let a_entity5;
    let t8;
    let a_mixin2;
    let a_mixin2_vary_value;
    let t9;
    let a_entity6;
    let t10;
    let a_sky;
    return {
      c() {
        a_plane = element("a-plane");
        t0 = space();
        a_entity0 = element("a-entity");
        a_sphere = element("a-sphere");
        t1 = space();
        a_entity1 = element("a-entity");
        t2 = space();
        a_entity2 = element("a-entity");
        t3 = space();
        a_mixin0 = element("a-mixin");
        t4 = space();
        a_entity3 = element("a-entity");
        t5 = space();
        a_entity4 = element("a-entity");
        t6 = space();
        a_mixin1 = element("a-mixin");
        t7 = space();
        a_entity5 = element("a-entity");
        t8 = space();
        a_mixin2 = element("a-mixin");
        t9 = space();
        a_entity6 = element("a-entity");
        t10 = space();
        a_sky = element("a-sky");
        set_custom_element_data(a_plane, "shadow", "");
        set_custom_element_data(a_plane, "id", "ground");
        set_custom_element_data(a_plane, "position", "0 0 0");
        set_custom_element_data(a_plane, "rotation", "-90 0 0");
        set_custom_element_data(a_plane, "width", a_plane_width_value = ctx[0] * 1.5);
        set_custom_element_data(a_plane, "height", a_plane_height_value = ctx[0] * 1.5);
        set_custom_element_data(a_plane, "ammo-body", "type: static; mass: 0;");
        set_custom_element_data(a_plane, "ammo-shape", "type:box");
        set_custom_element_data(a_plane, "color", "#334411");
        set_custom_element_data(a_plane, "location", a_plane_location_value = "name: \u{1F333};  box: " + -ctx[0] * 1.5 + " 0 " + -ctx[0] * 1.5 + " " + ctx[0] * 1.5 + " 100 " + ctx[0] * 1.5);
        set_custom_element_data(a_sphere, "position", "0 100 0");
        set_custom_element_data(a_sphere, "radius", "10");
        set_custom_element_data(a_sphere, "material", "color: yellow; shader: flat;");
        set_custom_element_data(a_entity0, "position", a_entity0_position_value = ctx[0] / 4 + " " + ctx[0] * 2 + " " + ctx[0] / 4);
        set_custom_element_data(a_entity0, "light", a_entity0_light_value = ctx[1]({
          type: "directional",
          color: light,
          castShadow: true,
          shadowCameraTop: ctx[0],
          shadowCameraLeft: -ctx[0],
          shadowCameraRight: ctx[0],
          shadowCameraBottom: -ctx[0],
          shadowMapHeight: 1024 * 4,
          shadowMapWidth: 1024 * 4,
          intensity: 0.5
        }));
        set_custom_element_data(a_entity1, "position", a_entity1_position_value = "-" + ctx[0] / 4 + " " + ctx[0] * 2 + " -" + ctx[0] / 4);
        set_custom_element_data(a_entity1, "light", a_entity1_light_value = ctx[1]({
          type: "directional",
          color: light,
          intensity: 0.5
        }));
        set_custom_element_data(a_entity2, "light", "type:ambient; color:white; intensity:1;");
        set_custom_element_data(a_mixin0, "id", "cloud");
        set_custom_element_data(a_mixin0, "scatter", ctx[2]);
        set_custom_element_data(a_mixin0, "material", "color: #ffffff; shader: flat; ");
        set_custom_element_data(a_mixin0, "geometry", "");
        set_custom_element_data(a_mixin0, "scale", "15 5 10");
        set_custom_element_data(a_mixin0, "vary", "property: scale; range: 1 1 1 1.5 1.5 1.5");
        set_custom_element_data(a_entity3, "pool__cloud", "mixin: shadow cloud; size: 50");
        set_custom_element_data(a_entity3, "activate__cloud", "");
        set_custom_element_data(a_entity3, "position", a_entity3_position_value = "0 35 " + ctx[0]);
        set_custom_element_data(a_entity3, "animation", a_entity3_animation_value = "property:object3D.position.z; to:-" + ctx[0] + "; dur: " + 400 * 300 * 2 + "; loop: true;");
        set_custom_element_data(a_entity3, "animation__scale", a_entity3_animation__scale_value = "property:object3D.scale; from: 0 0 0; to:1 1 1; dur: " + 400 * 300 / 2 + "; loop: true; dir: alternate");
        set_custom_element_data(a_entity4, "sound", "autoplay: true; loop: true; volume: 0.05; src:#sound-bg;positional:false");
        set_custom_element_data(a_mixin1, "id", "floof");
        set_custom_element_data(a_mixin1, "geometry", "");
        set_custom_element_data(a_mixin1, "scale", "0.05 0.05 0.05");
        set_custom_element_data(a_mixin1, "material", "color: white; shader: flat;");
        set_custom_element_data(a_mixin1, "vary", a_mixin1_vary_value = "property: position; range: -" + ctx[0] * 0.75 + " 0 -" + ctx[0] * 0.75 + " " + ctx[0] * 0.75 + " 4 " + ctx[0] * 0.75);
        set_custom_element_data(a_mixin1, "floaty", "");
        set_custom_element_data(a_entity5, "pool__floof", "mixin: floof; size: 100;");
        set_custom_element_data(a_entity5, "activate__floof", "");
        set_custom_element_data(a_mixin2, "id", "birds");
        set_custom_element_data(a_mixin2, "geometry", "");
        set_custom_element_data(a_mixin2, "scale", "0.25 0.15 0.15");
        set_custom_element_data(a_mixin2, "material", "color: yellow; shader: flat;");
        set_custom_element_data(a_mixin2, "vary", a_mixin2_vary_value = "property: position; range: -" + ctx[0] * 0.75 + " 10.5 -" + ctx[0] * 0.75 + " " + ctx[0] * 0.75 + " 40 " + ctx[0] * 0.75);
        set_custom_element_data(a_mixin2, "floaty", "");
        set_custom_element_data(a_entity6, "pool__birds", "mixin: birds; size: 50;");
        set_custom_element_data(a_entity6, "activate__birds", "");
        set_custom_element_data(a_sky, "shader", "space");
      },
      m(target, anchor) {
        insert(target, a_plane, anchor);
        insert(target, t0, anchor);
        insert(target, a_entity0, anchor);
        append(a_entity0, a_sphere);
        insert(target, t1, anchor);
        insert(target, a_entity1, anchor);
        insert(target, t2, anchor);
        insert(target, a_entity2, anchor);
        insert(target, t3, anchor);
        insert(target, a_mixin0, anchor);
        insert(target, t4, anchor);
        insert(target, a_entity3, anchor);
        insert(target, t5, anchor);
        insert(target, a_entity4, anchor);
        insert(target, t6, anchor);
        insert(target, a_mixin1, anchor);
        insert(target, t7, anchor);
        insert(target, a_entity5, anchor);
        insert(target, t8, anchor);
        insert(target, a_mixin2, anchor);
        insert(target, t9, anchor);
        insert(target, a_entity6, anchor);
        insert(target, t10, anchor);
        insert(target, a_sky, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & 1 && a_plane_width_value !== (a_plane_width_value = ctx2[0] * 1.5)) {
          set_custom_element_data(a_plane, "width", a_plane_width_value);
        }
        if (dirty & 1 && a_plane_height_value !== (a_plane_height_value = ctx2[0] * 1.5)) {
          set_custom_element_data(a_plane, "height", a_plane_height_value);
        }
        if (dirty & 1 && a_plane_location_value !== (a_plane_location_value = "name: \u{1F333};  box: " + -ctx2[0] * 1.5 + " 0 " + -ctx2[0] * 1.5 + " " + ctx2[0] * 1.5 + " 100 " + ctx2[0] * 1.5)) {
          set_custom_element_data(a_plane, "location", a_plane_location_value);
        }
        if (dirty & 1 && a_entity0_position_value !== (a_entity0_position_value = ctx2[0] / 4 + " " + ctx2[0] * 2 + " " + ctx2[0] / 4)) {
          set_custom_element_data(a_entity0, "position", a_entity0_position_value);
        }
        if (dirty & 1 && a_entity0_light_value !== (a_entity0_light_value = ctx2[1]({
          type: "directional",
          color: light,
          castShadow: true,
          shadowCameraTop: ctx2[0],
          shadowCameraLeft: -ctx2[0],
          shadowCameraRight: ctx2[0],
          shadowCameraBottom: -ctx2[0],
          shadowMapHeight: 1024 * 4,
          shadowMapWidth: 1024 * 4,
          intensity: 0.5
        }))) {
          set_custom_element_data(a_entity0, "light", a_entity0_light_value);
        }
        if (dirty & 1 && a_entity1_position_value !== (a_entity1_position_value = "-" + ctx2[0] / 4 + " " + ctx2[0] * 2 + " -" + ctx2[0] / 4)) {
          set_custom_element_data(a_entity1, "position", a_entity1_position_value);
        }
        if (dirty & 1 && a_entity3_position_value !== (a_entity3_position_value = "0 35 " + ctx2[0])) {
          set_custom_element_data(a_entity3, "position", a_entity3_position_value);
        }
        if (dirty & 1 && a_entity3_animation_value !== (a_entity3_animation_value = "property:object3D.position.z; to:-" + ctx2[0] + "; dur: " + 400 * 300 * 2 + "; loop: true;")) {
          set_custom_element_data(a_entity3, "animation", a_entity3_animation_value);
        }
        if (dirty & 1 && a_mixin1_vary_value !== (a_mixin1_vary_value = "property: position; range: -" + ctx2[0] * 0.75 + " 0 -" + ctx2[0] * 0.75 + " " + ctx2[0] * 0.75 + " 4 " + ctx2[0] * 0.75)) {
          set_custom_element_data(a_mixin1, "vary", a_mixin1_vary_value);
        }
        if (dirty & 1 && a_mixin2_vary_value !== (a_mixin2_vary_value = "property: position; range: -" + ctx2[0] * 0.75 + " 10.5 -" + ctx2[0] * 0.75 + " " + ctx2[0] * 0.75 + " 40 " + ctx2[0] * 0.75)) {
          set_custom_element_data(a_mixin2, "vary", a_mixin2_vary_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(a_plane);
        if (detaching)
          detach(t0);
        if (detaching)
          detach(a_entity0);
        if (detaching)
          detach(t1);
        if (detaching)
          detach(a_entity1);
        if (detaching)
          detach(t2);
        if (detaching)
          detach(a_entity2);
        if (detaching)
          detach(t3);
        if (detaching)
          detach(a_mixin0);
        if (detaching)
          detach(t4);
        if (detaching)
          detach(a_entity3);
        if (detaching)
          detach(t5);
        if (detaching)
          detach(a_entity4);
        if (detaching)
          detach(t6);
        if (detaching)
          detach(a_mixin1);
        if (detaching)
          detach(t7);
        if (detaching)
          detach(a_entity5);
        if (detaching)
          detach(t8);
        if (detaching)
          detach(a_mixin2);
        if (detaching)
          detach(t9);
        if (detaching)
          detach(a_entity6);
        if (detaching)
          detach(t10);
        if (detaching)
          detach(a_sky);
      }
    };
  }
  var light = "#FEE";
  function instance9($$self, $$props, $$invalidate) {
    const str = AFRAME.utils.styleParser.stringify.bind(AFRAME.utils.styleParser);
    let { groundSize = 100 } = $$props;
    const scatterBig = [-groundSize, 0, -groundSize, groundSize, 0, groundSize].join(" ");
    $$self.$$set = ($$props2) => {
      if ("groundSize" in $$props2)
        $$invalidate(0, groundSize = $$props2.groundSize);
    };
    return [groundSize, str, scatterBig];
  }
  var Environmental = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance9, create_fragment10, safe_not_equal, { groundSize: 0 });
    }
  };
  var environmental_default = Environmental;

  // src/component/location.ts
  var location2 = new Value([]);
  var locations = {};
  var wpos = new AFRAME.THREE.Vector3();
  AFRAME.registerSystem("loc", {
    init() {
      this.tick = AFRAME.utils.throttleTick(this.tick, 1e3, this);
    },
    tick() {
      camera.$.updateMatrixWorld();
      camera.$.getWorldPosition(wpos);
      for (let entry of Object.entries(locations)) {
        const [key, value] = entry;
        const n = value.data.name;
        const l = location2.$.indexOf(n);
        if (value.playerIsIn(wpos)) {
          if (l !== -1)
            continue;
          location2.$.push(n);
          location2.poke();
        } else if (l !== -1) {
          location2.$.splice(l, 1);
          location2.poke();
        }
      }
    }
  });
  var vec34 = new AFRAME.THREE.Vector3();
  AFRAME.registerComponent("location", {
    schema: {
      name: { type: "string" },
      box: { type: "string", default: "-1 -1 -1 1 1 1" }
    },
    init() {
      locations[this.data.name] = this;
      this.bb = new AFRAME.THREE.Box3();
      this.bb.setFromArray(this.data.box.split(" ").map(parseFloat));
    },
    playerIsIn(playerPos) {
      return this.bb.containsPoint(vec34.copy(playerPos).sub(this.el.object3D.position));
    },
    remove() {
      delete locations[this.data.name];
    }
  });

  // src/ui/onscreen-ui.svelte
  function get_each_context(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[17] = list[i];
    return child_ctx;
  }
  function get_each_context_1(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[20] = list[i];
    return child_ctx;
  }
  function create_each_block_1(ctx) {
    let div;
    let t0_value = (ctx[6][ctx[20]] || ctx[20]) + "";
    let t0;
    let t1;
    let div_class_value;
    let mounted;
    let dispose;
    function click_handler() {
      return ctx[12](ctx[20]);
    }
    return {
      c() {
        div = element("div");
        t0 = text(t0_value);
        t1 = space();
        attr(div, "class", div_class_value = "button bounce bound " + (ctx[4] === "" + ctx[20] ? "down" : "inactive") + " " + (ctx[5][ctx[20]] ? "active" : "") + " svelte-11pk8jo");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t0);
        append(div, t1);
        if (!mounted) {
          dispose = listen(div, "click", click_handler);
          mounted = true;
        }
      },
      p(new_ctx, dirty) {
        ctx = new_ctx;
        if (dirty & 64 && t0_value !== (t0_value = (ctx[6][ctx[20]] || ctx[20]) + ""))
          set_data(t0, t0_value);
        if (dirty & 48 && div_class_value !== (div_class_value = "button bounce bound " + (ctx[4] === "" + ctx[20] ? "down" : "inactive") + " " + (ctx[5][ctx[20]] ? "active" : "") + " svelte-11pk8jo")) {
          attr(div, "class", div_class_value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(div);
        mounted = false;
        dispose();
      }
    };
  }
  function create_each_block(ctx) {
    let div;
    let t_value = ctx[17] + "";
    let t;
    return {
      c() {
        div = element("div");
        t = text(t_value);
        attr(div, "class", "loc");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, t);
      },
      p(ctx2, dirty) {
        if (dirty & 128 && t_value !== (t_value = ctx2[17] + ""))
          set_data(t, t_value);
      },
      d(detaching) {
        if (detaching)
          detach(div);
      }
    };
  }
  function create_fragment11(ctx) {
    let div0;
    let div0_class_value;
    let t0;
    let div5;
    let div1;
    let t2;
    let div2;
    let t4;
    let div4;
    let div3;
    let div5_class_value;
    let t5;
    let div6;
    let mounted;
    let dispose;
    let each_value_1 = ctx[8];
    let each_blocks_1 = [];
    for (let i = 0; i < each_value_1.length; i += 1) {
      each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    }
    let each_value = ctx[7];
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    }
    return {
      c() {
        div0 = element("div");
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].c();
        }
        t0 = space();
        div5 = element("div");
        div1 = element("div");
        div1.textContent = "\u{1F4AC}";
        t2 = space();
        div2 = element("div");
        div2.textContent = "\u{1F998}";
        t4 = space();
        div4 = element("div");
        div3 = element("div");
        t5 = space();
        div6 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", div0_class_value = "bind-bar " + (ctx[3] ? "mobile" : "") + " svelte-11pk8jo");
        attr(div1, "class", "speak button bounce svelte-11pk8jo");
        attr(div2, "class", "jump button bounce svelte-11pk8jo");
        attr(div3, "class", "dot svelte-11pk8jo");
        set_style(div3, "margin-top", ctx[2] * 100 + "%");
        set_style(div3, "margin-left", ctx[1] * 100 + "%");
        attr(div4, "class", "move button bounce svelte-11pk8jo");
        attr(div5, "class", div5_class_value = "motion " + (ctx[3] ? "mobile" : "") + " svelte-11pk8jo");
        attr(div6, "class", "location svelte-11pk8jo");
      },
      m(target, anchor) {
        insert(target, div0, anchor);
        for (let i = 0; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].m(div0, null);
        }
        insert(target, t0, anchor);
        insert(target, div5, anchor);
        append(div5, div1);
        append(div5, t2);
        append(div5, div2);
        append(div5, t4);
        append(div5, div4);
        append(div4, div3);
        ctx[15](div4);
        insert(target, t5, anchor);
        insert(target, div6, anchor);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div6, null);
        }
        if (!mounted) {
          dispose = [
            listen(div1, "click", ctx[13]),
            listen(div2, "click", ctx[14]),
            listen(div4, "touchmove", ctx[9]),
            listen(div4, "touchend", ctx[10]),
            listen(div4, "mousemove", ctx[9]),
            listen(div4, "mousedown", ctx[11]),
            listen(div4, "touchstart", ctx[11]),
            listen(div4, "mouseleave", ctx[10]),
            listen(div4, "mouseup", ctx[10])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 368) {
          each_value_1 = ctx2[8];
          let i;
          for (i = 0; i < each_value_1.length; i += 1) {
            const child_ctx = get_each_context_1(ctx2, each_value_1, i);
            if (each_blocks_1[i]) {
              each_blocks_1[i].p(child_ctx, dirty);
            } else {
              each_blocks_1[i] = create_each_block_1(child_ctx);
              each_blocks_1[i].c();
              each_blocks_1[i].m(div0, null);
            }
          }
          for (; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d(1);
          }
          each_blocks_1.length = each_value_1.length;
        }
        if (dirty & 8 && div0_class_value !== (div0_class_value = "bind-bar " + (ctx2[3] ? "mobile" : "") + " svelte-11pk8jo")) {
          attr(div0, "class", div0_class_value);
        }
        if (dirty & 4) {
          set_style(div3, "margin-top", ctx2[2] * 100 + "%");
        }
        if (dirty & 2) {
          set_style(div3, "margin-left", ctx2[1] * 100 + "%");
        }
        if (dirty & 8 && div5_class_value !== (div5_class_value = "motion " + (ctx2[3] ? "mobile" : "") + " svelte-11pk8jo")) {
          attr(div5, "class", div5_class_value);
        }
        if (dirty & 128) {
          each_value = ctx2[7];
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
            } else {
              each_blocks[i] = create_each_block(child_ctx);
              each_blocks[i].c();
              each_blocks[i].m(div6, null);
            }
          }
          for (; i < each_blocks.length; i += 1) {
            each_blocks[i].d(1);
          }
          each_blocks.length = each_value.length;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div0);
        destroy_each(each_blocks_1, detaching);
        if (detaching)
          detach(t0);
        if (detaching)
          detach(div5);
        ctx[15](null);
        if (detaching)
          detach(t5);
        if (detaching)
          detach(div6);
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance10($$self, $$props, $$invalidate) {
    let $ismobile;
    let $key_down;
    let $binds;
    let $binds_icon;
    let $location;
    component_subscribe($$self, ismobile, ($$value) => $$invalidate(3, $ismobile = $$value));
    component_subscribe($$self, key_down, ($$value) => $$invalidate(4, $key_down = $$value));
    component_subscribe($$self, binds, ($$value) => $$invalidate(5, $binds = $$value));
    component_subscribe($$self, binds_icon, ($$value) => $$invalidate(6, $binds_icon = $$value));
    component_subscribe($$self, location2, ($$value) => $$invalidate(7, $location = $$value));
    let bound = [1, 2, 3, 4, 5];
    let holder;
    let x = 0.5;
    let y = 0.5;
    let interacting = false;
    function update3(e) {
      if (e.touches) {
        e.x = e.touches[0].clientX;
        e.y = e.touches[0].clientY;
      }
      e.preventDefault();
      e.stopPropagation();
      const { x: bx, y: by, width: width2, height: height2 } = holder.getBoundingClientRect();
      let target_x = 0;
      let target_y = 0;
      target_y = e.y - by;
      target_x = e.x - bx;
      const ye = target_y / height2;
      const xd = target_x / width2;
      $$invalidate(1, x = Math.min(Math.max(0, xd), 1));
      $$invalidate(2, y = Math.min(Math.max(0, ye), 1));
      if (!interacting)
        return;
      if (x > 0.6) {
        key_down.set("e");
      } else {
        key_up.set("e");
      }
      if (x < 0.4) {
        key_down.set("q");
      } else {
        key_up.set("q");
      }
      if (y > 0.6) {
        key_down.set("s");
      } else {
        key_up.set("s");
      }
      if (y < 0.4) {
        key_down.set("w");
      } else {
        key_up.set("w");
      }
      if (y < 0.2 || y > 0.8) {
        key_down.set("shift");
      } else {
        key_up.set("shift");
      }
    }
    function stop_interact(e) {
      e.preventDefault();
      e.stopPropagation();
      interacting = false;
      key_up.set("w");
      key_up.set("s");
      key_up.set("q");
      key_up.set("e");
      key_up.set("shift");
    }
    function interact(e) {
      e.preventDefault();
      e.stopPropagation();
      interacting = true;
    }
    const click_handler = (b) => {
      key_down.set("" + b);
      key_up.set("" + b);
    };
    const click_handler_1 = () => {
      open_text.set("");
      requestAnimationFrame(() => {
        document.getElementById("text").focus();
      });
    };
    const click_handler_2 = () => {
      key_down.set(" ");
      setTimeout(() => {
        key_up.set(" ");
      }, 300);
    };
    function div4_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        holder = $$value;
        $$invalidate(0, holder);
      });
    }
    return [
      holder,
      x,
      y,
      $ismobile,
      $key_down,
      $binds,
      $binds_icon,
      $location,
      bound,
      update3,
      stop_interact,
      interact,
      click_handler,
      click_handler_1,
      click_handler_2,
      div4_binding
    ];
  }
  var Onscreen_ui = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance10, create_fragment11, safe_not_equal, {});
    }
  };
  var onscreen_ui_default = Onscreen_ui;

  // src/game.svelte
  function create_if_block3(ctx) {
    let live;
    let t0;
    let heard;
    let t1;
    let onscreenui;
    let current;
    live = new live_default({});
    heard = new heard_default({});
    onscreenui = new onscreen_ui_default({});
    return {
      c() {
        create_component(live.$$.fragment);
        t0 = space();
        create_component(heard.$$.fragment);
        t1 = space();
        create_component(onscreenui.$$.fragment);
      },
      m(target, anchor) {
        mount_component(live, target, anchor);
        insert(target, t0, anchor);
        mount_component(heard, target, anchor);
        insert(target, t1, anchor);
        mount_component(onscreenui, target, anchor);
        current = true;
      },
      i(local) {
        if (current)
          return;
        transition_in(live.$$.fragment, local);
        transition_in(heard.$$.fragment, local);
        transition_in(onscreenui.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(live.$$.fragment, local);
        transition_out(heard.$$.fragment, local);
        transition_out(onscreenui.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(live, detaching);
        if (detaching)
          detach(t0);
        destroy_component(heard, detaching);
        if (detaching)
          detach(t1);
        destroy_component(onscreenui, detaching);
      }
    };
  }
  function create_fragment12(ctx) {
    let webcam;
    let t0;
    let netdata;
    let t1;
    let t2;
    let a_scene;
    let a_assets;
    let a_sphere;
    let t3;
    let audio;
    let audio_src_value;
    let t4;
    let a_mixin;
    let t5;
    let charactersmixins;
    let t6;
    let camera2;
    let t7;
    let characters;
    let t8;
    let forest;
    let t9;
    let house;
    let t10;
    let debug_1;
    let t11;
    let environmental;
    let a_scene_physics_value;
    let current;
    webcam = new webcam_default({});
    netdata = new netdata_default({});
    let if_block = ctx[0] && create_if_block3(ctx);
    charactersmixins = new characters_assets_default({});
    camera2 = new camera_default({});
    characters = new characters_default({});
    forest = new forest_default({ props: { groundSize: 200 } });
    house = new house_default({});
    debug_1 = new debug_default({});
    environmental = new environmental_default({ props: { groundSize: 200 } });
    return {
      c() {
        create_component(webcam.$$.fragment);
        t0 = space();
        create_component(netdata.$$.fragment);
        t1 = space();
        if (if_block)
          if_block.c();
        t2 = space();
        a_scene = element("a-scene");
        a_assets = element("a-assets");
        a_sphere = element("a-sphere");
        t3 = space();
        audio = element("audio");
        t4 = space();
        a_mixin = element("a-mixin");
        t5 = space();
        create_component(charactersmixins.$$.fragment);
        t6 = space();
        create_component(camera2.$$.fragment);
        t7 = space();
        create_component(characters.$$.fragment);
        t8 = space();
        create_component(forest.$$.fragment);
        t9 = space();
        create_component(house.$$.fragment);
        t10 = space();
        create_component(debug_1.$$.fragment);
        t11 = space();
        create_component(environmental.$$.fragment);
        set_custom_element_data(a_sphere, "color", "blue");
        set_custom_element_data(a_sphere, "radius", "5");
        attr(audio, "id", "sound-bg");
        if (!src_url_equal(audio.src, audio_src_value = "./sound/bg-ocean.mp3"))
          attr(audio, "src", audio_src_value);
        set_custom_element_data(a_mixin, "id", "shadow");
        set_custom_element_data(a_mixin, "shadow", "cast: true");
        set_custom_element_data(a_scene, "keyboard-shortcuts", "enterVR: false");
        set_custom_element_data(a_scene, "stats", ctx[1]);
        set_custom_element_data(a_scene, "renderer", " alpha: false; colorManagement: true;");
        set_custom_element_data(a_scene, "shadow", "type:basic;");
        set_custom_element_data(a_scene, "physics", a_scene_physics_value = "driver: ammo; debug: " + ctx[2] + ";");
        set_custom_element_data(a_scene, "uniforms", "");
        set_custom_element_data(a_scene, "net", "");
      },
      m(target, anchor) {
        mount_component(webcam, target, anchor);
        insert(target, t0, anchor);
        mount_component(netdata, target, anchor);
        insert(target, t1, anchor);
        if (if_block)
          if_block.m(target, anchor);
        insert(target, t2, anchor);
        insert(target, a_scene, anchor);
        append(a_scene, a_assets);
        append(a_assets, a_sphere);
        append(a_assets, t3);
        append(a_assets, audio);
        append(a_assets, t4);
        append(a_assets, a_mixin);
        append(a_assets, t5);
        mount_component(charactersmixins, a_assets, null);
        append(a_scene, t6);
        mount_component(camera2, a_scene, null);
        append(a_scene, t7);
        mount_component(characters, a_scene, null);
        append(a_scene, t8);
        mount_component(forest, a_scene, null);
        append(a_scene, t9);
        mount_component(house, a_scene, null);
        append(a_scene, t10);
        mount_component(debug_1, a_scene, null);
        append(a_scene, t11);
        mount_component(environmental, a_scene, null);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (ctx2[0]) {
          if (if_block) {
            if (dirty & 1) {
              transition_in(if_block, 1);
            }
          } else {
            if_block = create_if_block3(ctx2);
            if_block.c();
            transition_in(if_block, 1);
            if_block.m(t2.parentNode, t2);
          }
        } else if (if_block) {
          group_outros();
          transition_out(if_block, 1, 1, () => {
            if_block = null;
          });
          check_outros();
        }
        if (!current || dirty & 2) {
          set_custom_element_data(a_scene, "stats", ctx2[1]);
        }
        if (!current || dirty & 4 && a_scene_physics_value !== (a_scene_physics_value = "driver: ammo; debug: " + ctx2[2] + ";")) {
          set_custom_element_data(a_scene, "physics", a_scene_physics_value);
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(webcam.$$.fragment, local);
        transition_in(netdata.$$.fragment, local);
        transition_in(if_block);
        transition_in(charactersmixins.$$.fragment, local);
        transition_in(camera2.$$.fragment, local);
        transition_in(characters.$$.fragment, local);
        transition_in(forest.$$.fragment, local);
        transition_in(house.$$.fragment, local);
        transition_in(debug_1.$$.fragment, local);
        transition_in(environmental.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(webcam.$$.fragment, local);
        transition_out(netdata.$$.fragment, local);
        transition_out(if_block);
        transition_out(charactersmixins.$$.fragment, local);
        transition_out(camera2.$$.fragment, local);
        transition_out(characters.$$.fragment, local);
        transition_out(forest.$$.fragment, local);
        transition_out(house.$$.fragment, local);
        transition_out(debug_1.$$.fragment, local);
        transition_out(environmental.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(webcam, detaching);
        if (detaching)
          detach(t0);
        destroy_component(netdata, detaching);
        if (detaching)
          detach(t1);
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(t2);
        if (detaching)
          detach(a_scene);
        destroy_component(charactersmixins);
        destroy_component(camera2);
        destroy_component(characters);
        destroy_component(forest);
        destroy_component(house);
        destroy_component(debug_1);
        destroy_component(environmental);
      }
    };
  }
  function instance11($$self, $$props, $$invalidate) {
    let $open_ui;
    let $open_stats;
    let $open_debug;
    component_subscribe($$self, open_ui, ($$value) => $$invalidate(0, $open_ui = $$value));
    component_subscribe($$self, open_stats, ($$value) => $$invalidate(1, $open_stats = $$value));
    component_subscribe($$self, open_debug, ($$value) => $$invalidate(2, $open_debug = $$value));
    return [$open_ui, $open_stats, $open_debug];
  }
  var Game = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance11, create_fragment12, safe_not_equal, {});
    }
  };
  var game_default = Game;

  // src/ui/title.svelte
  function create_fragment13(ctx) {
    let div3;
    let t8;
    let div7;
    return {
      c() {
        div3 = element("div");
        div3.innerHTML = `<div class="favicon svelte-1u5pxqu"></div> 
	<div class="full svelte-1u5pxqu"><div class="title svelte-1u5pxqu"><offset class="svelte-1u5pxqu"><b class="svelte-1u5pxqu">a</b>  <br/></offset> 
			<b class="svelte-1u5pxqu">G</b>oblin
			<offset class="svelte-1u5pxqu"><b class="svelte-1u5pxqu">L</b>ife</offset></div></div>`;
        t8 = space();
        div7 = element("div");
        div7.innerHTML = `<div class="button kofi svelte-1u5pxqu"><a href="https://ko-fi.com/Z8Z1C37O3" target="_blank" class="svelte-1u5pxqu">\u{1FA99}</a></div> 
	<div style="width: 40vh;"></div> 
	<div class="button discord svelte-1u5pxqu"><a href="https://twitter.com/agoblinlife" target="_blank" class="svelte-1u5pxqu">\u{1F426}</a></div>`;
        attr(div3, "class", "intro svelte-1u5pxqu");
        attr(div7, "class", "ads svelte-1u5pxqu");
      },
      m(target, anchor) {
        insert(target, div3, anchor);
        insert(target, t8, anchor);
        insert(target, div7, anchor);
      },
      p: noop,
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div3);
        if (detaching)
          detach(t8);
        if (detaching)
          detach(div7);
      }
    };
  }
  var Title = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, null, create_fragment13, safe_not_equal, {});
    }
  };
  var title_default = Title;

  // src/ui/video.svelte
  function create_fragment14(ctx) {
    let iframe;
    let iframe_width_value;
    let iframe_src_value;
    return {
      c() {
        iframe = element("iframe");
        attr(iframe, "width", iframe_width_value = 1 / ctx[1].length * 100 + "%");
        attr(iframe, "height", "100%");
        if (!src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/" + ctx[0]))
          attr(iframe, "src", iframe_src_value);
        attr(iframe, "title", "YouTube video player");
        attr(iframe, "frameborder", "0");
        attr(iframe, "allow", "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture");
        iframe.allowFullscreen = true;
      },
      m(target, anchor) {
        insert(target, iframe, anchor);
      },
      p(ctx2, [dirty]) {
        if (dirty & 2 && iframe_width_value !== (iframe_width_value = 1 / ctx2[1].length * 100 + "%")) {
          attr(iframe, "width", iframe_width_value);
        }
        if (dirty & 1 && !src_url_equal(iframe.src, iframe_src_value = "https://www.youtube.com/embed/" + ctx2[0])) {
          attr(iframe, "src", iframe_src_value);
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(iframe);
      }
    };
  }
  function instance12($$self, $$props, $$invalidate) {
    let $videos;
    component_subscribe($$self, videos, ($$value) => $$invalidate(1, $videos = $$value));
    let { src = "MePBW53Rtpw" } = $$props;
    $$self.$$set = ($$props2) => {
      if ("src" in $$props2)
        $$invalidate(0, src = $$props2.src);
    };
    return [src, $videos];
  }
  var Video = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance12, create_fragment14, safe_not_equal, { src: 0 });
    }
  };
  var video_default = Video;

  // src/ui/home.svelte
  function get_each_context2(ctx, list, i) {
    const child_ctx = ctx.slice();
    child_ctx[3] = list[i];
    return child_ctx;
  }
  function create_each_block2(ctx) {
    let video2;
    let current;
    video2 = new video_default({ props: { src: ctx[3] } });
    return {
      c() {
        create_component(video2.$$.fragment);
      },
      m(target, anchor) {
        mount_component(video2, target, anchor);
        current = true;
      },
      p(ctx2, dirty) {
        const video_changes = {};
        if (dirty & 2)
          video_changes.src = ctx2[3];
        video2.$set(video_changes);
      },
      i(local) {
        if (current)
          return;
        transition_in(video2.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(video2.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(video2, detaching);
      }
    };
  }
  function create_fragment15(ctx) {
    let div10;
    let div0;
    let t0;
    let title;
    let t1;
    let div8;
    let div3;
    let div1;
    let t2;
    let textarea;
    let t3;
    let div2;
    let t4;
    let div7;
    let div4;
    let t5;
    let div5;
    let t7;
    let div6;
    let t8;
    let div9;
    let current;
    let mounted;
    let dispose;
    title = new title_default({});
    let each_value = ctx[1];
    let each_blocks = [];
    for (let i = 0; i < each_value.length; i += 1) {
      each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
    }
    const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
      each_blocks[i] = null;
    });
    return {
      c() {
        div10 = element("div");
        div0 = element("div");
        t0 = space();
        create_component(title.$$.fragment);
        t1 = space();
        div8 = element("div");
        div3 = element("div");
        div1 = element("div");
        t2 = space();
        textarea = element("textarea");
        t3 = space();
        div2 = element("div");
        t4 = space();
        div7 = element("div");
        div4 = element("div");
        t5 = space();
        div5 = element("div");
        div5.textContent = "\u{1F4DF}";
        t7 = space();
        div6 = element("div");
        t8 = space();
        div9 = element("div");
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].c();
        }
        attr(div0, "class", "sprites sprite svelte-wh29xi");
        attr(div1, "class", "flex svelte-wh29xi");
        attr(textarea, "type", "text");
        attr(textarea, "class", "text button svelte-wh29xi");
        attr(textarea, "maxlength", "200");
        textarea.value = ctx[0];
        textarea.readOnly = true;
        attr(div2, "class", "flex svelte-wh29xi");
        attr(div3, "class", "span2 full svelte-wh29xi");
        attr(div4, "class", "flex svelte-wh29xi");
        attr(div5, "type", "button");
        attr(div5, "class", "button icon svelte-wh29xi");
        attr(div5, "value", "GO");
        attr(div6, "class", "flex svelte-wh29xi");
        attr(div7, "class", "span2 full svelte-wh29xi");
        attr(div8, "class", "vbox svelte-wh29xi");
        attr(div9, "class", "flex span2 case svelte-wh29xi");
        attr(div10, "class", "menu svelte-wh29xi");
      },
      m(target, anchor) {
        insert(target, div10, anchor);
        append(div10, div0);
        append(div10, t0);
        mount_component(title, div10, null);
        append(div10, t1);
        append(div10, div8);
        append(div8, div3);
        append(div3, div1);
        append(div3, t2);
        append(div3, textarea);
        append(div3, t3);
        append(div3, div2);
        append(div8, t4);
        append(div8, div7);
        append(div7, div4);
        append(div7, t5);
        append(div7, div5);
        append(div7, t7);
        append(div7, div6);
        append(div10, t8);
        append(div10, div9);
        for (let i = 0; i < each_blocks.length; i += 1) {
          each_blocks[i].m(div9, null);
        }
        current = true;
        if (!mounted) {
          dispose = [
            listen(textarea, "copy", copy_handler),
            listen(textarea, "paste", paste_handler),
            listen(textarea, "keydown", keydown_handler),
            listen(div5, "click", ctx[2])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & 1) {
          textarea.value = ctx2[0];
        }
        if (dirty & 2) {
          each_value = ctx2[1];
          let i;
          for (i = 0; i < each_value.length; i += 1) {
            const child_ctx = get_each_context2(ctx2, each_value, i);
            if (each_blocks[i]) {
              each_blocks[i].p(child_ctx, dirty);
              transition_in(each_blocks[i], 1);
            } else {
              each_blocks[i] = create_each_block2(child_ctx);
              each_blocks[i].c();
              transition_in(each_blocks[i], 1);
              each_blocks[i].m(div9, null);
            }
          }
          group_outros();
          for (i = each_value.length; i < each_blocks.length; i += 1) {
            out(i);
          }
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(title.$$.fragment, local);
        for (let i = 0; i < each_value.length; i += 1) {
          transition_in(each_blocks[i]);
        }
        current = true;
      },
      o(local) {
        transition_out(title.$$.fragment, local);
        each_blocks = each_blocks.filter(Boolean);
        for (let i = 0; i < each_blocks.length; i += 1) {
          transition_out(each_blocks[i]);
        }
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div10);
        destroy_component(title);
        destroy_each(each_blocks, detaching);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  var copy_handler = (e) => {
    e.preventDefault();
  };
  var paste_handler = (e) => {
    e.preventDefault();
  };
  var keydown_handler = (e) => {
  };
  function instance13($$self, $$props, $$invalidate) {
    let $motd;
    let $videos;
    component_subscribe($$self, motd, ($$value) => $$invalidate(0, $motd = $$value));
    component_subscribe($$self, videos, ($$value) => $$invalidate(1, $videos = $$value));
    if (args.$.has("go")) {
      open_game.set(true);
      open_home.set(false);
    }
    const click_handler = () => {
      open_home.set(false);
      open_game.set(true);
    };
    return [$motd, $videos, click_handler];
  }
  var Home = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance13, create_fragment15, safe_not_equal, {});
    }
  };
  var home_default = Home;

  // src/ui/text.svelte
  function create_if_block4(ctx) {
    let div;
    let input;
    let div_class_value;
    let mounted;
    let dispose;
    return {
      c() {
        div = element("div");
        input = element("input");
        attr(input, "id", "text");
        attr(input, "type", "text");
        attr(input, "class", "entry svelte-ul99pz");
        input.autofocus = true;
        attr(div, "class", div_class_value = "lofi " + (ctx[2] ? "mobile" : "") + " svelte-ul99pz");
      },
      m(target, anchor) {
        insert(target, div, anchor);
        append(div, input);
        set_input_value(input, ctx[1]);
        ctx[6](input);
        input.focus();
        if (!mounted) {
          dispose = [
            listen(input, "input", ctx[5]),
            listen(input, "blur", ctx[4]),
            listen(input, "keydown", ctx[7])
          ];
          mounted = true;
        }
      },
      p(ctx2, dirty) {
        if (dirty & 2 && input.value !== ctx2[1]) {
          set_input_value(input, ctx2[1]);
        }
        if (dirty & 4 && div_class_value !== (div_class_value = "lofi " + (ctx2[2] ? "mobile" : "") + " svelte-ul99pz")) {
          attr(div, "class", div_class_value);
        }
      },
      d(detaching) {
        if (detaching)
          detach(div);
        ctx[6](null);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function create_fragment16(ctx) {
    let if_block_anchor;
    let if_block = ctx[1] !== void 0 && create_if_block4(ctx);
    return {
      c() {
        if (if_block)
          if_block.c();
        if_block_anchor = empty();
      },
      m(target, anchor) {
        if (if_block)
          if_block.m(target, anchor);
        insert(target, if_block_anchor, anchor);
      },
      p(ctx2, [dirty]) {
        if (ctx2[1] !== void 0) {
          if (if_block) {
            if_block.p(ctx2, dirty);
          } else {
            if_block = create_if_block4(ctx2);
            if_block.c();
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        } else if (if_block) {
          if_block.d(1);
          if_block = null;
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (if_block)
          if_block.d(detaching);
        if (detaching)
          detach(if_block_anchor);
      }
    };
  }
  function instance14($$self, $$props, $$invalidate) {
    let $open_text;
    let $ismobile;
    component_subscribe($$self, open_text, ($$value) => $$invalidate(1, $open_text = $$value));
    component_subscribe($$self, ismobile, ($$value) => $$invalidate(2, $ismobile = $$value));
    let ele;
    function send() {
      talk.set(open_text.$);
      open_text.set(void 0);
    }
    function escape2() {
      open_text.set(void 0);
    }
    key_down.on(() => {
      switch (key_down.$) {
        case "`":
          if (open_text.$ === void 0) {
            open_text.set("~ ");
            requestAnimationFrame(() => ele?.focus());
          }
          break;
        case "enter":
          if (open_text.$ === void 0) {
            open_text.set("");
            requestAnimationFrame(() => ele?.focus());
          }
      }
    });
    function input_input_handler() {
      $open_text = this.value;
      open_text.set($open_text);
    }
    function input_binding($$value) {
      binding_callbacks[$$value ? "unshift" : "push"](() => {
        ele = $$value;
        $$invalidate(0, ele);
      });
    }
    const keydown_handler2 = (e) => {
      if (e.key === "Enter") {
        send();
      }
      switch (e.key) {
        case "Enter":
          send();
          break;
        case "Escape":
          escape2();
          break;
      }
    };
    return [
      ele,
      $open_text,
      $ismobile,
      send,
      escape2,
      input_input_handler,
      input_binding,
      keydown_handler2
    ];
  }
  var Text = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance14, create_fragment16, safe_not_equal, {});
    }
  };
  var text_default = Text;

  // src/ui/loading.svelte
  function create_fragment17(ctx) {
    let div4;
    let div0;
    let t0;
    let title;
    let t1;
    let div3;
    let div1;
    let t2;
    let textarea;
    let t3;
    let div2;
    let current;
    title = new title_default({});
    return {
      c() {
        div4 = element("div");
        div0 = element("div");
        t0 = space();
        create_component(title.$$.fragment);
        t1 = space();
        div3 = element("div");
        div1 = element("div");
        t2 = space();
        textarea = element("textarea");
        t3 = space();
        div2 = element("div");
        attr(div0, "class", "sprites sprite svelte-134u19r");
        attr(div1, "class", "flex svelte-134u19r");
        attr(textarea, "type", "text");
        attr(textarea, "class", "text button svelte-134u19r");
        attr(textarea, "maxlength", "200");
        textarea.value = ctx[0];
        textarea.readOnly = true;
        attr(div2, "class", "flex svelte-134u19r");
        attr(div3, "class", "span2 full svelte-134u19r");
        attr(div4, "class", "menu svelte-134u19r");
      },
      m(target, anchor) {
        insert(target, div4, anchor);
        append(div4, div0);
        append(div4, t0);
        mount_component(title, div4, null);
        append(div4, t1);
        append(div4, div3);
        append(div3, div1);
        append(div3, t2);
        append(div3, textarea);
        append(div3, t3);
        append(div3, div2);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (!current || dirty & 1) {
          textarea.value = ctx2[0];
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(title.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(title.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        if (detaching)
          detach(div4);
        destroy_component(title);
      }
    };
  }
  function instance15($$self, $$props, $$invalidate) {
    let $loading;
    component_subscribe($$self, loading, ($$value) => $$invalidate(0, $loading = $$value));
    return [$loading];
  }
  var Loading = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance15, create_fragment17, safe_not_equal, {});
    }
  };
  var loading_default = Loading;

  // src/ui/help.svelte
  function create_fragment18(ctx) {
    let div5;
    let div0;
    let t0;
    let div4;
    let div3;
    let div1;
    let t1;
    let textarea;
    let t2;
    let div2;
    let mounted;
    let dispose;
    return {
      c() {
        div5 = element("div");
        div0 = element("div");
        t0 = space();
        div4 = element("div");
        div3 = element("div");
        div1 = element("div");
        t1 = space();
        textarea = element("textarea");
        t2 = space();
        div2 = element("div");
        attr(div0, "class", "sprites sprite svelte-1qmwcry");
        attr(div1, "class", "flex svelte-1qmwcry");
        attr(textarea, "type", "text");
        attr(textarea, "class", "text button svelte-1qmwcry");
        attr(textarea, "maxlength", "200");
        textarea.value = ctx[0];
        textarea.readOnly = true;
        attr(div2, "class", "flex svelte-1qmwcry");
        attr(div3, "class", "span2 full svelte-1qmwcry");
        attr(div4, "class", "vbox svelte-1qmwcry");
        attr(div5, "class", "menu svelte-1qmwcry");
      },
      m(target, anchor) {
        insert(target, div5, anchor);
        append(div5, div0);
        append(div5, t0);
        append(div5, div4);
        append(div4, div3);
        append(div3, div1);
        append(div3, t1);
        append(div3, textarea);
        append(div3, t2);
        append(div3, div2);
        if (!mounted) {
          dispose = [
            listen(div1, "click", ctx[1]),
            listen(div2, "click", ctx[1])
          ];
          mounted = true;
        }
      },
      p(ctx2, [dirty]) {
        if (dirty & 1) {
          textarea.value = ctx2[0];
        }
      },
      i: noop,
      o: noop,
      d(detaching) {
        if (detaching)
          detach(div5);
        mounted = false;
        run_all(dispose);
      }
    };
  }
  function instance16($$self, $$props, $$invalidate) {
    let $helptext;
    component_subscribe($$self, helptext, ($$value) => $$invalidate(0, $helptext = $$value));
    function close() {
      open_help.set(false);
    }
    return [$helptext, close];
  }
  var Help = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance16, create_fragment18, safe_not_equal, {});
    }
  };
  var help_default = Help;

  // src/main.svelte
  function create_if_block_3(ctx) {
    let help;
    let current;
    help = new help_default({});
    return {
      c() {
        create_component(help.$$.fragment);
      },
      m(target, anchor) {
        mount_component(help, target, anchor);
        current = true;
      },
      i(local) {
        if (current)
          return;
        transition_in(help.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(help.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(help, detaching);
      }
    };
  }
  function create_if_block_2(ctx) {
    let loading3;
    let current;
    loading3 = new loading_default({});
    return {
      c() {
        create_component(loading3.$$.fragment);
      },
      m(target, anchor) {
        mount_component(loading3, target, anchor);
        current = true;
      },
      i(local) {
        if (current)
          return;
        transition_in(loading3.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(loading3.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(loading3, detaching);
      }
    };
  }
  function create_if_block_1(ctx) {
    let home;
    let current;
    home = new home_default({});
    return {
      c() {
        create_component(home.$$.fragment);
      },
      m(target, anchor) {
        mount_component(home, target, anchor);
        current = true;
      },
      i(local) {
        if (current)
          return;
        transition_in(home.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(home.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(home, detaching);
      }
    };
  }
  function create_if_block5(ctx) {
    let game;
    let current;
    game = new game_default({});
    return {
      c() {
        create_component(game.$$.fragment);
      },
      m(target, anchor) {
        mount_component(game, target, anchor);
        current = true;
      },
      i(local) {
        if (current)
          return;
        transition_in(game.$$.fragment, local);
        current = true;
      },
      o(local) {
        transition_out(game.$$.fragment, local);
        current = false;
      },
      d(detaching) {
        destroy_component(game, detaching);
      }
    };
  }
  function create_fragment19(ctx) {
    let text_1;
    let t0;
    let t1;
    let t2;
    let t3;
    let if_block3_anchor;
    let current;
    text_1 = new text_default({});
    let if_block0 = ctx[0] && create_if_block_3(ctx);
    let if_block1 = ctx[1] && create_if_block_2(ctx);
    let if_block2 = ctx[2] && create_if_block_1(ctx);
    let if_block3 = ctx[3] && create_if_block5(ctx);
    return {
      c() {
        create_component(text_1.$$.fragment);
        t0 = space();
        if (if_block0)
          if_block0.c();
        t1 = space();
        if (if_block1)
          if_block1.c();
        t2 = space();
        if (if_block2)
          if_block2.c();
        t3 = space();
        if (if_block3)
          if_block3.c();
        if_block3_anchor = empty();
      },
      m(target, anchor) {
        mount_component(text_1, target, anchor);
        insert(target, t0, anchor);
        if (if_block0)
          if_block0.m(target, anchor);
        insert(target, t1, anchor);
        if (if_block1)
          if_block1.m(target, anchor);
        insert(target, t2, anchor);
        if (if_block2)
          if_block2.m(target, anchor);
        insert(target, t3, anchor);
        if (if_block3)
          if_block3.m(target, anchor);
        insert(target, if_block3_anchor, anchor);
        current = true;
      },
      p(ctx2, [dirty]) {
        if (ctx2[0]) {
          if (if_block0) {
            if (dirty & 1) {
              transition_in(if_block0, 1);
            }
          } else {
            if_block0 = create_if_block_3(ctx2);
            if_block0.c();
            transition_in(if_block0, 1);
            if_block0.m(t1.parentNode, t1);
          }
        } else if (if_block0) {
          group_outros();
          transition_out(if_block0, 1, 1, () => {
            if_block0 = null;
          });
          check_outros();
        }
        if (ctx2[1]) {
          if (if_block1) {
            if (dirty & 2) {
              transition_in(if_block1, 1);
            }
          } else {
            if_block1 = create_if_block_2(ctx2);
            if_block1.c();
            transition_in(if_block1, 1);
            if_block1.m(t2.parentNode, t2);
          }
        } else if (if_block1) {
          group_outros();
          transition_out(if_block1, 1, 1, () => {
            if_block1 = null;
          });
          check_outros();
        }
        if (ctx2[2]) {
          if (if_block2) {
            if (dirty & 4) {
              transition_in(if_block2, 1);
            }
          } else {
            if_block2 = create_if_block_1(ctx2);
            if_block2.c();
            transition_in(if_block2, 1);
            if_block2.m(t3.parentNode, t3);
          }
        } else if (if_block2) {
          group_outros();
          transition_out(if_block2, 1, 1, () => {
            if_block2 = null;
          });
          check_outros();
        }
        if (ctx2[3]) {
          if (if_block3) {
            if (dirty & 8) {
              transition_in(if_block3, 1);
            }
          } else {
            if_block3 = create_if_block5(ctx2);
            if_block3.c();
            transition_in(if_block3, 1);
            if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
          }
        } else if (if_block3) {
          group_outros();
          transition_out(if_block3, 1, 1, () => {
            if_block3 = null;
          });
          check_outros();
        }
      },
      i(local) {
        if (current)
          return;
        transition_in(text_1.$$.fragment, local);
        transition_in(if_block0);
        transition_in(if_block1);
        transition_in(if_block2);
        transition_in(if_block3);
        current = true;
      },
      o(local) {
        transition_out(text_1.$$.fragment, local);
        transition_out(if_block0);
        transition_out(if_block1);
        transition_out(if_block2);
        transition_out(if_block3);
        current = false;
      },
      d(detaching) {
        destroy_component(text_1, detaching);
        if (detaching)
          detach(t0);
        if (if_block0)
          if_block0.d(detaching);
        if (detaching)
          detach(t1);
        if (if_block1)
          if_block1.d(detaching);
        if (detaching)
          detach(t2);
        if (if_block2)
          if_block2.d(detaching);
        if (detaching)
          detach(t3);
        if (if_block3)
          if_block3.d(detaching);
        if (detaching)
          detach(if_block3_anchor);
      }
    };
  }
  function instance17($$self, $$props, $$invalidate) {
    let $open_help;
    let $open_loading;
    let $open_home;
    let $open_game;
    component_subscribe($$self, open_help, ($$value) => $$invalidate(0, $open_help = $$value));
    component_subscribe($$self, open_loading, ($$value) => $$invalidate(1, $open_loading = $$value));
    component_subscribe($$self, open_home, ($$value) => $$invalidate(2, $open_home = $$value));
    component_subscribe($$self, open_game, ($$value) => $$invalidate(3, $open_game = $$value));
    return [$open_help, $open_loading, $open_home, $open_game];
  }
  var Main = class extends SvelteComponent {
    constructor(options) {
      super();
      init(this, options, instance17, create_fragment19, safe_not_equal, {});
    }
  };
  var main_default = Main;

  // src/index.ts
  var app = new main_default({
    target: document.getElementById("svelte"),
    props: {}
  });
  window.addEventListener("contextmenu", (e) => e.preventDefault());
})();
//!\ DECLARE ALIAS AFTER assign prototype !
